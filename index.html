<!DOCTYPE html>

<html lang="zh-CN">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>AI 对话</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

        
   

<style>
/* 
================================================================
    ✨ 少女心美化主题 v1.0 ✨
    由 AI 助手为您专属定制
================================================================
*/

/* --- 1. 全局与主题变量 (全新少女心配色) --- */
:root {
    /* 主题渐变色：从蜜桃色到樱花粉 */
    --accent-gradient: linear-gradient(135deg, #FFC3A0 0%, #FFAFBD 100%);
    /* 主题色 */
    --accent-color: #FFAFBD;
    --accent-color-deep: #E68FA0;
    /* 背景色 */
    --bg-main: #FFF8FA; /* 非常浅的粉色背景 */
    --bg-light: #FFFFFF;
    /* 边框与分隔线 */
    --border-color: #FDE9ED; /* 粉色调边框 */
    /* 文字颜色 */
    --text-color-dark: #5c5456; /* 柔和的深灰棕色 */
    --text-color-medium: #b8a6a9; /* 柔和的中灰粉色 */
    --text-color-light: #d8c6c9; /* 柔和的浅灰粉色 */
    /* 气泡与卡片背景 */
    --player-bubble-bg: var(--accent-gradient); /* 发送气泡使用渐变 */
    --player-bubble-bg-light: #FFF0F3; /* 浅粉色，用于发送的卡片 */
    --ai-bubble-bg: var(--bg-light);
    /* 阴影与危险色 */
    --shadow-light: 0 4px 12px rgba(255, 175, 189, 0.15); /* 粉色调的柔和阴影 */
    --danger-color: #FF7B7B; /* 更柔和的红色 */
    /* 字体与悬停 */
    --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
    --font-title: var(--font-main);
    --hover-bg-color: rgba(255, 175, 189, 0.08); /* 粉色调悬停背景 */
}



/* --- 2. 基础重置与布局 (增加柔和背景) --- */
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; overflow: hidden; font-family: var(--font-main); color: var(--text-color-dark); }
body { 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    background: linear-gradient(to top, #fff1f4 0%, #fde6e8 100%); /* 页面外框的梦幻渐变 */
}
#app-container { 
    width: 100%; 
    height: 100%; 
    max-width: 500px; 
    background-color: var(--bg-main);
    display: flex; 
    flex-direction: column; 
    overflow: hidden; 
    position: relative; 
    border-radius: 40px; /* 更圆润的边角 */
    box-shadow: 0 10px 40px rgba(230, 131, 150, 0.25); /* 更柔和的粉色阴影 */
    border: 6px solid white; /* 增加白色边框，更有层次感 */
}
#main-content { flex-grow: 1; position: relative; overflow: hidden; display: flex; }



/* --- 3. 页面切换与全屏模式 (无变化) --- */
.page { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; flex-direction: column; overflow: hidden; animation: fadeIn 0.3s ease-in-out; }


.page.active { display: flex; }
@keyframes fadeIn { from { opacity: 0.8; transform: scale(0.99); } to { opacity: 1; transform: scale(1); } }
#app-container.full-page #bottom-nav { display: none; }

/* --- 4. 通用页面头部 (增加柔和感) --- */
.page-header { padding: 12px 15px; display: grid; grid-template-columns: 60px 1fr 60px; align-items: center; text-align: center; background-color: rgba(255,255,255,0.6); backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); flex-shrink: 0; min-height: 56px; }
.page-header h1 { font-size: 1.1rem; font-weight: 600; color: var(--text-color-dark); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

.page-header .header-icon { font-size: 1.2rem; color: var(--text-color-dark); transition: transform 0.2s; }
.page-header .header-icon:active { transform: scale(0.9); }
.header-btn { background: none; border: none; font-size: 1rem; font-weight: 600; color: var(--accent-color); cursor: pointer; }

.page-content { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }



/* --- 5. 底部导航栏 (美化) --- */
#bottom-nav { 
    display: flex; 
    width: 100%; 
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color); 
    padding: 6px 0 8px 0; 
    flex-shrink: 0; 
    box-shadow: 0 -2px 10px rgba(0,0,0,0.04);
}
.nav-item { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; color: var(--text-color-medium); transition: all 0.3s ease; }
.nav-item.active { 
    color: var(--accent-color); 
    transform: translateY(-2px); /* 选中项轻微上浮 */
}
.nav-item.active i {
    text-shadow: 0 0 10px var(--accent-color); /* 增加辉光效果 */
}
.nav-item:active { transform: scale(0.95); }
.nav-item i { font-size: 1.3rem; margin-bottom: 3px; }
.nav-item span { font-size: 0.7rem; }
/* --- 6. 会话列表页 (头像圆角化) --- */
#page-conversations .page-header { background-color: var(--bg-light); }
#my-avatar { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; cursor: pointer; border: 2px solid white; box-shadow: var(--shadow-light); }
#page-conversations .page-content { padding: 0; }
.list-item { position: relative; display: flex; align-items: center; padding: 12px 15px; cursor: pointer; background-color: var(--bg-light); transition: background-color 0.2s, transform 0.2s ease-in-out; }
.list-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.list-item:active { background-color: var(--hover-bg-color); }
.list-item.pinned {
    background-color: var(--border-color); /* 使用主题边框粉色，比背景更深 */
}


.item-avatar { width: 50px; height: 50px; border-radius: 50%; /* 头像全部变圆 */ object-fit: cover; margin-right: 12px; flex-shrink: 0; background-color: #eee; border: 1px solid var(--border-color); }
.item-content { flex-grow: 1; overflow: hidden; }
.item-name { font-weight: 600; font-size: 1.05rem; margin-bottom: 5px; color: var(--text-color-dark); }
.item-last-msg { font-size: 0.85rem; color: var(--text-color-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.empty-placeholder { display: none; text-align: center; padding-top: 80px; color: var(--text-color-light); font-size: 0.9rem; }
/* --- 7. 聊天页面 (核心美化) --- */
#page-chat .page-header { background-color: transparent; }
#chat-header-container { display: flex; flex-direction: column; align-items: center; justify-content: center; }
#chat-header-subtitle { font-size: 0.75rem; color: var(--text-color-medium); font-weight: 400; height: 0; opacity: 0; transition: height 0.3s ease, opacity 0.3s ease; }
#chat-header-subtitle.visible { height: 15px; opacity: 1; }

.chat-area { flex-grow: 1; padding: 20px 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; background-color: transparent; }

/* ▼▼▼ 新增：“线下场景/小说模式”样式 ▼▼▼ */
.chat-area.offline-mode {
    background-color: #F5F5F7; /* 一个柔和的灰色背景，适合阅读 */
    padding: 10px;
}
.narrative-block {
    background-color: var(--bg-light);
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    font-family: 'Songti SC', 'STSong', 'SimSun', serif; /* 优先使用宋体，更有文学感 */
    line-height: 1.8;
    color: #333;
}
.narrative-block .narration {
    text-indent: 2em; /* 首行缩进 */
    margin-bottom: 15px;
}
.narrative-block .dialogue {
    margin: 10px 0;
    padding-left: 1.5em; /* 对话前也留出空间 */
    font-weight: 500;
}
.narrative-block .dialogue.player {
    color: var(--accent-color-deep); /* 玩家的对话用主题色突出 */
}
/* ▲▲▲ 新增完成 ▲▲▲ */

.message-row { display: flex; max-width: 80%; width: fit-content; }
.message-row.sent { align-self: flex-end; }
.message-row.received { align-self: flex-start; }
.message-avatar { width: 42px; height: 42px; border-radius: 50%; /* 头像变圆 */ object-fit: cover; flex-shrink: 0; }
.message-row.sent .message-avatar { margin-left: 10px; order: 2; }
.message-row.received .message-avatar { margin-right: 10px; }
.bubble { 
    padding: 10px 16px; /* 增大内边距 */
    border-radius: 22px; /* 更圆润 */
    word-break: break-word; 
    white-space: pre-wrap; 
    line-height: 1.5; 
    font-size: 1rem; 
    position: relative; 
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 更Q弹的动画 */
    box-shadow: var(--shadow-light); 
}

@keyframes popIn { from { transform: scale(0.8) translateY(5px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }

.bubble::after { content: ''; position: absolute; top: 14px; border-width: 6px; border-style: solid; }
.bubble.sent { 
    background: var(--player-bubble-bg); 
    border-radius: 22px 22px 6px 22px; 
    color: white;
    text-shadow: 0 1px 1px rgba(0,0,0,0.1);
}
.bubble.sent::after { right: -10px; border-color: transparent transparent transparent var(--accent-color); }
.bubble.received { background-color: var(--ai-bubble-bg); border-radius: 22px 22px 22px 6px; }
.bubble.received::after { left: -10px; border-color: transparent var(--ai-bubble-bg) transparent transparent; }

.chat-input-area { 
    display: flex; 
    align-items: center; 
    padding: 8px 30px 8px 0px; /* 核心修改：左边距6px, 右边距12px */
    border-top: 1px solid var(--border-color); 
    background-color: var(--bg-light);
    flex-shrink: 0; 
    gap: 6px; 
}






/* 核心美化：将功能按钮改为粉色渐变圆圈 */
/* 核心美化：将功能按钮改为粉色渐变圆圈 */
#trigger-ai-btn,
#toggle-input-mode-btn,
#toggle-functions-btn {
    background: var(--accent-gradient); /* 使用主题渐变色 */
    border: none;
    color: white; /* 图标改为白色 */
    width: 34px; /* 核心修改：缩小宽度 */
    height: 34px; /* 核心修改：缩小高度 */
    border-radius: 50%; /* 变为圆形 */
    font-size: 1rem; /* 核心修改：图标也相应缩小 */
    cursor: pointer;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    box-shadow: 0 2px 4px rgba(255, 175, 189, 0.4);
    transition: all 0.2s;
}

#trigger-ai-btn:active,
#toggle-input-mode-btn:active,
#toggle-functions-btn:active {
    transform: scale(0.9);
    box-shadow: 0 1px 2px rgba(255, 175, 189, 0.4);
}


#message-input { 
    flex-grow: 1; 
    border: 1px solid var(--border-color); /* 核心修改：添加边框 */
    background: var(--bg-light); 
    padding: 10px 15px; 
    border-radius: 20px; 
    font-size: 1rem; 
    outline: none;
    transition: box-shadow 0.2s, border-color 0.2s; /* 增加边框颜色过渡 */
}

#message-input:focus {
    box-shadow: 0 0 0 3px rgba(255, 175, 189, 0.4);
}

#send-btn {
    background: var(--accent-gradient);
    border: none;
    color: white;
    width: 32px; /* 核心修改：再次缩小宽度 */
    height: 32px; /* 核心修改：再次缩小高度 */
    border-radius: 50%;
    font-size: 0.9rem; /* 核心修改：图标也相应缩小 */
    cursor: pointer;
    transition: all 0.2s;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    box-shadow: 0 2px 5px rgba(255, 175, 189, 0.5);
}



#send-btn:active { transform: scale(0.9); box-shadow: 0 1px 2px rgba(255, 175, 189, 0.5); }
#send-btn:disabled, #trigger-ai-btn:disabled { opacity: 0.5; cursor: not-allowed; }
#message-input:disabled { background-color: #f0f0f0; }

@keyframes heartbeat { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }
#show-thought-btn { color: var(--danger-color); animation: heartbeat 1.5s ease-in-out infinite; }

.system-message-container { display: flex; justify-content: center; padding: 5px 0; font-size: 0.8rem; color: var(--text-color-light); }
.re-edit-link { color: var(--accent-color); margin-left: 5px; cursor: pointer; }

/* ... (后续其他CSS保持不变，仅调整颜色和圆角) ... */
.context-menu {
    position: absolute; display: none; background-color: rgba(255,255,255,0.8); backdrop-filter: blur(10px); border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 1001; align-items: center; padding: 0; border: 1px solid var(--border-color); overflow: hidden;
}
.context-menu-item {
    padding: 8px 16px; font-size: 0.85rem; color: var(--text-color-dark); cursor: pointer; transition: background-color 0.2s; white-space: nowrap;
}
.context-menu-item:not(:last-child) {
    border-right: 1px solid var(--border-color);
}
.context-menu-item:hover { background-color: var(--hover-bg-color); }
.context-menu-item:active { background-color: #FDE9ED; }

.bubble.voice { display: flex; align-items: center; gap: 8px; cursor: pointer; min-width: 80px; justify-content: space-between; }
.voice-icon { font-size: 1.1rem; }
.bubble.sent .voice-icon { color: white; order: 2; }
.bubble.received .voice-icon { color: var(--text-color-medium); }
.voice-duration { font-size: 0.9rem; white-space: nowrap; }
.bubble.sent .voice-duration { color: rgba(255,255,255,0.9); }
.bubble.received .voice-duration { color: var(--text-color-medium); }
.bubble-container { position: relative; }

.voice-to-text { display: none; position: absolute; top: 100%; margin-top: 8px; z-index: 10; padding: 10px 14px; background-color: var(--bg-light); border-radius: 18px; font-size: 0.95rem; line-height: 1.6; color: var(--text-color-dark); box-shadow: var(--shadow-light); word-break: break-word; white-space: pre-wrap; min-width: 150px; }
.message-row.sent .voice-to-text { right: 0; border-radius: 18px 18px 4px 18px; }
.message-row.received .voice-to-text { left: 0; border-radius: 18px 18px 18px 4px; }
.voice-to-text::after { content: ''; position: absolute; border-width: 6px; border-style: solid; top: -10px; }
.message-row.sent .voice-to-text::after { right: 14px; border-color: transparent transparent var(--bg-light) transparent; }
.message-row.received .voice-to-text::after { left: 14px; border-color: transparent transparent var(--bg-light) transparent; }
.voice-to-text.visible { display: block; }

#hold-to-talk-btn { flex-grow: 1; border: 1px solid var(--border-color); background: var(--bg-light); padding: 10px 15px; border-radius: 12px; font-size: 1rem; font-weight: 500; color: var(--text-color-dark); text-align: center; cursor: pointer; display: none; }
#hold-to-talk-btn:active { background-color: #FDE9ED; }
.chat-input-area.voice-mode #message-input, .chat-input-area.voice-mode #send-btn { display: none; }
.chat-input-area.voice-mode #hold-to-talk-btn { display: block; }




/* --- 8. 设置 & 发现页面 (圆角化) --- */
#page-settings .page-content, #page-discover .page-content { padding: 15px; }
.settings-list { display: flex; flex-direction: column; gap: 10px; }
.setting-item { display: flex; align-items: center; padding: 16px; cursor: pointer; background-color: var(--bg-light); border-radius: 16px; /* 更大的圆角 */ transition: all 0.2s; box-shadow: var(--shadow-light); }
.setting-item:active { background-color: var(--hover-bg-color); transform: scale(0.98); }
.setting-item i { font-size: 1.2rem; color: var(--accent-color); margin-right: 15px; width: 25px; text-align: center; }
.setting-item span { font-size: 1rem; flex-grow: 1; }
.setting-item .fa-chevron-right { color: var(--text-color-light); font-size: 0.9rem; }
#page-api-settings .page-content { padding: 20px 15px; }
.api-settings-group { display: flex; flex-direction: column; gap: 1px; border-radius: 16px; overflow: hidden; box-shadow: var(--shadow-light); }
.api-setting-item { background-color: var(--bg-light); padding: 15px; }
.api-setting-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.api-setting-item label { display: block; margin-bottom: 8px; font-size: 0.9rem; color: var(--text-color-medium); }
.api-setting-item input { width: 100%; border: none; outline: none; font-size: 1rem; padding: 8px 0; background: transparent; }
#save-settings-btn, #save-moments-settings-btn { 
    margin-top: 30px; width: 100%; padding: 14px; font-size: 1rem; font-weight: 600; background: var(--accent-gradient); color: white; border: none; border-radius: 25px; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 10px rgba(255, 175, 189, 0.4);
}
#save-settings-btn:active, #save-moments-settings-btn:active { transform: scale(0.98); box-shadow: 0 2px 5px rgba(255, 175, 189, 0.4); }


/* --- 9. 通讯录页面 (美化) --- */
#page-contacts .page-header { background-color: var(--bg-light); }
#page-contacts .page-content { padding: 0; }
.contacts-tabs { display: flex; justify-content: center; padding: 0 15px; background-color: var(--bg-light); border-bottom: 1px solid var(--border-color); }

.contact-tab { padding: 12px 16px; cursor: pointer; color: var(--text-color-medium); font-weight: 500; border-bottom: 3px solid transparent; transition: all 0.2s; position: relative; }
.contact-tab.active { color: var(--accent-color); border-bottom-color: var(--accent-color); }
.contact-tab.active::after { content: ''; }
.contact-group { display: none; }
.contact-group.active { display: block; }
.group-header { padding: 6px 15px; background-color: var(--bg-main); color: var(--text-color-medium); font-size: 0.8rem; font-weight: 500; }
.contact-list { list-style: none; background-color: var(--bg-light); }
.contact-item .item-name { font-size: 1rem; margin: 0; }

/* --- 10. 创建/编辑页面通用表单样式 --- */

/* ... (后续所有CSS都已基于新主题色和圆角风格进行调整) ... */

.page-form-content { padding: 15px; }
.form-group { margin-bottom: 10px; background-color: var(--bg-light); padding: 12px 15px; border-radius: 16px; }
.form-group label { display: block; color: var(--text-color-dark); font-size: 1rem; margin-bottom: 8px; font-weight: 500; }
.form-group input, .form-group select, .form-group textarea { width: 100%; padding: 8px 0; border: none; font-size: 1rem; background-color: transparent; font-family: var(--font-main); color: var(--text-color-dark); -webkit-appearance: none; appearance: none; outline: none; }
.form-group textarea { resize: vertical; min-height: 60px; }
.form-group select { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 0.8em; }
.avatar-upload-area { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px 0; }
.avatar-preview { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; background-color: #eee; cursor: pointer; border: 3px solid var(--bg-light); box-shadow: var(--shadow-light); }
.avatar-file-input { display: none; }
.member-selection-list { max-height: 200px; overflow-y: auto; background-color: transparent; padding: 0; }
.member-item { display: flex; align-items: center; padding: 8px 0; }
.member-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.member-item input[type="checkbox"] { margin-right: 15px; width: 18px; height: 18px; accent-color: var(--accent-color); }
.member-item img { width: 36px; height: 36px; border-radius: 50%; margin-right: 10px; }

/* --- 11. 我的信息页专属样式 --- */
#page-my-info .page-header { background-color: var(--bg-light); }
#page-my-info .page-header h1 { position: relative; }
#page-my-info .page-header h1::after { content: ''; position: absolute; bottom: -12px; left: 50%; transform: translateX(-50%); width: 30px; height: 3px; background: var(--accent-gradient); border-radius: 2px; }
.form-actions-bar { display: flex; gap: 10px; margin-top: 20px; }
.form-actions-bar button { flex: 1; padding: 12px; border-radius: 25px; border: 1px solid var(--border-color); background-color: var(--bg-light); font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s; }
.form-actions-bar .btn-save { background: var(--accent-gradient); color: white; border-color: transparent; }
.form-actions-bar .btn-delete { color: var(--danger-color); border-color: #ffe0e0; }
.form-actions-bar button:active { transform: scale(0.98); }

/* 新增: 添加好友页面的底部按钮样式 */


.create-friend-actions { display: flex; gap: 15px; padding: 15px; margin-top: 15px; }
.create-friend-actions button { flex: 1; padding: 14px; font-size: 1rem; font-weight: 600; border-radius: 25px; border: none; cursor: pointer; transition: all 0.2s; }
.create-friend-actions .btn-cancel {
    background-color: var(--bg-light); /* 改为白色 */
    color: var(--text-color-dark);
    border: 1px solid var(--border-color); /* 增加淡淡的粉色边框 */
}

.create-friend-actions .btn-add { background: var(--accent-gradient); color: white; }
.create-friend-actions button:active { transform: scale(0.98); }

/* --- 12. 弹窗与提示 --- */

/* 新增: 选择器弹窗的专属样式 */
.selection-list { display: flex; flex-direction: column; }
.selection-option-item { display: flex; justify-content: space-between; align-items: center; padding: 14px 10px; cursor: pointer; font-size: 1rem; }
.selection-option-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.selection-option-icon { font-size: 1.2rem; color: var(--text-color-light); }
.selection-option-item.selected .selection-option-icon { color: var(--accent-color); }
.form-group.selectable { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
.form-group.selectable .form-value { display: flex; align-items: center; gap: 8px; color: var(--text-color-medium); }
.form-group.selectable .form-value .fa-chevron-right { font-size: 0.8em; }


.toast-notification { 
    position: fixed; 
    bottom: 20%; 
    left: 50%; 
    transform: translateX(-50%); 
    background-color: var(--bg-light); /* 核心修改：改为白色 */
    backdrop-filter: blur(8px); 
    color: var(--text-color-dark); /* 核心修改：文字改为深色 */
    padding: 12px 22px; 
    border-radius: 25px; 
    font-size: 0.9rem; 
    z-index: 10000; 
    opacity: 0; 
    pointer-events: none; 
    transition: opacity 0.3s ease-in-out; 
    box-shadow: var(--shadow-light); /* 改为主题粉色阴影 */
    border: 1px solid var(--border-color); /* 增加淡淡的粉色边框 */
}

.toast-notification.show { opacity: 1; }
.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 1000; }
.modal-overlay.visible { display: flex; }
.modal-content { background: var(--bg-light); padding: 20px; border-radius: 24px; width: 85%; max-width: 320px; box-shadow: 0 5px 25px rgba(0,0,0,0.1); }
.modal-header { font-size: 1.1rem; font-weight: 600; margin-bottom: 15px; text-align: center; }
.modal-actions { display: flex; gap: 10px; margin-top: 20px; }
.modal-btn { flex: 1; padding: 12px; border: none; border-radius: 25px; cursor: pointer; font-size: 1rem; font-weight: 600; transition: all 0.2s; }
.modal-btn:active { transform: scale(0.98); }
.btn-primary { background: var(--accent-gradient); color: white; }
.btn-secondary { 
    background-color: var(--bg-light); /* 改为白色 */
    color: var(--text-color-dark); /* 改为主题深色文字 */
    border: 1px solid var(--border-color); /* 增加淡淡的粉色边框 */
}


/* --- 13. 通讯录添加弹窗 (新样式) --- */
/* --- 12.5. 聊天设置弹窗 (新增) --- */


.chat-options-title { font-size: 1.2rem; font-weight: 600; padding: 10px 15px 15px 15px; text-align: left; }
#chat-options-modal .modal-content { background-color: var(--bg-main); }
#chat-options-modal .add-option-item { margin: 0 10px; width: auto; }


.modal-overlay.from-bottom { align-items: flex-end; background: rgba(0,0,0,0); transition: background 0.3s ease-out; }
.modal-overlay.from-bottom.visible { background: rgba(0,0,0,0.4); backdrop-filter: blur(2px); }
.modal-overlay.from-bottom .modal-content { width: 100%; max-width: 500px; background-color: var(--bg-main); border-radius: 24px 24px 0 0; padding: 10px 15px 30px 15px; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 0 -5px 25px rgba(0,0,0,0.1); }
.modal-overlay.from-bottom.visible .modal-content { transform: translateY(0); }
.add-options-list { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
.add-option-item { display: flex; align-items: center; padding: 16px; background-color: var(--bg-light); border-radius: 16px; cursor: pointer; transition: background-color 0.2s; }
.add-option-item:active { background-color: #FDE9ED; }
.add-option-icon { width: 24px; text-align: center; margin-right: 15px; }
.add-option-icon i { color: var(--accent-color); font-size: 1.2rem; }
.add-option-item span { flex-grow: 1; font-size: 1rem; font-weight: 500; }
.add-option-item .fa-chevron-right { color: var(--text-color-light); font-size: 0.9rem; }

/* --- 14. 编辑/删除模式 --- */
.edit-mode .list-item { transform: translateX(45px); }
.list-item .select-checkbox { position: absolute; left: -30px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; accent-color: var(--accent-color); }
.edit-mode-bar { position: absolute; bottom: 0; left: 0; right: 0; height: 60px; background-color: var(--bg-light); border-top: 1px solid var(--border-color); display: none; justify-content: space-between; align-items: center; padding: 0 20px; animation: slideUp 0.2s ease-out; }
@keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
.edit-mode-bar.visible { display: flex; }
.edit-mode-bar button { padding: 8px 20px; border-radius: 20px; border: 1px solid var(--border-color); background-color: transparent; font-size: 0.9rem; cursor: pointer; font-weight: 500; }
.edit-mode-bar .delete-btn { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }

/* --- 15. 钱包页面专属样式 (新增) --- */

.wallet-balance-card { background: var(--accent-gradient); color: white; padding: 25px 20px; border-radius: 24px; margin: 15px; text-align: center; box-shadow: 0 4px 15px rgba(255, 175, 189, 0.4); }
.wallet-balance-card .balance-label { font-size: 0.9rem; opacity: 0.8; margin-bottom: 8px; }
.wallet-balance-card .balance-amount { font-size: 2.2rem; font-weight: 600; letter-spacing: 1px; }
.wallet-balance-card .edit-balance-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; cursor: pointer; margin-left: 10px; }
.transaction-list-header { padding: 15px 15px 5px 15px; font-size: 0.9rem; font-weight: 500; color: var(--text-color-medium); }
.transaction-list { margin: 0 15px; background-color: var(--bg-light); border-radius: 16px; overflow: hidden; }
.transaction-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; }
.transaction-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.transaction-details .reason { font-size: 1rem; font-weight: 500; }
.transaction-details .date { font-size: 0.8rem; color: var(--text-color-light); margin-top: 4px; }
.transaction-amount { font-size: 1.1rem; font-weight: 600; }
.transaction-amount.income {
    color: var(--accent-color); /* 核心修改：改为主题粉色 */
}

.transaction-amount.expense { color: var(--danger-color); }
.transaction-delete-btn {
    background: none;
    border: none;
    color: var(--text-color-light);
    font-size: 1rem;
    cursor: pointer;
    padding: 5px 10px;
    margin-left: 10px;
    transition: color 0.2s;
}
.transaction-delete-btn:hover {
    color: var(--danger-color);
}

/* 新增: 让减号和日记图标有特殊颜色 */

.header-icon.icon-danger { color: var(--danger-color); }

.header-icon.icon-diary {
    color: #FFD700; /* 明亮的金黄色，像阳光一样温暖 */
}


/* --- 15.5. 朋友圈交互样式 (新增) --- */

/* ▼▼▼ 新增：作者栏和三点按钮的样式 ▼▼▼ */

.moment-author-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.moment-options-btn { color: var(--text-color-medium); cursor: pointer; padding: 4px 8px; border-radius: 4px; font-size: 1rem; transition: background-color 0.2s; }
.moment-options-btn:active { background-color: var(--hover-bg-color); }
.moment-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
.moment-actions { display: flex; gap: 5px; }
.action-btn { background: var(--bg-main); border: none; padding: 6px 10px; border-radius: 15px; cursor: pointer; font-size: 0.8rem; color: var(--text-color-dark); display: flex; align-items: center; gap: 5px; }
.action-btn i { font-size: 0.9rem; }
.action-btn.liked { color: var(--danger-color); font-weight: 600; }
.moment-footer .left-side { display: flex; align-items: center; gap: 12px; color: var(--text-color-light); font-size: 0.8rem; }
.moment-post-controls { display: flex; align-items: center; gap: 10px; }
.delete-moment-btn { color: var(--text-color-light); cursor: pointer; font-size: 0.85rem; transition: color 0.2s; }
.delete-moment-btn:hover { color: var(--danger-color); }


.moment-social-feed { background-color: var(--bg-main); border-radius: 12px; margin-top: 12px; padding: 2px 12px; font-size: 0.9rem; }
.likes-section { padding: 8px 0; display: flex; align-items: center; gap: 6px; color: var(--accent-color); border-bottom: 1px solid var(--border-color); }
.likes-section.no-comments { border-bottom: none; }
.likes-section .fa-heart { font-size: 0.8rem; color: var(--danger-color); }
.comments-section { padding: 5px 0; }
.comment-item { padding: 5px 0; line-height: 1.5; display: flex; justify-content: space-between; align-items: center; }
.comment-text-wrapper { flex-grow: 1; word-break: break-word; }
.comment-author { color: var(--accent-color); font-weight: 600; cursor: pointer; }
.comment-reply-to { margin: 0 4px; }
.comment-content { word-break: break-word; }
.comment-actions { flex-shrink: 0; display: flex; gap: 8px; }
.comment-delete-btn, .comment-reply-btn, .comment-edit-btn { color: var(--text-color-light); font-size: 0.7rem; cursor: pointer; transition: color 0.2s; }
.comment-delete-btn:hover, .comment-reply-btn:hover, .comment-edit-btn:hover { color: var(--accent-color); }



.comment-input-area { display: flex; gap: 8px; margin-top: 10px; }
.comment-input-area input { flex-grow: 1; border: none; background: var(--bg-main); padding: 8px 12px; border-radius: 15px; outline: none; }
.comment-input-area button { background: var(--accent-gradient); border: none; color: white; padding: 6px 15px; border-radius: 15px; font-size: 0.8rem; font-weight: 500; cursor: pointer; }

/* --- 16. 朋友圈页面 --- */

#page-moments { background-color: var(--bg-light); }
#page-moments .page-header { position: absolute; top: 0; left: 0; right: 0; background-color: transparent; border-bottom: none; z-index: 10; color: white; }
#page-moments .page-header .header-icon { color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.3); }

.moments-header { position: relative; width: 100%; height: 300px; background-color: #ccc; flex-shrink: 0; }
.moments-cover { width: 100%; height: 100%; object-fit: cover; cursor: pointer; }
.moments-user-info { position: absolute; bottom: -25px; right: 15px; display: flex; align-items: center; gap: 15px; }
.moments-user-name { font-size: 1.1rem; font-weight: 600; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); }
.moments-user-avatar { width: 70px; height: 70px; border-radius: 16px; border: 3px solid white; object-fit: cover; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
.moments-feed { padding: 40px 0 20px 0; }
.moment-post { display: flex; gap: 12px; padding: 20px 15px; border-bottom: 1px solid var(--border-color); }
.moment-avatar { width: 42px; height: 42px; border-radius: 50%; object-fit: cover; flex-shrink: 0; }
.moment-content { flex-grow: 1; }
.moment-author-name { font-size: 1rem; font-weight: 600; color: var(--accent-color); margin-bottom: 8px; }
.moment-text { font-size: 0.95rem; line-height: 1.6; margin-bottom: 10px; white-space: pre-wrap; }
.moment-images { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin-bottom: 10px; }
.moment-images.img-count-1 { grid-template-columns: minmax(0, 2fr); }
.moment-images.img-count-2, .moment-images.img-count-4 { grid-template-columns: repeat(2, 1fr); }
.moment-image { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; border-radius: 12px; }
.moment-timestamp { font-size: 0.8rem; color: var(--text-color-light); }
.moments-feed .empty-placeholder { padding-top: 40px; }

/* --- 17. 发布动态页面 --- */

#post-moment-image-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; }
.post-moment-img-preview { width: 100%; aspect-ratio: 1 / 1; border-radius: 12px; object-fit: cover; position: relative; }
#post-moment-select-img-btn { width: 100%; aspect-ratio: 1 / 1; border: 2px dashed var(--border-color); border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; color: var(--text-color-light); }
#post-moment-select-img-btn i { font-size: 1.5rem; margin-bottom: 5px; }
#post-moment-select-img-btn span { font-size: 0.8rem; }
/* --- 17.5. 心声弹窗样式 (新增) --- */


.thought-section { margin-bottom: 20px; }
.thought-section:last-child { margin-bottom: 5px; }
.thought-title { font-size: 0.9rem; font-weight: 600; color: var(--text-color-medium); margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid var(--border-color); }
.thought-content { font-size: 1rem; line-height: 1.6; color: var(--text-color-dark); white-space: pre-wrap; }
/* --- 18. 加载动画 --- */


.loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 248, 250, 0.7); backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 9999; }
.spinner { width: 40px; height: 40px; border: 4px solid rgba(255, 175, 189, 0.2); border-left-color: var(--accent-color); border-radius: 50%; animation: spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }



    ... (所有其他CSS代码) ...

/* ▼▼▼ 新增：美化通用编辑弹窗的文本域 ▼▼▼ */


#edit-info-modal textarea { width: 100%; min-height: 80px; border: 1px solid var(--border-color); border-radius: 12px; padding: 10px; font-family: var(--font-main); font-size: 1rem; resize: vertical; outline: none; }
#edit-info-modal textarea:focus { border-color: var(--accent-color); box-shadow: 0 0 0 3px rgba(255, 175, 189, 0.4); }
/* ▲▲▲ 新增完成 ▲▲▲ */
/* ========================================================== */
/* ========================================================== */
/* ========================================================== */
/* ========================================================== */
/* V9.0 升级：一起听歌/独自听歌 功能样式 */
/* ========================================================== */

/* --- 音乐播放器美化 --- */
.message-row .music-share-card { background-color: #fff; color: #333; width: 220px; padding: 12px; display: flex; align-items: center; gap: 12px; cursor: pointer; box-shadow: var(--shadow-light); border-radius: 18px 18px 18px 4px; }
.message-row.sent .music-share-card { background-color: var(--player-bubble-bg-light); border-radius: 18px 18px 4px 18px; }
.message-row.sent { justify-content: flex-end; }
.music-card-cover { width: 50px; height: 50px; background: var(--accent-gradient); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; flex-shrink: 0; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.2); animation: spin 8s linear infinite; animation-play-state: paused; }
.music-card-cover.playing { animation-play-state: running; }
.music-card-play-btn { position: absolute; color: rgba(255, 255, 255, 0.8); font-size: 18px; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
.music-card-info { flex-grow: 1; min-width: 0; }
.music-card-title { font-weight: 600; font-size: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.music-card-artist { font-size: 0.8rem; color: var(--text-color-medium); margin-top: 2px; }

/* 悬浮音乐播放器 (结构升级) */


#music-player-card { display: none; flex-direction: column; position: absolute; width: 300px; height: 450px; background-color: rgba(255, 248, 250, 0.9); backdrop-filter: blur(20px); border-radius: 24px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1); overflow: hidden; top: 50px; left: 50px; z-index: 1000; transition: all 0.4s ease-in-out; border: 1px solid rgba(255,255,255,0.5); }
.player-header { padding: 0 15px; height: 45px; font-weight: 600; color: white; background: var(--accent-gradient); cursor: move; user-select: none; display: flex; justify-content: center; align-items: center; flex-shrink: 0; position: relative; }
.player-header-title { transition: opacity 0.2s; }
.player-collapse-btn, .player-close-btn { position: absolute; top: 50%; transform: translateY(-50%); cursor: pointer; color: white; font-size: 18px; padding: 5px; }
.player-collapse-btn { left: 15px; }
.player-close-btn { right: 15px; }
.header-collapsed-content { display: none; align-items: center; gap: 10px; width: 100%; padding-left: 35px; }
.header-avatar-stack { display: flex; align-items: center; }
.header-avatar { width: 28px; height: 28px; border-radius: 50%; border: 2px solid white; object-fit: cover; }
.header-avatar:last-child { margin-left: -10px; }
.header-lyric { flex-grow: 1; font-size: 14px; font-weight: 600; color: var(--accent-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#music-player-card.collapsed .header-lyric { color: white; font-weight: 500; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
.player-main-content { flex-grow: 1; display: flex; flex-direction: column; transition: opacity 0.3s, visibility 0.3s; }
.player-avatar-stack { display: flex; justify-content: center; align-items: center; padding: 20px 0 15px; }
.player-avatar { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
.player-avatar:last-child { margin-left: -20px; }
.player-song-info { text-align: center; }
.player-title { font-size: 1.1rem; font-weight: 700; }
.player-artist { font-size: 0.9rem; color: var(--text-color-medium); margin-top: 5px; }
.lyrics-container { flex-grow: 1; overflow: hidden; position: relative; mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%); margin-top: 15px; }
.lyrics-wrapper { position: absolute; width: 100%; transition: transform 0.5s ease-out; }
.lyric-line { padding: 8px 20px; text-align: center; font-size: 1rem; color: var(--text-color-medium); transition: color 0.5s, transform 0.5s; }
.lyric-line.active { color: var(--accent-color); font-weight: 600; transform: scale(1.1); }
.player-controls-wrapper { padding: 15px 20px; border-top: 1px solid var(--border-color); }
.player-progress-bar-wrapper { display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--text-color-medium); }
.player-progress-bar { flex-grow: 1; height: 4px; background-color: rgba(0,0,0,0.1); border-radius: 2px; cursor: pointer; }
.player-progress { width: 0%; height: 100%; background: var(--accent-gradient); border-radius: 2px; }
.player-controls { display: flex; justify-content: space-around; align-items: center; font-size: 20px; margin-top: 10px; color: var(--text-color-dark); }
.player-control-btn { cursor: pointer; transition: transform 0.2s; width: 30px; text-align: center;}
.player-play-btn { font-size: 40px; color: var(--accent-color); }
#music-player-card.solo-mode .player-avatar:last-child, #music-player-card.solo-mode .header-avatar:last-child { display: none; }
#music-player-card.collapsed { height: 45px; background-color: rgba(255, 175, 189, 0.4); backdrop-filter: blur(25px); box-shadow: 0 4px 15px rgba(255, 175, 189, 0.25); }
#music-player-card.collapsed .player-header-title { display: none; }
#music-player-card.collapsed .header-collapsed-content { display: flex; }
#music-player-card.collapsed .player-main-content { visibility: hidden; opacity: 0; }
/* 音乐库页面样式 */


.music-item { background-color: white; border-radius: 12px; padding: 12px 15px; display: flex; align-items: center; justify-content: space-between; box-shadow: var(--shadow-light); margin-bottom: 10px; }
.music-info { flex-grow: 1; }
.music-title { font-weight: 600; color: #333; }
.music-artist { font-size: 14px; color: var(--text-color-medium); margin-top: 3px; }
.music-delete-btn { background: none; border: none; font-size: 16px; color: #aaa; cursor: pointer; padding: 5px; }
.music-delete-btn:hover { color: var(--danger-color); }
.keyword-item { background-color: white; border-radius: 12px; padding: 12px 15px; box-shadow: var(--shadow-light); margin-bottom: 10px; cursor: pointer; display: flex; align-items: center; gap: 10px; }
.keyword-delete-btn { background: none; border: none; font-size: 1rem; color: var(--text-color-light); cursor: pointer; padding: 5px; flex-shrink: 0; }
.keyword-delete-btn:hover { color: var(--danger-color); }
.keyword-info { flex-grow: 1; }
.keyword-title { font-weight: 600; color: #333; margin-bottom: 5px; }
.keyword-content-preview { font-size: 14px; color: var(--text-color-medium); display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; }
.keyword-picker-item { display: flex; align-items: center; gap: 15px; padding: 15px; background-color: white; border-radius: 12px; margin-bottom: 10px; cursor: pointer; }
.keyword-picker-item input[type="checkbox"] { width: 20px; height: 20px; accent-color: var(--accent-color); flex-shrink: 0; }
.music-picker-item, .playlist-item { padding: 12px 5px; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 0.9rem; }
.music-picker-item:hover, .playlist-item:hover { background-color: var(--hover-bg-color); }
.music-picker-item:last-child { border-bottom: none; }
.playlist-item .music-title { font-weight: 500; }
.playlist-item .music-artist { font-size: 0.8rem; color: var(--text-color-medium); margin-top: 3px; }
.playlist-item.active .music-title, .playlist-item.active .music-artist { color: var(--accent-color); font-weight: 600; }

/* --- 7.9. 聊天功能面板 (新增) --- */


/* ▼▼▼ 核心升级：可滑动功能面板的全新样式 ▼▼▼ */
.chat-function-panel-container {
    display: none; /* 默认隐藏整个容器 */
    flex-direction: column;
    padding: 20px 0 10px 0; /* 调整内边距 */
    background-color: var(--bg-light);
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
}
.chat-function-panel {
    display: flex; /* 改为flex布局，让页面可以并排 */
    width: 200%; /* 轨道总宽度为2个页面宽度 */
    transition: transform 0.3s ease-out; /* 滑动动画 */
}
.function-page {
    width: 50%; /* 每个页面占一半宽度 */
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    padding: 0 20px;
}
.panel-dots-indicator {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-top: 15px;
}
.panel-dots-indicator .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: var(--text-color-light);
    transition: all 0.3s;
}
.panel-dots-indicator .dot.active {
    background-color: var(--accent-color);
    width: 12px;
    border-radius: 3px;
}
/* ▲▲▲ 升级完成 ▲▲▲ */


.function-item { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; }
.function-item .icon-wrapper { width: 60px; height: 60px; background-color: var(--bg-light); border-radius: 18px; display: flex; justify-content: center; align-items: center; font-size: 1.6rem; color: var(--accent-color); box-shadow: var(--shadow-light); }
.function-item span { font-size: 0.75rem; color: var(--text-color-medium); }

/* ▼▼▼ 升级：通话记录/系统通知消息样式 ▼▼▼ */

.call-record-message,
.offline-status-message { 
    background-color: var(--bg-light);
    color: var(--text-color-medium);
    font-size: 0.75rem; 
    padding: 4px 12px; 
    border-radius: 10px; 
    display: inline-flex; 
    align-items: center; 
    gap: 6px;
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow-light);
}

/* 为线下模式提示单独设置图标颜色 */
.offline-status-message .fa-hand-sparkles {
    color: var(--accent-color);
}

/* ▲▲▲ 升级完成 ▲▲▲ */


/* --- 7.9.1 转账卡片美化 (修改) --- */


.transfer-card { width: 210px; border-radius: 18px; overflow: hidden; box-shadow: var(--shadow-light); animation: popIn 0.2s ease-out; transition: opacity 0.3s; }
.transfer-card.status-pending { cursor: pointer; }
.transfer-card.status-completed { opacity: 0.7; cursor: default; }
.transfer-card.status-completed .transfer-card-icon svg { fill: var(--text-color-light); }
.transfer-card.status-completed .transfer-card-title, .transfer-card.status-completed .transfer-card-amount { color: var(--text-color-light); }
.transfer-card.sent { background-color: var(--player-bubble-bg-light); border-radius: 18px 18px 4px 18px; }
.transfer-card.received { background-color: var(--ai-bubble-bg); border-radius: 18px 18px 18px 4px; }
.transfer-card-main { display: flex; align-items: center; padding: 12px; gap: 12px; }
.transfer-card-icon svg { width: 32px; height: 32px; fill: var(--accent-color); }
.transfer-card-details { flex-grow: 1; }
.transfer-card-title { font-size: 0.95rem; font-weight: 500; color: var(--text-color-dark); }
.transfer-card-amount { font-size: 1.4rem; font-weight: 600; color: var(--text-color-dark); margin-top: 2px; }
.transfer-card-footer { font-size: 0.75rem; padding: 6px 12px; color: var(--text-color-medium); border-top: 1px solid var(--border-color); }
.transfer-card.sent .transfer-card-footer { border-top: 1px solid rgba(255, 175, 189, 0.2); }

/* --- 12.6 转账弹窗 (新增) --- */


#transfer-modal .modal-content { padding: 0; overflow: hidden; }
.transfer-modal-header { background-color: var(--bg-main); padding: 15px; text-align: center; font-size: 1rem; color: var(--text-color-dark); border-bottom: 1px solid var(--border-color); }
.transfer-modal-body { padding: 25px 20px; }
.transfer-modal-body label { font-size: 0.9rem; color: var(--text-color-medium); }
.transfer-amount-input-wrapper { display: flex; align-items: center; border-bottom: 2px solid var(--border-color); margin-top: 10px; padding: 15px 0; }
.transfer-amount-input-wrapper span { font-size: 2rem; font-weight: 600; margin-right: 10px; color: var(--accent-color); }
.transfer-amount-input-wrapper input { flex-grow: 1; border: none; outline: none; font-size: 2.2rem; font-weight: 600; background: transparent; width: 100%; }
.transfer-modal-footer { padding: 0 20px 20px 20px; }
.transfer-confirm-btn { width: 100%; padding: 14px; font-size: 1rem; font-weight: 500; background: var(--accent-gradient); color: white; border: none; border-radius: 12px; cursor: pointer; }
.transfer-confirm-btn:disabled { background: #e0e0e0; cursor: not-allowed; }
/* ▲▲▲ 新增完成 ▲▲▲ */
/* --- 19. 视频通话页面样式 (新增) --- */

#video-call-screen, #incoming-call-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.4); backdrop-filter: blur(8px); }
.video-call-card { width: 90%; max-width: 400px; height: 75%; max-height: 650px; background-color: rgba(255, 248, 250, 0.95); border-radius: 24px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15); display: flex; flex-direction: column; color: var(--text-color-dark); overflow: hidden; }
.video-call-header { padding: 15px; text-align: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
#video-call-contact-name { font-size: 1.2rem; font-weight: 600; }

#video-call-timer { display: block; font-size: 0.9rem; color: #28a745; margin-top: 4px; font-weight: 600; }
.video-call-main { flex-grow: 1; padding: 15px; overflow: hidden; }
.narrative-feed { height: 100%; overflow-y: auto; padding-right: 10px; display: flex; flex-direction: column; gap: 12px; }
.narrative-bubble { align-self: flex-start; max-width: 95%; background-color: #fff; border: 1px solid var(--border-color); box-shadow: var(--shadow-light); padding: 10px 15px; border-radius: 18px; border-top-left-radius: 4px; font-size: 0.95rem; line-height: 1.6; }
.narrative-user-message { align-self: flex-end; background: var(--player-bubble-bg-light); padding: 10px 15px; border-radius: 18px; border-bottom-right-radius: 4px; color: var(--text-dark); font-weight: 500; max-width: 95%; font-size: 0.95rem; line-height: 1.6; }
.video-call-input-area { padding: 8px 15px; display: flex; align-items: center; border-top: 1px solid var(--border-color); background-color: rgba(255,240,243,0.5); flex-shrink: 0; }
#video-call-input { flex-grow: 1; background-color: white; border: 1px solid var(--border-color); border-radius: 20px; padding: 8px 15px; font-size: 1rem; outline: none; resize: none; }
#video-call-send-btn { background: var(--accent-gradient); color: white; border: none; border-radius: 50%; width: 38px; height: 38px; display: flex; justify-content: center; align-items: center; margin-left: 8px; cursor: pointer; font-size: 1rem; flex-shrink: 0; }
.video-call-controls { display: flex; justify-content: space-around; align-items: center; padding: 15px 20px; background-color: rgba(255,240,243,0.5); flex-shrink: 0; }
.call-control-btn { background: none; border: none; display: flex; flex-direction: column; align-items: center; cursor: pointer; color: var(--text-color-medium); }
.call-control-btn .icon-bg { 
    width: 60px; 
    height: 60px; 
    border-radius: 50%; 
    background-color: var(--bg-light); /* 改为白色 */
    display: flex; 
    justify-content: center; 
    align-items: center; 
    font-size: 26px; 
    margin-bottom: 6px; 
    color: var(--text-color-dark);
    border: 1px solid var(--border-color); /* 增加淡淡的粉色边框 */
}

.call-control-btn.hang-up .icon-bg { background-color: var(--danger-color); color: white; }
.call-control-btn span { font-size: 0.8rem; }
#incoming-call-screen { color: white; text-align: center; justify-content: space-around; padding: 80px 0; background: linear-gradient(135deg, rgba(255, 195, 160, 0.8) 0%, rgba(255, 175, 189, 0.8) 100%); }
#incoming-caller-avatar { width: 100px; height: 100px; border-radius: 50%; border: 3px solid white; margin-bottom: 15px; }
#incoming-caller-name { font-size: 1.8rem; font-weight: 600; }
#incoming-call-text { font-size: 1rem; margin-top: 10px; opacity: 0.8; }
.incoming-call-actions { width: 100%; display: flex; justify-content: space-around; padding: 0 40px; }
/* --- 20. 外卖功能专属样式 (修改) --- */

/* 新增：通用的图标占位符样式 */

.takeout-icon-placeholder { display: flex; justify-content: center; align-items: center; background-color: var(--player-bubble-bg-light); color: var(--accent-color); }
.takeout-icon-placeholder i { font-size: 1.8rem; }
.takeout-menu-item .takeout-icon-placeholder i { font-size: 2.2rem; }
.takeout-shop-item { display: flex; gap: 15px; background-color: var(--bg-light); padding: 15px; border-radius: 16px; margin-bottom: 10px; box-shadow: var(--shadow-light); cursor: pointer; }
.takeout-shop-item .logo { width: 60px; height: 60px; border-radius: 12px; flex-shrink: 0; }
.takeout-shop-item .details { flex-grow: 1; }
.takeout-shop-item .details .name { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; }
.takeout-shop-item .details .info { font-size: 0.8rem; color: var(--text-color-medium); }
.takeout-shop-header { padding-bottom: 20px; background-color: var(--bg-main); }
.takeout-shop-header .shop-info-card { margin: 15px 15px 0 15px; background-color: var(--bg-light); border-radius: 16px; padding: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 15px; }
.takeout-shop-header .shop-info-card .logo { width: 50px; height: 50px; border-radius: 12px; }
.takeout-shop-menu {
    margin: -10px 15px 0 15px; /* 核心修改1：改为外边距，并用负值微调与顶部的距离 */
    padding: 15px; /* 核心修改2：设置卡片内部的边距 */
    padding-bottom: 80px; /* 保留给底部购物车栏的空间 */
    background-color: var(--bg-light); /* 核心修改3：设置白色背景 */
    border-radius: 16px; /* 增加圆角 */
    box-shadow: var(--shadow-light); /* 增加柔和阴影 */
}

.takeout-menu-item { display: flex; gap: 12px; padding: 15px 0; border-bottom: 1px solid var(--border-color); }
.takeout-menu-item .item-img { width: 80px; height: 80px; border-radius: 12px; flex-shrink: 0; }
.takeout-menu-item .item-details { flex-grow: 1; display: flex; flex-direction: column; }
.takeout-menu-item .item-details .name { font-size: 1rem; font-weight: 500; }
.takeout-menu-item .item-details .price-action { margin-top: auto; display: flex; justify-content: space-between; align-items: center; }
.takeout-menu-item .price { font-size: 1.2rem; font-weight: 600; color: var(--danger-color); }
.takeout-menu-item .add-btn { background: var(--accent-gradient); color: white; border: none; width: 28px; height: 28px; border-radius: 50%; font-size: 1.2rem; cursor: pointer; }
#floating-cart-bar {
    position: absolute;
    bottom: 15px;
    left: 15px;
    right: 15px;
    height: 55px;
    background: var(--accent-gradient); /* 核心修改：使用主题渐变色 */
    border-radius: 28px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 8px 0 20px;
    color: white;
    transform: translateY(100px);
    transition: transform 0.3s ease-out;
    box-shadow: 0 4px 15px rgba(255, 175, 189, 0.4); /* 增加柔和的粉色阴影 */
}


#floating-cart-bar.visible { transform: translateY(0); }
#floating-cart-bar .cart-info { display: flex; align-items: center; gap: 10px; }
#floating-cart-bar .cart-info .fa-cart-shopping { font-size: 1.4rem; }
#floating-cart-bar #cart-item-count { position: absolute; top: 8px; left: 35px; background: var(--danger-color); color: white; font-size: 0.7rem; border-radius: 50%; min-width: 18px; height: 18px; display: flex; justify-content: center; align-items: center; padding: 0 4px; }
#floating-cart-bar .total-price { font-size: 1.2rem; font-weight: 600; }
#floating-cart-bar #checkout-btn {
    background-color: white; /* 核心修改：按钮变为白色 */
    border: none;
    color: var(--accent-color); /* 核心修改：文字变为主题粉色 */
    font-size: 1rem;
    font-weight: 600; /* 加粗文字 */
    padding: 0 25px;
    height: 40px;
    border-radius: 20px;
    cursor: pointer;
}
.order-confirm-section { background: var(--bg-light); border-radius: 16px; padding: 15px; margin-bottom: 15px; }
.order-confirm-section .section-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
.order-item-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
.order-item-row .item-name { color: var(--text-color-dark); }
.order-item-row .item-count { color: var(--text-color-medium); font-size: 0.9rem; }
.order-item-row .item-price { font-weight: 500; }
.order-total-row { text-align: right; margin-top: 10px; font-size: 1.3rem; font-weight: 600; }
.order-total-row span { color: var(--danger-color); }
#place-order-btn { width: 100%; padding: 14px; font-size: 1rem; font-weight: 500; background: var(--accent-gradient); color: white; border: none; border-radius: 12px; cursor: pointer; margin-top: 20px; }
#place-order-btn:disabled { background-color: #e0e0e0; cursor: not-allowed; }
.my-order-item { background-color: var(--bg-light); border-radius: 16px; margin-bottom: 10px; padding: 15px; box-shadow: var(--shadow-light); }
.my-order-item .order-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
.my-order-item .order-header .shop-name { font-weight: 600; }
.my-order-item .order-header .status { font-size: 0.9rem; color: var(--accent-color); }
.my-order-item .order-body { padding: 10px 0; font-size: 0.9rem; color: var(--text-color-medium); }
.my-order-item .order-footer { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; margin-top: 10px; border-top: 1px solid var(--border-color); }
.my-order-item .order-footer .total { font-weight: 600; font-size: 1.1rem; }
.my-order-item .order-footer .actions button { background: transparent; border: 1px solid var(--border-color); padding: 6px 12px; border-radius: 15px; font-size: 0.8rem; cursor: pointer; margin-left: 8px; }
.my-order-item .order-footer .actions .btn-primary { background: var(--accent-gradient); border-color: transparent; color: white; }
.review-section {
    margin-top: 30px; /* 核心修改：增大与上方内容的距离 */
}

.review-item { display: flex; gap: 10px; padding: 10px 0; border-top: 1px solid var(--border-color); }
.review-item:first-child { border-top: none; }
.review-item .avatar { width: 36px; height: 36px; border-radius: 50%; object-fit: cover; flex-shrink: 0; }
.review-item .content .author { font-weight: 600; }
.review-item .content .text { margin-top: 5px; font-size: 0.9rem; line-height: 1.5; }
.review-item .avatar i { font-size: 1.2rem; }
/* --- 20.5. 外卖详细购物车弹窗 (新增) --- */


.detailed-cart-item { display: flex; align-items: center; padding: 12px 5px; border-bottom: 1px solid var(--border-color); }
.detailed-cart-item .item-name { flex-grow: 1; font-size: 0.95rem; }
.detailed-cart-item .item-price { font-size: 0.9rem; color: var(--text-color-medium); margin-right: 15px; }
.quantity-control { display: flex; align-items: center; gap: 8px; }
.quantity-control button { background-color: transparent; border: 1px solid var(--border-color); color: var(--text-color-dark); width: 24px; height: 24px; border-radius: 50%; font-size: 1rem; cursor: pointer; display: flex; justify-content: center; align-items: center; padding: 0; }
.quantity-control .btn-plus { border-color: var(--accent-color); background-color: var(--accent-color); color: white; }
.quantity-control .item-count { font-size: 1rem; font-weight: 500; min-width: 20px; text-align: center; }

/* --- 20.6. 外卖分享卡片样式 (新增) --- */

.takeout-share-card { width: 220px; background-color: var(--ai-bubble-bg); border-radius: 12px; box-shadow: var(--shadow-light); overflow: hidden; cursor: pointer; }
.message-row.sent .takeout-share-card { background-color: var(--player-bubble-bg-light); }
.takeout-share-card .card-header { display: flex; align-items: center; gap: 10px; padding: 10px; }
.takeout-share-card .card-header .icon { font-size: 1.5rem; color: var(--accent-color); }
.takeout-share-card .card-header .shop-name { font-weight: 600; }
.takeout-share-card .card-body { padding: 10px; font-size: 0.9rem; color: var(--text-color-medium); border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); }
.takeout-share-card .card-footer { padding: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; }
.takeout-share-card .card-footer .view-details-btn { color: var(--accent-color); font-weight: 500; }
/* --- 20.7. 外卖代付请求卡片样式 (修改) --- */

.takeout-payment-request-card { width: 220px; overflow: hidden; box-shadow: var(--shadow-light); animation: popIn 0.2s ease-out; }
.takeout-payment-request-card.sent { background-color: var(--player-bubble-bg-light); border-radius: 18px 18px 4px 18px; }
.takeout-payment-request-card.received { background-color: var(--ai-bubble-bg); border-radius: 18px 18px 18px 4px; }
.takeout-payment-request-card .card-main { display: flex; align-items: center; padding: 15px; gap: 12px; }
.takeout-payment-request-card .card-icon { font-size: 2rem; color: #FFC107; flex-shrink: 0; }
.takeout-payment-request-card .card-details { flex-grow: 1; }
.takeout-payment-request-card .card-title { font-size: 1rem; font-weight: 500; color: var(--text-color-dark); }
.takeout-payment-request-card .card-amount { font-size: 1.5rem; font-weight: 600; color: var(--text-color-dark); margin-top: 4px; }
.takeout-payment-request-card .card-footer { font-size: 0.8rem; padding: 8px 12px; color: var(--text-color-medium); border-top: 1px solid var(--border-color); }
.takeout-payment-request-card.sent .card-footer { border-top: 1px solid var(--border-color); }
.message-row.received .takeout-payment-request-card { cursor: pointer; }
/* ▼▼▼ 核心美化：位置分享卡片样式 ▼▼▼ */
.location-share-card {
    width: 220px; /* 核心修改：尺寸参考音乐卡片 */
    background-color: var(--bg-light);
    border-radius: 16px; /* 更圆润的边角 */
    box-shadow: var(--shadow-light);
    padding: 12px;
    display: flex; /* 核心修改：改为flex左右布局 */
    align-items: center;
    gap: 12px;
}
.message-row.sent .location-share-card {
    background-color: var(--player-bubble-bg-light);
}
.location-share-card .location-icon-wrapper {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--accent-gradient); /* 使用主题渐变色 */
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5rem; /* 调整图标大小 */
    flex-shrink: 0;
}
.location-share-card .location-details {
    flex-grow: 1;
    min-width: 0; /* 防止长文本撑开布局 */
}
.location-share-card .location-name {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 1rem;
}
/* ▼▼▼ 核心美化：红包卡片全新样式 ▼▼▼ */
.red-packet-card {
    width: 220px;
    border-radius: 12px;
    background: linear-gradient(150deg, #F96854, #F24D4D);
    color: #FFD700; /* 金色文字 */
    box-shadow: 0 4px 10px rgba(230, 72, 72, 0.3), inset 0 -2px 5px rgba(0,0,0,0.1);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    padding: 12px;
    position: relative;
    border: 1px solid #FAD961;
}
.message-row.sent .red-packet-card {
    background: var(--player-bubble-bg-light);
    color: var(--danger-color);
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow-light);
}
.red-packet-card .red-packet-body {
    display: flex;
    align-items: center;
    gap: 10px;
}
.red-packet-card .red-packet-icon {
    font-size: 1.8rem;
}
.red-packet-card .red-packet-memo {
    font-weight: 500;
    font-size: 1rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
}
.red-packet-card .red-packet-footer {
    font-size: 0.75rem;
    margin-top: 8px;
    opacity: 0.8;
}
.message-row.sent .red-packet-card .red-packet-footer {
    color: var(--text-color-medium);
}
@keyframes pulse {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
    70% { transform: scale(1.05); box-shadow: 0 0 0 8px rgba(255, 215, 0, 0); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
}
.red-packet-open-btn {
    position: absolute;
    bottom: 10px; /* 核心修改1：再往下移动一点 */
    right: 12px;
    transform: none;
    width: 25px; /* 核心修改2：按钮整体再缩小一点 */
    height: 25px; /* 核心修改2：按钮整体再缩小一点 */
    border-radius: 50%;
    background-color: white;
    color: var(--danger-color);
    font-weight: bold;
    font-size: 1rem; /* 核心修改3：保持字体大小不变 */
    font-family: var(--font-main);
    border: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    animation: none;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: transform 0.2s;
}

.red-packet-open-btn:active {
    transform: scale(0.9); /* 核心修改：简化按压效果的变换 */
}



.red-packet-receipt-card {
    width: 220px;
    border-radius: 12px;
    background: var(--player-bubble-bg-light);
    color: var(--text-color-medium);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
}
.red-packet-receipt-card .receipt-icon {
    font-size: 1.2rem;
}
/* ▲▲▲ 美化完成 ▲▲▲ */



.location-share-card .location-subtitle {
    font-size: 0.8rem;
    color: var(--text-color-medium);
    margin-top: 4px;
}
/* ▲▲▲ 美化完成 ▲▲▲ */


    <style>
        /* 微博主 feed 页面 */
        .weibo-post-list { padding-bottom: 20px; }
        .weibo-post-item {
            background-color: var(--bg-light);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
        }
        .weibo-post-item .author-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            cursor: pointer;
        }
        /* ▼▼▼ 核心美化：虚拟网友头像改为白色底 + 整体渐变图标 ▼▼▼ */
        .weibo-post-item .author-avatar.takeout-icon-placeholder {
            background-color: var(--bg-light); /* 核心修改1：背景改为白色 */
            border: 1px solid var(--border-color); /* 增加淡淡的粉色边框 */
        }
        .weibo-post-item .author-avatar.takeout-icon-placeholder i {
            font-size: 1.8rem;
            /* 核心修改2：重新启用渐变图标技巧 */
            background: var(--accent-gradient);
            color: transparent;
            -webkit-background-clip: text;
            background-clip: text;
        }
        /* ▲▲▲ 美化完成 ▲▲▲ */



.weibo-post-item .post-main { flex-grow: 1; overflow: hidden; }
.weibo-post-item .author-name { font-weight: 600; cursor: pointer; }
.weibo-post-item .post-content-text { margin: 8px 0; line-height: 1.6; font-size: 0.95rem; white-space: pre-wrap; word-break: break-word; }
.weibo-post-item .post-meta { font-size: 0.8rem; color: var(--text-color-light); margin-bottom: 12px; }
.weibo-post-actions { display: grid; grid-template-columns: repeat(3, 1fr); border-top: 1px solid var(--border-color); margin-top: 10px; }
.weibo-post-actions .action-btn { background: none; border: none; border-right: 1px solid var(--border-color); padding: 10px 0; cursor: pointer; color: var(--text-color-medium); font-size: 0.85rem; display: flex; justify-content: center; align-items: center; gap: 5px; }
.weibo-post-actions .action-btn:last-child { border-right: none; }
.weibo-post-actions .action-btn:active { background-color: var(--hover-bg-color); }
.weibo-post-actions .action-btn.liked { color: var(--danger-color); font-weight: bold; }

                /* ▼▼▼ 新增：微博页面底部标签栏样式 (已重构) ▼▼▼ */
     

#page-weibo { flex-direction: column; }
#weibo-bottom-nav { display: flex; width: 100%; background-color: rgba(255, 255, 255, 0.7); backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); padding: 6px 0 8px 0; flex-shrink: 0; z-index: 10; }
.weibo-tab-btn { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; color: var(--text-color-medium); transition: all 0.2s; }
.weibo-tab-btn i { font-size: 1.3rem; margin-bottom: 3px; }
.weibo-tab-btn span { font-size: 0.7rem; }
.weibo-tab-btn.active { color: var(--accent-color); }
.weibo-tab-btn:active { transform: scale(0.95); }
#page-weibo .page-content { padding-bottom: 60px; }
.weibo-tab-content { display: none; }
.weibo-tab-content.active { display: block; }

        /* ▼▼▼ 新增：热搜板块样式 ▼▼▼ */
     
.hot-search-section { background-color: var(--bg-light); margin-bottom: 8px; padding: 5px 15px 15px 15px; }
.hot-search-section h3 { font-size: 1rem; margin-bottom: 10px; }
.hot-search-list { display: flex; flex-direction: column; gap: 12px; }
.hot-search-item { display: flex; align-items: center; font-size: 0.9rem; }
.hot-search-item .rank { font-weight: 600; color: var(--text-color-light); width: 25px; }
.hot-search-item .rank.top-1, .hot-search-item .rank.top-2, .hot-search-item .rank.top-3 { color: var(--danger-color); }
.hot-search-item .title { flex-grow: 1; }
.hot-search-item .tag { font-size: 0.7rem; color: white; padding: 1px 4px; border-radius: 3px; margin-left: 5px; }
.hot-search-item .tag.boom { background: #FF7B7B; } 



/* ▼▼▼ 新增：拍一拍消息样式 ▼▼▼ */
.pat-message {
    text-align: center;
    padding: 5px 0 10px 0;
    font-size: 0.8rem;
    color: var(--text-color-medium);
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* ▼▼▼ 新增：聊天时间戳样式 ▼▼▼ */

     
.message-timestamp-container { text-align: center; padding: 5px 0 10px 0; font-size: 0.75rem; color: var(--text-color-light); }
/* --- 21. 直播功能专属样式 (新增) --- */
.live-tab-content { display: none; }
.live-tab-content.active { display: flex; flex-direction: column; flex-grow: 1; }

.streamer-card-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}
.streamer-card {
    position: relative;
    aspect-ratio: 9 / 12;
    border-radius: 16px;
    overflow: hidden;
    cursor: pointer;
    box-shadow: var(--shadow-light);
}


/* 核心修改：将图片封面样式替换为图标容器样式 (V2.0 白色渐变版) */
.streamer-card-icon-bg {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    /* 核心美化：背景改为从纯白到极浅粉的微妙渐变，更显高级感 */
    background: linear-gradient(135deg, #FFFFFF 0%, #FFF8FA 100%);
    /* 核心美化：为了在白色背景上可见，图标颜色改为主题粉色 */
    color: var(--accent-color);
    font-size: 3.5rem; /* 图标大小 */
}

.streamer-card-live-badge {
    position: absolute;
    top: 8px;
    left: 8px;
    background-color: rgba(255, 0, 0, 0.8);
    color: white;
    font-size: 0.7rem;
    padding: 3px 6px;
    border-radius: 5px;
    font-weight: bold;
}
.streamer-card-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 8px;
    background: linear-gradient(to top, rgba(255, 175, 189, 0.6), transparent);
    /* 核心修复：文字颜色从 white 改为深色，这样才能在白色背景上看见 */
    color: var(--text-color-dark);
    /* 优化：阴影改为浅色，给深色文字营造柔和的描边效果，更好看 */
    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.7);
}

.streamer-card-info .title {
    font-weight: 600;
    font-size: 0.9rem;
}
.streamer-card-info .name {
    font-size: 0.8rem;
    opacity: 0.9;
    margin-top: 4px;
}
.streamer-card .status-toggle {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 50px;
    height: 24px;
    border-radius: 12px;
    background-color: rgba(0,0,0,0.4);
    cursor: pointer;
    z-index: 5;
    display: flex;
    align-items: center;
    padding: 2px;
    transition: background-color 0.3s;
}
.streamer-card .status-toggle::before {
    content: '';
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: white;
    transition: transform 0.3s ease;
}
.streamer-card .status-toggle.live {
    background-color: var(--accent-color);
}
.streamer-card .status-toggle.live::before {
    transform: translateX(26px);
}

.streamer-card .status-toggle.live::before {
    transform: translateX(26px);
}
/* ▼▼▼ 新增：直播间系统消息/礼物消息样式 ▼▼▼ */
.chat-comment.system-event {
    background-color: rgba(255, 228, 234, 0.7); /* 更淡雅的粉色背景 */
    backdrop-filter: blur(8px);
    color: var(--accent-color-deep); /* 使用更有质感的深粉色文字 */
    font-weight: 500;
    font-size: 0.85rem;
    align-self: flex-start; /* 确保它靠左显示 */
}
.chat-comment.system-event .username {
    color: var(--text-color-dark); /* 在系统消息里，用户名用深色，更清晰 */
}
.chat-comment.system-event .gift-icon {
    margin-left: 5px;
    color: #FFD700; /* 金色图标 */
    text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
}

/* ▼▼▼ 新增：豪华礼物横幅 & 房管徽章样式 ▼▼▼ */
.chat-comment.system-event-luxury {
    width: 95%;
    align-self: center; /* 居中显示 */
    text-align: center;
    background: linear-gradient(135deg, #FFD700 0%, #FFAFBD 100%);
    color: white;
    font-weight: bold;
    font-size: 0.9rem;
    padding: 8px 12px;
    border-radius: 15px;
    animation: popIn 0.3s ease-out;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}
.manager-badge {
    background-color: #FFC107;
    color: white;
    font-size: 0.65rem;
    padding: 2px 5px;
    border-radius: 4px;
    margin-right: 6px;
    font-weight: bold;
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* ▼▼▼ 新增：网店经营功能样式 ▼▼▼ */
.product-card {
    background-color: var(--bg-light);
    border-radius: 16px;
    padding: 15px;
    margin-bottom: 10px;
    box-shadow: var(--shadow-light);
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.product-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.product-card-header .name {
    font-size: 1.1rem;
    font-weight: 600;
}
.product-card-header .price {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--danger-color);
}
.product-card-body .description {
    font-size: 0.9rem;
    color: var(--text-color-medium);
    line-height: 1.5;
}
.product-card-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
}
.product-card-footer button {
    background: transparent;
    border: 1px solid var(--border-color);
    padding: 6px 12px;
    border-radius: 15px;
    font-size: 0.8rem;
    cursor: pointer;
}
.product-card-footer .btn-primary {
    background: var(--accent-gradient);
    border-color: transparent;
    color: white;
}
.store-order-item {
    background-color: var(--bg-light);
    border-radius: 16px;
    margin-bottom: 10px;
    padding: 15px;
    box-shadow: var(--shadow-light);
    cursor: pointer;
}
.store-order-item .order-header .status {
    font-size: 0.9rem;
    color: var(--accent-color);
}
.store-order-item .order-header .status.completed {
    color: #28a745;
}
.product-share-card {
    width: 220px;
    background-color: var(--ai-bubble-bg);
    border-radius: 12px;
    box-shadow: var(--shadow-light);
    overflow: hidden;
    cursor: pointer;
}
.message-row.sent .product-share-card {
    background-color: var(--player-bubble-bg-light);
}
.product-share-card .card-header .icon {
    font-size: 1.5rem;
    color: var(--accent-color);
}
.product-share-card .card-header .product-name {
    font-weight: 600;
}
.product-share-card .card-body {
    padding: 10px;
    font-size: 0.9rem;
    color: var(--text-color-medium);
    border-top: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
}
.product-share-card .card-footer .price {
    color: var(--danger-color);
    font-weight: 600;
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* ▼▼▼ 新增：仓库与进货市场样式 ▼▼▼ */
.warehouse-item, .wholesale-item {
    background-color: var(--bg-light);
    border-radius: 12px;
    padding: 12px 15px;
    margin-bottom: 10px;
    box-shadow: var(--shadow-light);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.warehouse-item .stock-count {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--accent-color);
}
.wholesale-category {
    margin-bottom: 15px;
}
.wholesale-category-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 10px;
    padding-left: 5px;
}
.wholesale-item {
    cursor: pointer;
}
.wholesale-item .cost {
    font-size: 0.9rem;
    color: var(--text-color-medium);
}
/* ▲▲▲ 新增完成 ▲▲▲ */


/* ▼▼▼ 新增：网店页面专属底部导航栏样式 ▼▼▼ */
#online-store-bottom-nav {
    display: flex;
    width: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    padding: 6px 0 8px 0;
    flex-shrink: 0;
    z-index: 10;
}
.store-tab-btn {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-color-medium);
    transition: all 0.2s;
}
.store-tab-btn i {
    font-size: 1.3rem;
    margin-bottom: 3px;
}
.store-tab-btn span {
    font-size: 0.7rem;
}
.store-tab-btn.active {
    color: var(--accent-color);
}
.store-tab-btn:active {
    transform: scale(0.95);
}
/* ▲▲▲ 新增完成 ▲▲▲ */






/* ▼▼▼ 新增：地址选择弹窗样式 ▼▼▼ */
.address-picker-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 10px;
    cursor: pointer;
}
.address-picker-item:not(:last-child) {
    border-bottom: 1px solid var(--border-color);
}
.address-picker-item .address-text {
    flex-grow: 1;
    margin-right: 15px;
}
.address-picker-item .fa-circle-dot, .address-picker-item .fa-circle {
    color: var(--text-color-light);
}
.address-picker-item.selected .fa-circle-dot {
    color: var(--accent-color);
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* ▼▼▼ 新增：礼物弹窗样式 ▼▼▼ */

.gift-panel-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    padding: 10px;
}
.gift-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 10px 5px;
    border-radius: 12px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s ease;
}
.gift-item:hover {
    background-color: var(--hover-bg-color);
}
.gift-item.selected {
    border-color: var(--accent-color);
    background-color: var(--player-bubble-bg-light);
}
.gift-item .gift-icon {
    font-size: 2rem;
    color: var(--accent-color);
}
.gift-item .gift-name {
    font-size: 0.8rem;
    color: var(--text-color-dark);
}
.gift-item .gift-price {
    font-size: 0.75rem;
    color: var(--text-color-medium);
}
#gift-modal .modal-actions {
    padding: 10px 15px;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#gift-modal .wallet-balance-display {
    font-size: 0.9rem;
}
#gift-modal #send-gift-confirm-btn {
    padding: 8px 25px;
    border-radius: 20px;
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* ▼▼▼ 新增：“我的”直播页数据面板样式 ▼▼▼ */

.my-streamer-dashboard {
    background-color: var(--bg-light);
    border-radius: 16px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: var(--shadow-light);
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    text-align: center;
}
.dashboard-item {
    cursor: pointer;
}
.dashboard-item .value {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--accent-color-deep);
}
.dashboard-item .label {
    font-size: 0.8rem;
    color: var(--text-color-medium);
    margin-top: 5px;
}
/* ▲▲▲ 新增完成 ▲▲▲ */

/* 直播间样式 (V2.0 少女心美化版) */

/* ▼▼▼ 主播卡片管理按钮美化 (无变化) ▼▼▼ */
.live-status-btn { position: absolute; top: 8px; left: 8px; color: white; font-size: 0.7rem; padding: 4px 8px; border-radius: 5px; font-weight: bold; cursor: pointer; z-index: 5; transition: background-color 0.3s; }
.live-status-btn.live { background-color: rgba(255, 0, 0, 0.8); }
.live-status-btn.offline { background-color: rgba(100, 100, 100, 0.7); }
/* 核心美化：三点按钮样式更新 (V2.0 粉色版) */
.streamer-options-btn-corner {
    position: absolute;
    bottom: 8px;
    right: 8px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    /* 背景改为主题粉色渐变，让它成为一个可爱的装饰 */
    background: var(--accent-gradient);
    /* 图标颜色改为白色，以提供最佳对比度 */
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1rem;
    cursor: pointer;
    z-index: 5;
    transition: transform 0.2s;
    box-shadow: 0 2px 4px rgba(255, 175, 189, 0.4);
}
.streamer-options-btn-corner:active {
    transform: scale(0.9);
}
.streamer-options-btn-corner:hover { background-color: rgba(0, 0, 0, 0.6); }
/* ▲▲▲ 新增完成 ▲▲▲ */

/* 核心美化 1/6：页面整体背景 */
#page-live-room {
    background: linear-gradient(160deg, #fff1f4 0%, #fde6e8 100%);
    /* 核心修改 1/2：将内容对齐方式从“两端对齐”改为“末端对齐” */
    /* 这样就会把聊天区和输入框整体推到屏幕底部 */
    justify-content: flex-end;
    color: var(--text-color-dark);
}

/* 核心美化 2/6：顶部信息栏 */
.live-room-header {
    position: absolute;
    top: 0; left: 0; right: 0;
    padding: 12px 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    /* 移除黑色渐变，保持页面背景通透 */
    z-index: 10;
}
.streamer-info-card {
    display: flex;
    align-items: center;
    gap: 10px;
    background-color: rgba(255, 255, 255, 0.5); /* 半透明白色，营造磨砂玻璃感 */
    backdrop-filter: blur(10px); /* 磨砂玻璃效果的关键 */
    padding: 5px 10px 5px 5px;
    border-radius: 25px;
    flex-grow: 1;
    border: 1px solid rgba(255, 255, 255, 0.7); /* 增加一个亮边，更有质感 */
}
.streamer-info-card .item-avatar { width: 36px; height: 36px; margin: 0; }
.streamer-info-card .item-name { color: var(--text-color-dark); font-size: 0.9rem; margin: 0; font-weight: 600; }
.streamer-info-card .item-last-msg { color: var(--text-color-medium); font-size: 0.7rem; margin: 2px 0 0 0; }
#live-room-follow-btn {
    background: var(--accent-gradient);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: 600;
    flex-shrink: 0;
    box-shadow: var(--shadow-light); /* 增加柔和阴影 */
}
#close-live-room-btn {
    color: var(--text-color-dark);
    background-color: rgba(255, 255, 255, 0.5); /* 同样改为半透明白色 */
    backdrop-filter: blur(10px);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1rem;
}

/* 核心美化 3/6：聊天弹幕区 */
.live-room-chat-feed {
    /* 核心修改 2/2：不再让它撑满全屏，而是给一个最大高度限制 */
    max-height: 45vh; /* vh是视窗高度单位，45vh约等于半个屏幕高 */
    overflow-y: auto;
    padding: 10px 15px; /* 调整内边距，顶部不再需要留出巨大空间 */
    /* 更新遮罩，让渐变效果作用于新的、更短的聊天区顶部 */
    mask-image: linear-gradient(to top, black 70%, transparent 100%);
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}
.chat-comment {
    background-color: rgba(255, 255, 255, 0.6); /* 半透明白色气泡 */
    backdrop-filter: blur(5px);
    color: var(--text-color-dark); /* 深色文字 */
    padding: 6px 12px;
    border-radius: 12px;
    margin-bottom: 8px;
    font-size: 0.9rem;
    align-self: flex-start;
    max-width: 80%;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* 增加一点点阴影 */
}
.chat-comment .username {
    color: var(--accent-color-deep); /* 用户名改为更有质感的深粉色 */
    font-weight: 600;
    margin-right: 5px;
}

/* 核心美化 4/6：底部输入区 */
.live-room-footer {
    padding: 8px 15px 15px 15px;
    display: flex;
    gap: 10px;
    flex-shrink: 0;
    z-index: 10;
}
#live-room-comment-input {
    flex-grow: 1;
    border: 1px solid var(--border-color); /* 增加淡淡的边框 */
    background-color: rgba(255, 255, 255, 0.5); /* 半透明白色 */
    backdrop-filter: blur(10px);
    color: var(--text-color-dark);
    padding: 10px 15px;
    border-radius: 20px;
    outline: none;
}
#live-room-comment-input::placeholder {
    color: var(--text-color-medium); /* 占位文字颜色 */
}
.live-room-footer .action-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent-gradient);
    color: white;
    font-size: 1rem;
    border: none;
    box-shadow: 0 2px 5px rgba(255, 175, 189, 0.4);
    /* ▼▼▼ 新增的居中代码 ▼▼▼ */
    display: flex;
    justify-content: center;
    align-items: center;
    /* ▲▲▲ 新增完成 ▲▲▲ */
}


/* 核心美化 5/6：点赞特效容器 */
.floating-likes-container {
    position: absolute;
    bottom: 60px;
    right: 15px;
    width: 50px;
    height: 250px; /* 增加高度，让动画更舒展 */
    pointer-events: none;
}

/* 核心美化 6/6：全新的少女心点赞动画 */
@keyframes floatUpGirly {
    0% {
        transform: translateY(0) scale(0.8) rotate(0deg);
        opacity: 1;
    }
    50% {
        transform: translateY(-120px) scale(1.2) rotate(15deg);
        opacity: 0.8;
    }
    100% {
        transform: translateY(-250px) scale(0.5) rotate(-10deg);
        opacity: 0;
    }
}
.floating-like {
    position: absolute;
    bottom: 0;
    left: 50%; /* 水平位置由JS随机控制 */
    /* 移除固定的颜色和大小，这些将由JS动态设定 */
    animation-name: floatUpGirly;
    animation-timing-function: ease-out;
    animation-fill-mode: forwards;
}

    </style>



</head>
<body>


    <div id="app-container">
        <div id="main-content">
            <!-- ... 其他页面保持不变 ... -->
            <div id="page-conversations" class="page active">
                <div class="page-header">
                    <div class="header-left"><img id="my-avatar" src="https://s2.loli.net/2023/05/23/9N25XbYVdDgrzQj.png" alt="avatar"></div>
                    <h1>消息</h1>
                    <div class="header-right"><i class="fa-solid fa-trash-can header-icon" id="toggle-delete-mode-btn"></i></div>
                </div>
                <div class="page-content">
                    <ul class="conversation-list" id="conversation-list-ul"></ul>
                    <div class="empty-placeholder" id="empty-conversation-placeholder"><p>还没有消息，快去和新朋友聊天吧~</p></div>
                </div>
            </div>
                             <div id="page-chat" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-to-conversations-btn"></i></div>
                    <div id="chat-header-container">
                        <h1 id="chat-header-title">朋友</h1>
                        <div id="chat-header-subtitle"></div>
                    </div>
                                                            <div class="header-right" style="display: flex; justify-content: flex-end; align-items: center; gap: 20px;">
                        <!-- ▼▼▼ 核心修改：为日记按钮增加一个专属的 class "icon-diary" ▼▼▼ -->
                        <i class="fa-solid fa-book-journal-whills header-icon icon-diary" id="show-diary-btn" style="display: none;" title="查看日记"></i>
                        <!-- ▲▲▲ 修改完成 ▲▲▲ -->
                        <i class="fa-solid fa-heart-pulse header-icon" id="show-thought-btn" style="display: none;" title="查看心声"></i>
                        <i class="fa-solid fa-comments header-icon" id="return-online-btn" style="display: none;" title="返回线上"></i>
                        <i class="fa-solid fa-ellipsis-vertical header-icon" id="chat-options-btn"></i>
                    </div>



                   
                </div>
                <!-- ...后续代码... -->


                <div class="chat-area" id="chat-area"></div>
                
                <!-- ▼▼▼ 升级：可滑动的功能面板 ▼▼▼ -->
                <div class="chat-function-panel-container" id="chat-function-panel-container">
                    <div class="chat-function-panel" id="chat-function-panel">
                        <!-- 第一页 -->
                        <div class="function-page" id="function-page-1">
                            <div class="function-item" id="transfer-btn">
                                <div class="icon-wrapper"><i class="fa-solid fa-money-bill-transfer"></i></div>
                                <span>转账</span>
                            </div>
                            <div class="function-item" id="red-packet-btn">
                               <div class="icon-wrapper"><i class="fa-solid fa-envelope"></i></div>
                               <span>红包</span>
                           </div>

                            <div class="function-item" id="video-call-btn">
                                <div class="icon-wrapper"><i class="fa-solid fa-video"></i></div>
                                <span>视频通话</span>
                            </div>
                            <div class="function-item" id="listen-together-btn">
                                <div class="icon-wrapper"><i class="fa-solid fa-headphones"></i></div>
                                <span>一起听歌</span>
                            </div>
                            <!-- ▼▼▼ 新增：“线下见面”功能按钮 ▼▼▼ -->
                            <div class="function-item" id="offline-mode-btn">
                                <div class="icon-wrapper"><i class="fa-solid fa-hand-sparkles"></i></div>
                                <span>线下见面</span>
                            </div>
                            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                        </div>

                        <!-- 第二页 -->
                        <div class="function-page" id="function-page-2">
                             <div class="function-item" id="send-location-btn">
                                <div class="icon-wrapper"><i class="fa-solid fa-location-dot"></i></div>
                                <span>位置</span>
                            </div>
                        </div>
                    </div>
                    <!-- 滑动指示器 -->
                    <div class="panel-dots-indicator">
                        <span class="dot active" data-index="0"></span>
                        <span class="dot" data-index="1"></span>
                    </div>
                </div>




                <!-- ▲▲▲ 新增完成 ▲▲▲ -->

                                <div class="chat-input-area" id="chat-input-area">
                    <button id="trigger-ai-btn"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                    <button id="toggle-input-mode-btn"><i class="fa-solid fa-microphone"></i></button>
                    <input type="text" id="message-input" placeholder="输入消息...">
                    <button id="hold-to-talk-btn">按住 说话</button>
                    <button id="send-btn"><i class="fa-solid fa-paper-plane"></i></button>
                    <button id="toggle-functions-btn"><i class="fa-solid fa-plus"></i></button>
                </div>


            </div>


           
            <div id="page-contacts" class="page">
                <div class="page-header">
                    <div class="header-left">
                        <!-- 我们将原来的文字按钮，换成了一个带新ID的图标 -->
                        <i class="fa-solid fa-minus header-icon icon-danger" id="contacts-delete-toggle-btn"></i>
                    </div>
                    <h1>通讯录</h1>
                    <div class="header-right">
                        <i class="fa-solid fa-plus header-icon" id="add-contact-btn"></i>
                    </div>
                </div>
                <div class="page-content" id="contacts-page-content"></div>
            </div>

            <div id="page-discover" class="page" data-page-id="discover-page">
                <div class="page-header"><h1>发现</h1></div>

                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="show-moments-btn"><i class="fa-solid fa-camera-retro"></i><span>朋友圈</span><i class="fa-solid fa-chevron-right"></i></div>
                        <div class="setting-item" id="takeout-btn"><i class="fa-solid fa-utensils"></i><span>外卖</span><i class="fa-solid fa-chevron-right"></i></div>
                        <!-- ▼▼▼ 新增：微博功能入口 ▼▼▼ -->
                        <div class="setting-item" id="weibo-btn"><i class="fa-brands fa-weibo"></i><span>微博</span><i class="fa-solid fa-chevron-right"></i></div>
                        <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                        <!-- ▼▼▼ 新增：直播功能入口 ▼▼▼ -->
                        <div class="setting-item" id="live-stream-btn"><i class="fa-solid fa-tower-broadcast"></i><span>直播</span><i class="fa-solid fa-chevron-right"></i></div>
                        <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                        <!-- ▼▼▼ 新增：网店经营入口 ▼▼▼ -->
                        <div class="setting-item" id="online-store-btn"><i class="fa-solid fa-shop"></i><span>网店经营</span><i class="fa-solid fa-chevron-right"></i></div>
                        <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                        <div class="setting-item" id="music-library-btn"><i class="fa-solid fa-music"></i><span>音乐库</span><i class="fa-solid fa-chevron-right"></i></div>



                    </div>
                </div>
            </div>



                     <div id="page-settings" class="page">
                <div class="page-header"><h1>系统</h1></div>
                <div class="page-content">
                    <!-- ▼▼▼ 核心修改：只保留一个容器，所有内容由JS填充 ▼▼▼ -->
                    <div class="settings-list" id="settings-list-container">
                        <!-- 所有设置项将由JS动态生成到这里 -->
                    </div>
                    <!-- 隐藏的文件输入框放在外面，不影响布局 -->
                    <input type="file" id="import-file-input" class="avatar-file-input" accept=".json">
                </div>
            </div>


            <div id="page-api-settings" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-to-settings-btn"></i></div>
                    <h1>API 配置</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content page-form-content">
                    <div class="api-settings-group">
                        <div class="api-setting-item"><label for="base-url">Base URL</label><input type="text" id="base-url" placeholder="例如: https://api.openai.com"></div>
                        <div class="api-setting-item"><label for="api-key">API Key</label><input type="password" id="api-key" placeholder="你的 API Key"></div>
                        <div class="api-setting-item"><label for="model-name">Model Name</label><input type="text" id="model-name" placeholder="例如: gpt-4o"></div>
                                        </div>
                    <button id="save-settings-btn">保存设置</button>
                </div>
            </div>

            <!-- ▼▼▼ 1. 新增的朋友圈API配置页面 ▼▼▼ -->
            <div id="page-moments-api-settings" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-moments-api-settings-btn"></i></div>
                    <h1>朋友圈 API 配置</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content page-form-content">
                    <div class="api-settings-group">
                        <div class="api-setting-item"><label for="moments-base-url">Base URL (朋友圈专用)</label><input type="text" id="moments-base-url" placeholder="留空则使用通用API配置"></div>
                        <div class="api-setting-item"><label for="moments-api-key">API Key (朋友圈专用)</label><input type="password" id="moments-api-key" placeholder="留空则使用通用API配置"></div>
                        <div class="api-setting-item"><label for="moments-model-name">Model Name (朋友圈专用)</label><input type="text" id="moments-model-name" placeholder="留空则使用通用API配置"></div>
                    </div>
                    <button id="save-moments-settings-btn">保存朋友圈设置</button>
                </div>
            </div>
            <!-- ▲▲▲ 1. 新增完成 ▲▲▲ -->

            <div id="page-create-friend" class="page">

                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-create-friend-btn"></i></div>
                    <h1>添加新好友</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content page-form-content" id="create-friend-form-content"></div>
            </div>



            <!-- 页面8: 我的信息页面 (结构修改) -->
            <div id="page-my-info" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-my-info-btn"></i></div>
                    <h1>我的信息</h1>
                    <div class="header-right"></div> <!-- 移除顶部的保存按钮 -->
                </div>
                <div class="page-content page-form-content" id="my-info-form-content">
                    <!-- 内容将由JS动态生成 -->
                </div>
            </div>
            
            <div id="page-create-group" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-create-group-btn"></i></div>
                    <h1>新建群聊</h1>
                    <div class="header-right"><button class="header-btn" id="save-group-btn">创建</button></div>
                </div>
                <div class="page-content page-form-content" id="create-group-form-content"></div>
            </div>
            <div id="page-create-friend-group" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-create-friend-group-btn"></i></div>
                    <h1>新建分组</h1>
                    <div class="header-right"><button class="header-btn" id="save-friend-group-btn">创建</button></div>
                </div>
                <div class="page-content page-form-content" id="create-friend-group-form-content">
                    <!-- 内容将由JS动态生成 -->
                </div>
            </div>


                      <!-- 页面9: 修改好友信息页面 (新增) -->
            <div id="page-edit-friend" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-edit-friend-btn"></i></div>
                    <h1>修改好友信息</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content page-form-content" id="edit-friend-form-content">
                    <!-- 表单内容将由JS动态生成 -->
                </div>
            </div>

            <!-- ▼▼▼ 请将下面这个新的页面代码块，完整粘贴到这里 ▼▼▼ -->
            <div id="page-wallet" class="page">

                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-wallet-btn"></i></div>
                    <h1>我的钱包</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="wallet-page-content">
                    <!-- 钱包内容将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 请将上面这个新的页面代码块，完整粘贴到这里 ▲▲▲ -->

            <!-- 页面10: 朋友圈页面 (新增) -->
            <div id="page-moments" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-moments-btn"></i></div>
                    <h1></h1>
                    <div class="header-right" style="display: flex; gap: 20px; justify-content: flex-end;">
                        <i class="fa-solid fa-users-rays header-icon" id="trigger-ai-social-btn"></i>
                        <i class="fa-solid fa-wand-magic-sparkles header-icon" id="generate-ai-moment-btn"></i>
                        <i class="fa-solid fa-camera header-icon" id="post-my-moment-btn"></i>
                    </div>
                </div>

                <div class="page-content" style="padding: 0; overflow-y: auto;">
                    <!-- 朋友圈内容将由JS动态生成 -->
                    <div id="moments-content-area"></div>
                </div>
            </div>

            <!-- 页面11: 发布动态页面 (新增) -->
            <div id="page-post-moment" class="page">
                <div class="page-header">
                    <div class="header-left"></div>
                    <h1>发布动态</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content page-form-content" id="post-moment-form-content">
                     <!-- 发布表单将由JS动态生成 -->
                </div>
            </div>


            <!-- ▼▼▼ 新增：音乐库页面 ▼▼▼ -->
            <div id="page-music-library" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-music-library-btn"></i></div>
                    <h1>音乐库</h1>
                    <div class="header-right"><i class="fa-solid fa-plus header-icon" id="add-music-btn"></i></div>
                </div>
                <div class="page-content" id="music-library-content" style="padding: 10px;">
                    <!-- 音乐列表将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->

            <!-- ▼▼▼ 新增：关键词库相关页面 ▼▼▼ -->
            <div id="page-keywords" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-keywords-btn"></i></div>
                    <h1>关键词库</h1>
                    <div class="header-right"><i class="fa-solid fa-plus header-icon" id="add-keyword-btn"></i></div>
                </div>
                <div class="page-content" id="keywords-list-content" style="padding: 10px;">
                    <!-- 关键词列表将由JS动态生成 -->
                </div>
            </div>

            <div id="page-keyword-edit" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-keyword-edit-btn"></i></div>
                    <h1 id="keyword-edit-page-title">添加关键词</h1>
                    <div class="header-right"><button class="header-btn" id="save-keyword-btn">保存</button></div>
                </div>
                <div class="page-content page-form-content">
                    <div class="form-group">
                        <label>标题 (必填)</label>
                        <input type="text" id="keyword-title-input" placeholder="例如：魔法学院世界观">
                    </div>
                    <div class="form-group">
                        <label>内容 (世界观/设定/记忆)</label>
                        <textarea id="keyword-content-input" placeholder="在这里详细描述设定..." style="min-height: 200px;"></textarea>
                    </div>
                </div>
            </div>

            <div id="page-keyword-picker" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-keyword-picker-btn"></i></div>
                    <h1>选择关键词</h1>
                    <div class="header-right"><button class="header-btn" id="save-keyword-selection-btn">完成</button></div>
                </div>
                <div class="page-content" id="keyword-picker-list-content" style="padding: 10px;">
                    <!-- 关键词选择列表将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->


            

            <!-- ▼▼▼ 新增：视频通话页面 (替换旧的语音通话页) ▼▼▼ -->
            <div id="video-call-screen">
                <div class="video-call-card">
                    <div class="video-call-header">
                        <h1 id="video-call-contact-name"></h1>
                        <span id="video-call-timer"></span>
                    </div>
                    <div class="video-call-main">
                        <div class="narrative-feed" id="narrative-feed"></div>
                    </div>
                    <div class="video-call-input-area">
                        <input type="text" id="video-call-input" placeholder="输入你的回应...">
                        <button id="video-call-send-btn"><i class="fa-solid fa-paper-plane"></i></button>
                    </div>
                    <div class="video-call-controls">
                        <button class="call-control-btn hang-up" id="video-hang-up-btn">
                            <div class="icon-bg"><i class="fas fa-phone-slash"></i></div>
                            <span>挂断</span>
                        </button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
            <!-- ▼▼▼ 新增：外卖功能相关页面 ▼▼▼ -->
            <div id="page-takeout-main" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" data-target-page="page-discover"></i></div>
                    <h1>外卖</h1>
                    <div class="header-right"><i class="fa-solid fa-receipt header-icon" id="my-orders-btn" style="color: var(--accent-color);"></i></div>
                </div>
                <div class="page-content" id="takeout-main-content" style="padding: 10px;">
                    <!-- 店铺列表将由JS动态生成 -->
                </div>
            </div>


            <div id="page-takeout-shop" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" data-target-page="page-takeout-main"></i></div>
                    <h1 id="takeout-shop-name">店铺名称</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="takeout-shop-content" style="padding: 0;">
                    <!-- 店铺详情和菜单将由JS动态生成 -->
                </div>
                <!-- 浮动购物车 -->
                <div id="floating-cart-bar" style="display: none;">
                    <div class="cart-info">
                        <i class="fa-solid fa-cart-shopping"></i>
                        <span id="cart-item-count">0</span>
                        <span class="total-price">¥<span id="cart-total-price">0.00</span></span>
                    </div>
                    <button id="checkout-btn">去结算</button>
                </div>
            </div>

            <div id="page-takeout-order-confirm" class="page">
                 <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-to-shop-from-confirm-btn"></i></div>
                    <h1>确认订单</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="order-confirm-content" style="padding: 15px;">
                    <!-- 订单确认信息将由JS动态生成 -->
                </div>
            </div>

            <div id="page-takeout-my-orders" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" data-target-page="page-takeout-main"></i></div>
                    <h1>我的订单</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="my-orders-content" style="padding: 10px;">
                    <!-- 历史订单将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                        <div id="page-takeout-order-details" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-order-details-btn"></i></div>
                    <h1>订单详情</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="takeout-order-details-content" style="padding: 15px;">
                    <!-- 订单详情将由JS动态生成 -->
                </div>
            </div>

            <!-- ▼▼▼ 新增：微博页面 (已重构) ▼▼▼ -->
            <div id="page-weibo" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-weibo-btn"></i></div>
                    <h1>微博</h1>
                    <div class="header-right">
                        <i class="fa-solid fa-wand-magic-sparkles header-icon" id="generate-weibo-content-btn"></i>
                    </div>
                </div>
                <div class="page-content" id="weibo-page-content" style="padding: 0; background-color: var(--bg-main);">
                    <!-- 广场页面 -->
                    <div class="weibo-tab-content" id="weibo-plaza-content">
                        <!-- 热搜和微博流将由JS动态生成 -->
                    </div>
                    <!-- 关注页面 -->
                    <div class="weibo-tab-content" id="weibo-following-content">
                        <div class="empty-placeholder" style="display:block; padding-top: 40px;"><p>关注页面施工中...</p></div>
                    </div>
                    <!-- 我的页面 -->
                    <div class="weibo-tab-content" id="weibo-my-profile-content">
                        <div class="empty-placeholder" style="display:block; padding-top: 40px;"><p>我的页面施工中...</p></div>
                    </div>
                </div>
                <!-- 微博页底部导航栏 -->
                <div id="weibo-bottom-nav">
                    <div class="weibo-tab-btn" data-tab="plaza">
                        <i class="fa-solid fa-house"></i>
                        <span>广场</span>
                    </div>
                    <div class="weibo-tab-btn" data-tab="following">
                        <i class="fa-solid fa-user-group"></i>
                        <span>关注</span>
                    </div>
                    <div class="weibo-tab-btn" data-tab="my-profile">
                        <i class="fa-solid fa-circle-user"></i>
                        <span>我的</span>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 重构完成 ▲▲▲ -->

            <!-- ▼▼▼ 新增：直播大厅页面 ▼▼▼ -->
            <div id="page-live-stream" class="page">
                                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-live-stream-btn"></i></div>
                    <h1>直播中心</h1>
                    <div class="header-right" id="live-stream-header-actions">
                        <!-- 核心修改：直接将按钮放在这里 -->
                        <i class="fa-solid fa-user-plus header-icon" id="create-streamer-from-friend-btn"></i>
                    </div>
                </div>


                <div id="live-stream-tabs" class="contacts-tabs">
                     <div class="contact-tab active" data-tab="recommended">推荐</div>
                     <div class="contact-tab" data-tab="following">关注</div>
                     <div class="contact-tab" data-tab="my">我的</div>
                </div>
                <div class="page-content" style="background-color: var(--bg-main); padding: 10px;">
                    <div class="live-tab-content active" id="live-recommended-content">
                        <!-- 推荐直播列表将由JS动态生成 -->
                    </div>
                    <div class="live-tab-content" id="live-following-content">
                        <div class="empty-placeholder" style="display:block; padding-top: 40px;"><p>还没有关注的主播哦~</p></div>
                    </div>
                    <div class="live-tab-content" id="live-my-content">
                        <!-- “我的”直播间管理将由JS动态生成 -->
                    </div>
                </div>
            </div>

            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
            <!-- ▼▼▼ 新增：创建直播间页面 ▼▼▼ -->
            <div id="page-create-streamer" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-create-streamer-btn"></i></div>
                    <h1>新建直播间</h1>
                    <div class="header-right"><button class="header-btn" id="save-streamer-btn">创建</button></div>
                </div>
                <div class="page-content page-form-content" id="create-streamer-form-content">
                    <!-- 表单内容将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
            <!-- ▼▼▼ 新增：修改主播信息页面 ▼▼▼ -->
            <div id="page-edit-streamer" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-edit-streamer-btn"></i></div>
                    <h1>修改主播信息</h1>
                    <div class="header-right"><button class="header-btn" id="save-edited-streamer-btn">保存</button></div>
                </div>
                <div class="page-content page-form-content" id="edit-streamer-form-content">
                    <!-- 表单内容将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->

            <!-- ▼▼▼ 新增：直播间页面 ▼▼▼ -->
            <div id="page-live-room" class="page">
                <!-- 核心修改：这里我们不再需要固定的背景元素了，将直接用CSS控制页面背景 -->
                <div class="live-room-header">
                    <div class="streamer-info-card">
                        <img id="live-room-streamer-avatar" class="item-avatar" style="cursor: pointer;">
                        <input type="file" id="streamer-avatar-input" class="avatar-file-input" accept="image/*">
                        <div class="streamer-info-text">
                            <div id="live-room-streamer-name" class="item-name"></div>
                            <div id="live-room-streamer-followers" class="item-last-msg"></div>
                        </div>
                    </div>
                    <!-- ▼▼▼ 新增：排行榜按钮 ▼▼▼ -->
                    <i class="fa-solid fa-trophy header-icon" id="show-leaderboard-btn" style="color: #FFD700; margin-left: auto;"></i>
                    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                    <button id="live-room-follow-btn">关注</button>
                    <i class="fa-solid fa-xmark header-icon" id="close-live-room-btn"></i>
                </div>



                <div class="live-room-chat-feed" id="live-room-chat-feed">
                    <!-- 弹幕将由JS动态生成 -->
                </div>
                
                <div class="floating-likes-container" id="floating-likes-container"></div>
                <div class="live-room-footer">
                    <input type="text" id="live-room-comment-input" placeholder="说点什么...">
                    <button class="action-btn" id="live-room-send-comment-btn"><i class="fa-solid fa-paper-plane"></i></button>
                    <button class="action-btn" id="live-room-interact-btn"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                    <button class="action-btn" id="live-room-send-gift-btn"><i class="fa-solid fa-gift"></i></button>
                </div>


            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->

            <!-- ▼▼▼ 新增：直播收益明细页面 ▼▼▼ -->
            <div id="page-live-earnings" class="page">
                <div class="page-header">
                    <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-live-earnings-btn"></i></div>
                    <h1>直播收益明细</h1>
                    <div class="header-right"></div>
                </div>
                <div class="page-content" id="live-earnings-content">
                    <!-- 收益明细将由JS动态生成 -->
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->




            <!-- ▼▼▼ 新增：来电显示页面 ▼▼▼ -->

            <div id="incoming-call-screen">
                <div>
                    <img id="incoming-caller-avatar" src="">
                    <div id="incoming-caller-name"></div>
                    <div id="incoming-call-text">邀请你进行视频通话...</div>
                </div>
                <div class="incoming-call-actions">
                    <button class="call-control-btn hang-up" id="decline-call-btn">
                        <div class="icon-bg"><i class="fas fa-phone-slash"></i></div>
                        <span>拒绝</span>
                    </button>
                    <button class="call-control-btn" id="accept-call-btn" style="color: #28a745;">
                        <div class="icon-bg" style="background-color: #28a745;"><i class="fas fa-video" style="color: white;"></i></div>
                        <span>接听</span>
                    </button>
                </div>
            </div>
            <!-- ▲▲▲ 新增完成 ▲▲▲ -->
        </div>


        <!-- ... 底部导航栏和编辑栏保持不变 ... -->


        <div id="bottom-nav">
            <div class="nav-item active" data-page="page-conversations"><i class="fa-solid fa-comments"></i><span>消息</span></div>
            <div class="nav-item" data-page="page-contacts"><i class="fa-solid fa-address-book"></i><span>通讯录</span></div>
            <div class="nav-item" data-page="page-discover"><i class="fa-solid fa-compass"></i><span>发现</span></div>
            <div class="nav-item" data-page="page-settings"><i class="fa-solid fa-cog"></i><span>系统</span></div>
        </div>
        <div class="edit-mode-bar" id="conversations-edit-bar">
            <button id="conv-select-all-btn">全选</button>
            <button class="delete-btn" id="conv-delete-selected-btn">删除已选</button>
        </div>
        <div class="edit-mode-bar" id="contacts-edit-bar">
            <button id="contact-select-all-btn">全选</button>
            <button class="delete-btn" id="contact-delete-selected-btn">删除已选</button>
        </div>
    </div>

    <!-- ... 弹窗与提示保持不变 ... -->

    <!-- 升级：带确认按钮的通用选择器弹窗 -->
    <div id="selection-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header" id="selection-modal-title">请选择</h3>
            <div id="selection-options-list" class="selection-list" style="max-height: 50vh; overflow-y: auto;">
                <!-- 选项将由JS动态生成 -->
            </div>
            <!-- 新增：确认和取消按钮 -->
            <div class="modal-actions" id="selection-modal-actions" style="display: none;">
                <button class="modal-btn btn-secondary" id="selection-cancel-btn">取消</button>
                <button class="modal-btn btn-primary" id="selection-confirm-btn">确认</button>
            </div>
        </div>
    </div>


    <div id="add-contact-modal" class="modal-overlay from-bottom">

        <div class="modal-content">
            <h3 class="modal-header">新建/导入</h3>
            <div class="add-options-list">
                <div class="add-option-item" id="menu-add-friend">
                    <div class="add-option-icon"><i class="fa-solid fa-user-plus"></i></div>
                    <span>添加新好友</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <div class="add-option-item" id="menu-add-group">
                    <div class="add-option-icon"><i class="fa-solid fa-users"></i></div>
                    <span>新建群聊</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <div class="add-option-item" id="menu-add-friend-group">
                    <div class="add-option-icon"><i class="fa-solid fa-folder-plus"></i></div>
                    <span>新建分组</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <div class="add-option-item" id="menu-add-preset-role">
                    <div class="add-option-icon"><i class="fa-solid fa-user-secret"></i></div> <!-- 图标更新 -->
                    <span>新增内置角色</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <div class="add-option-item" id="menu-import-role">
                    <div class="add-option-icon"><i class="fa-solid fa-file-import"></i></div>
                    <span>导入角色/群聊</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
            </div>
        </div>
    </div>

        <!-- 新增：聊天页好友管理弹窗 -->
    <div id="chat-options-modal" class="modal-overlay from-bottom">
        <div class="modal-content">
            <!-- 这里我们不使用 modal-header，而是自定义一个标题 -->
            <h3 class="chat-options-title">好友管理</h3>
            <div class="add-options-list">
                <div class="add-option-item" id="menu-view-details-from-chat">
                    <div class="add-option-icon"><i class="fa-solid fa-circle-info"></i></div>
                    <span>查看详细资料</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <div class="add-option-item" id="menu-edit-friend-from-chat">
                    <div class="add-option-icon"><i class="fa-solid fa-user-pen"></i></div>
                    <span>修改好友信息</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                 <div class="add-option-item" id="menu-bind-player-from-chat">
                    <div class="add-option-icon"><i class="fa-solid fa-user-tie"></i></div>
                    <span>绑定玩家人设</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <!-- ▼▼▼ 新增：关键词功能入口 ▼▼▼ -->
                <div class="add-option-item" id="menu-set-keywords-from-chat">
                    <div class="add-option-icon"><i class="fa-solid fa-key"></i></div>
                    <span>关键词/世界观</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <!-- ▲▲▲ 新增完成 ▲▲▲ -->
                <!-- ▼▼▼ 新增：清空聊天记录按钮 ▼▼▼ -->
                <div class="add-option-item" id="menu-clear-chat-history" style="margin-top: 10px;">
                    <div class="add-option-icon"><i class="fa-solid fa-eraser" style="color: var(--danger-color);"></i></div>
                    <span style="color: var(--danger-color);">清空聊天记录</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <!-- ▲▲▲ 新增完成 ▲▲▲ -->
            </div>
        </div>
    </div>





        <div id="edit-info-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header" id="edit-info-title">编辑信息</h3>
            <div class="form-group" style="padding:0; background: transparent;">
                <textarea id="edit-info-input"></textarea>
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="edit-info-cancel-btn">取消</button>
                <button class="modal-btn btn-primary" id="edit-info-save-btn">保存</button>
            </div>
        </div>
    </div>

    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header" id="confirm-title">提示</h3>
            <p id="confirm-message" style="text-align: center;"></p>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="confirm-cancel-btn">取消</button>
                <button class="modal-btn btn-primary" id="confirm-ok-btn">确定</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast-notification"></div>

    <!-- 新增：心声/随笔弹窗 -->
    <div id="thought-modal" class="modal-overlay">
        <div class="modal-content">
            <!-- ▼▼▼ 核心修改：改造标题栏，加入按钮 ▼▼▼ -->
            <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center;">
                <span>对方的心声</span>
                <i class="fa-solid fa-wand-magic-sparkles header-icon" id="regenerate-thought-btn" style="cursor: pointer; font-size: 1rem;" title="AI重新思考"></i>
            </div>
            <!-- ▲▲▲ 修改完成 ▲▲▲ -->
            <div id="thought-modal-content-area" style="max-height: 60vh; overflow-y: auto; padding: 0 5px;">
                <!-- 内容将由JS动态生成 -->
            </div>
            <div class="modal-actions" style="margin-top: 15px;">
                <button class="modal-btn btn-primary" id="close-thought-modal-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- 1. DOM 元素获取 ---
    const getEl = (id) => document.getElementById(id);
    const appContainer = getEl('app-container');
    const pages = document.querySelectorAll('.page');
    const navItems = document.querySelectorAll('.nav-item');
    const myAvatar = getEl('my-avatar');
    const chatArea = getEl('chat-area');
    const messageInput = getEl('message-input');
    const sendBtn = getEl('send-btn');
    const chatHeaderTitle = getEl('chat-header-title');
    const addContactModal = getEl('add-contact-modal');

    // --- 2. 状态管理 ---
    let userProfile = {};
    let contacts = { friends: [], groups: [], friendGroups: [] };
    let conversations = [];
    let currentConversationId = null;
    let tempAvatarDataUrl = null;
    let confirmCallback = null;
    let moments = []; 
    let tempMomentImages = [];
    let activeCall = null;
    let callTimerInterval = null;
    let musicLibrary = [];
    let musicSessionContactId = null;
    let currentlyPlayingMsgId = null;
    const globalAudioPlayer = getEl('global-audio-player');
    let currentLyrics = [];
    let lastLyricIndex = -1;
    let playbackMode = 'list';
    let currentPlaylist = [];
    let keywordLibrary = [];
    let weiboData = { posts: [], hotSearches: [] };
    let takeoutData = {};
    let currentCart = {};
    let currentTakeoutShopId = null;
    let currentOrderRecipient = {};
    let orderDetailReturnPath = 'page-takeout-my-orders';
    let liveStreamData = [];
    let activeLiveRoomIntervals = { chat: null, likes: null };
    let activeLiveStreamerId = null;
    let activeLiveRoomEvent = null;

    const fullScreenPages = ['page-my-info', 'page-chat', 'page-api-settings', 'page-create-friend', 'page-create-group', 'page-create-friend-group', 'page-wallet', 'page-moments', 'page-post-moment', 'page-moments-api-settings', 'page-music-library', 'page-keywords', 'page-keyword-edit', 'page-keyword-picker', 'page-takeout-main', 'page-takeout-shop', 'page-takeout-order-confirm', 'page-takeout-my-orders', 'page-takeout-order-details', 'page-weibo', 'page-live-stream', 'page-live-room', 'page-live-earnings', 'page-online-store', 'page-edit-product', 'page-store-order-details', 'page-store-earnings', 'page-store-warehouse', 'page-wholesale-market'];

    // --- 3. 核心功能函数 ---
    function showPage(pageId) {
        pages.forEach(p => p.classList.remove('active')); 
        const targetPage = getEl(pageId); 
        if (targetPage) targetPage.classList.add('active'); 
        appContainer.classList.toggle('full-page', fullScreenPages.includes(pageId)); 
        const mainPages = ['page-conversations', 'page-contacts', 'page-discover', 'page-settings']; 
        if (mainPages.includes(pageId)) { 
            navItems.forEach(item => item.classList.toggle('active', item.getAttribute('data-page') === pageId)); 
        } 
    }

    function showToast(message, duration = 2000) { const toast = getEl('toast'); toast.textContent = message; toast.classList.add('show'); setTimeout(() => toast.classList.remove('show'), duration); }
    function showConfirmModal(title, message, onConfirm) { getEl('confirm-title').textContent = title; getEl('confirm-message').textContent = message; getEl('confirm-modal').classList.add('visible'); confirmCallback = onConfirm; }
    
    function showEditInfoModal({ title, initialValue, onSave }) {
        const modal = getEl('edit-info-modal');
        const modalTitle = getEl('edit-info-title');
        const textarea = getEl('edit-info-input');
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        modalTitle.textContent = title;
        textarea.value = initialValue;
        modal.classList.add('visible');
        textarea.focus();

        const saveHandler = () => { onSave(textarea.value.trim()); closeHandler(); };
        const closeHandler = () => { modal.classList.remove('visible'); saveBtn.removeEventListener('click', saveHandler); cancelBtn.removeEventListener('click', closeHandler); };

        saveBtn.addEventListener('click', saveHandler);
        cancelBtn.addEventListener('click', closeHandler);
    }
    // 之前缺失的通用选择器弹窗函数
    function showSelectionModal(title, options, currentValue, onSelect, config = {}) {
        const modal = getEl('selection-modal');
        const titleEl = getEl('selection-modal-title');
        const optionsList = getEl('selection-options-list');
        const actionsBar = getEl('selection-modal-actions');
        const confirmBtn = getEl('selection-confirm-btn');
        const cancelBtn = getEl('selection-cancel-btn');

        titleEl.textContent = title;
        optionsList.innerHTML = ''; // 清空旧选项

        options.forEach(option => {
            const isSelected = String(option.value) === String(currentValue);
            const item = document.createElement('div');
            item.className = 'selection-option-item';
            if (isSelected) {
                item.classList.add('selected');
            }
            item.innerHTML = `
                <span>${option.text}</span>
                <i class="selection-option-icon fa-solid ${isSelected ? 'fa-circle-dot' : 'fa-circle'}"></i>
            `;
            
            item.onclick = () => {
                onSelect(option.value);
                modal.classList.remove('visible');
            };
            optionsList.appendChild(item);
        });

        const closeHandler = () => modal.classList.remove('visible');
        modal.onclick = (e) => {
            if (e.target === modal) closeHandler();
        };
        cancelBtn.onclick = closeHandler;

        modal.classList.add('visible');
    }

    // --- 4. 数据持久化 ---
    function loadAllData() {
        // (所有数据加载和迁移的逻辑都已包含在此处，无需改动)
        const defaultProfile = { name: '商时序', avatar: 'https://s2.loli.net/2023/05/23/9N25XbYVdDgrzQj.png', gender: '女', patAction: '拍一拍', patContent: '我的头', background: '', walletBalance: 0, walletHistory: [], momentsCover: 'https://img1.imgtp.com/2024/05/15/kdtIV2fL.jpg', orders: [], followingStreamerIds: [], onlineStore: { products: [], orders: [], earnings: 0 } };
        const loadedProfile = JSON.parse(localStorage.getItem('aiUserProfile'));
        if (!loadedProfile) { userProfile = defaultProfile; } else { userProfile = { ...defaultProfile, ...loadedProfile }; if (!Array.isArray(userProfile.walletHistory)) userProfile.walletHistory = []; if (!Array.isArray(userProfile.orders)) userProfile.orders = []; if (!Array.isArray(userProfile.followingStreamerIds)) userProfile.followingStreamerIds = []; }
        const defaultContacts = { friends: [], groups: [], friendGroups: [{id: 'group_default', name: '好友', friendIds: []}, {id: 'group_default_chats', name: '群聊', friendIds: []}] };
        contacts = JSON.parse(localStorage.getItem('aiContacts')) || defaultContacts;
        conversations = JSON.parse(localStorage.getItem('aiConversations')) || [];
        moments = JSON.parse(localStorage.getItem('aiMoments')) || [];
        if (moments && moments.length > 0) { moments.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); }
        musicLibrary = JSON.parse(localStorage.getItem('aiMusicLibrary')) || [];
        keywordLibrary = JSON.parse(localStorage.getItem('aiKeywordLibrary')) || [];
        weiboData = JSON.parse(localStorage.getItem('aiWeiboData')) || { posts: [], hotSearches: [] };
        if (weiboData.posts && weiboData.posts.length > 0) { weiboData.posts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); }
        let migrationNeeded = false;
        contacts.friends.forEach(friend => { if (typeof friend.keywords === 'string' && friend.keywords) { const newKeyword = { id: `kw_${Date.now()}_${Math.random()}`, title: `${friend.name}的专属设定`, content: friend.keywords }; keywordLibrary.push(newKeyword); friend.keywordIds = [newKeyword.id]; delete friend.keywords; migrationNeeded = true; } if (!friend.keywordIds) { friend.keywordIds = []; } });
        if (migrationNeeded) { saveContacts(); saveKeywordLibrary(); }
        conversations.forEach(conv => { if (conv.history && conv.history.length > 0) { conv.history.forEach((msg, index) => { if (!msg.id) { msg.id = `msg_${Date.now()}_${index}_${Math.random()}`; } if (!msg.status) { msg.status = 'normal'; } }); } if (!conv.diaryEntries) { conv.diaryEntries = []; } });
        let timeMigrationNeeded = false;
        conversations.forEach(conv => { if (conv.history && conv.history.length > 0 && !conv.history[0].timestamp) { timeMigrationNeeded = true; let currentTime = Date.now() - (3 * 24 * 60 * 60 * 1000); conv.history.forEach(msg => { if (!msg.timestamp) { currentTime += (Math.random() * 175 + 5) * 1000; msg.timestamp = new Date(currentTime).toISOString(); } }); conv.lastActivity = currentTime; } });
        if (timeMigrationNeeded) { saveConversations(); conversations.sort((a, b) => (b.lastActivity || 0) - (a.lastActivity || 0)); }
        const settings = JSON.parse(localStorage.getItem('aiChatSettings'));
        if (settings) { getEl('base-url').value = settings.baseUrl || ''; getEl('api-key').value = settings.apiKey || ''; getEl('model-name').value = settings.modelName || ''; }
        const momentsSettings = JSON.parse(localStorage.getItem('aiMomentsSettings'));
        if (momentsSettings) { getEl('moments-base-url').value = momentsSettings.baseUrl || ''; getEl('moments-api-key').value = momentsSettings.apiKey || ''; getEl('moments-model-name').value = momentsSettings.modelName || ''; }
    }

    function saveUserProfile() { localStorage.setItem('aiUserProfile', JSON.stringify(userProfile)); }
    function saveContacts() { localStorage.setItem('aiContacts', JSON.stringify(contacts)); }
    function saveConversations() { localStorage.setItem('aiConversations', JSON.stringify(conversations)); }
    function saveMoments() { localStorage.setItem('aiMoments', JSON.stringify(moments)); }
    function saveSettings() { const settings = { baseUrl: getEl('base-url').value.trim(), apiKey: getEl('api-key').value.trim(), modelName: getEl('model-name').value.trim() }; localStorage.setItem('aiChatSettings', JSON.stringify(settings)); showToast('设置已保存！'); }
    function saveMomentsSettings() { const settings = { baseUrl: getEl('moments-base-url').value.trim(), apiKey: getEl('moments-api-key').value.trim(), modelName: getEl('moments-model-name').value.trim() }; localStorage.setItem('aiMomentsSettings', JSON.stringify(settings)); showToast('朋友圈专用设置已保存！'); }
    function saveMusicLibrary() { localStorage.setItem('aiMusicLibrary', JSON.stringify(musicLibrary)); }
    function saveKeywordLibrary() { localStorage.setItem('aiKeywordLibrary', JSON.stringify(keywordLibrary)); }
    function saveWeiboData() { localStorage.setItem('aiWeiboData', JSON.stringify(weiboData)); }
    function saveLiveStreamData() { localStorage.setItem('aiLiveStreamData', JSON.stringify(liveStreamData)); }


     // --- 5. 渲染函数 (多项更新) ---
 function renderAll() { 
        renderMyAvatar(); 
        renderConversationList(); 
        renderContactsPage();
        renderSettingsPage(); 
    }
    function renderMyAvatar() { myAvatar.src = userProfile.avatar; }
       function renderSettingsPage() {
        const settingsList = getEl('settings-list-container');
        settingsList.innerHTML = `
            <div class="setting-item" id="wallet-btn">
                <i class="fa-solid fa-wallet"></i>
                <span>钱包</span>
                <span style="font-size: 0.9rem; color: var(--text-color-medium); margin-right: 8px;">¥ ${userProfile.walletBalance.toFixed(2)}</span>
                <i class="fa-solid fa-chevron-right"></i>
            </div>
            <div class="setting-item" id="api-config-btn">
                <i class="fa-solid fa-server"></i>
                <span>通用 API 配置</span>
                <i class="fa-solid fa-chevron-right"></i>
            </div>
            <div class="setting-item" id="moments-api-config-btn">
                <i class="fa-solid fa-camera-retro"></i>
                <span>朋友圈 API 配置</span>
                <i class="fa-solid fa-chevron-right"></i>
            </div>
            <div class="setting-item" id="export-data-btn">
                <i class="fa-solid fa-file-export icon-export"></i>
                <span>一键导出数据</span>
                <i class="fa-solid fa-chevron-right"></i>
            </div>
            <div class="setting-item" id="import-data-btn">
                <i class="fa-solid fa-file-import icon-import"></i>
                <span>一键导入数据</span>
                <i class="fa-solid fa-chevron-right"></i>
            </div>
        `;
        
        // 重新绑定所有事件
        getEl('wallet-btn').onclick = () => { renderWalletPage(); showPage('page-wallet'); };
        getEl('api-config-btn').onclick = () => showPage('page-api-settings');
        getEl('moments-api-config-btn').onclick = () => showPage('page-moments-api-settings');
        
        // ▼▼▼ 关键修复：把导出和导入的“指令”也搬到这里来 ▼▼▼
        const exportBtn = getEl('export-data-btn');
        const importBtn = getEl('import-data-btn');
        const importFileInput = getEl('import-file-input');

        // 下载JSON文件的辅助函数
        function downloadJsonFile(data, filename) {
            if (!window.Blob || !window.URL || !document.createElement('a').download) {
                showToast('您的浏览器不支持文件下载功能。');
                return;
            }
            try {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
                const a = document.createElement('a');
                a.style.display = 'none';
                a.style.position = 'absolute';
                a.style.left = '-9999px';
                const url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            } catch (e) {
                console.error('导出失败:', e);
                showToast('导出文件时发生错误，请查看控制台。');
            }
        }

        // 导出按钮点击事件
        exportBtn.onclick = () => {
            showConfirmModal('确认导出', '即将导出一个包含您所有数据（人设、好友、聊天记录等）的备份文件，请妥善保管。', () => {
                const allData = {};
                const keysToExport = [
                    'aiUserProfile', 'aiContacts', 'aiConversations', 'aiMoments',
                    'aiMusicLibrary', 'aiKeywordLibrary', 'aiWeiboData', 'aiLiveStreamData',
                    'aiChatSettings', 'aiMomentsSettings'
                ];
                keysToExport.forEach(key => {
                    const data = localStorage.getItem(key);
                    if (data) {
                        allData[key] = JSON.parse(data);
                    }
                });
                downloadJsonFile(allData, 'ai_phone_backup.json');
                getEl('confirm-modal').classList.remove('visible');
                showToast('数据已开始导出！');
            });
        };

        // 导入按钮点击事件
        importBtn.onclick = () => {
            showConfirmModal('确认导入', '导入操作将清空当前所有数据，并替换为文件中的内容。此操作不可逆，请确认您已备份当前数据！', () => {
                getEl('confirm-modal').classList.remove('visible');
                importFileInput.click();
            });
        };
        // ▲▲▲ 修复完成 ▲▲▲
    }





    // 新增: 渲染钱包页面
    function renderWalletPage() {
        const content = getEl('wallet-page-content');
        let historyHtml = '';
        if (userProfile.walletHistory && userProfile.walletHistory.length > 0) {
            // reverse()会改变原数组，所以先复制一份再反转
            [...userProfile.walletHistory].reverse().forEach(item => {
                const isIncome = item.type === 'income';
                const amountClass = isIncome ? 'income' : 'expense';
                const sign = isIncome ? '+' : '-';
                const date = new Date(item.date).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit' });
                historyHtml += `
                    <div class="transaction-item">
                        <div class="transaction-details">
                            <div class="reason">${item.reason}</div>
                            <div class="date">${date}</div>
                        </div>
                        <div class="transaction-amount ${amountClass}">${sign}${item.amount.toFixed(2)}</div>
                        <button class="transaction-delete-btn" data-date="${item.date}"><i class="fa-solid fa-xmark"></i></button>
                    </div>
                `;
            });
        } else {
            historyHtml = '<div class="empty-placeholder" style="display:block; padding: 40px 0;">暂无收支明细</div>';
        }

        content.innerHTML = `
            <div class="wallet-balance-card">
                <div class="balance-label">账户余额 (元)</div>
                <div class="balance-amount">
                    <span>${userProfile.walletBalance.toFixed(2)}</span>
                    <button class="edit-balance-btn" id="edit-balance-btn">修改</button>
                </div>
            </div>
            <div class="transaction-list-header">收支明细</div>
            <div class="transaction-list">${historyHtml}</div>
        `;

        getEl('edit-balance-btn').onclick = handleEditBalance;
        // 核心新增：为所有新生成的删除按钮绑定点击事件
        document.querySelectorAll('.transaction-delete-btn').forEach(btn => {
            btn.onclick = () => handleDeleteTransaction(btn.dataset.date);
        });
    }


    function renderConversationList() { /* ... */ }
    function renderContactsPage() { /* ... */ }
    function renderContactsFriends() { /* ... */ }
    function renderContactsGroups() { /* ... */ }
    function renderContactsFriendGroups() { /* ... */ }
    
    // 修改: renderMyInfoPage 函数，使其也使用新的选择器UI
    function renderMyInfoPage() {
        tempAvatarDataUrl = userProfile.avatar;
        const formContent = getEl('my-info-form-content');

        // 1. 修改HTML，将性别<select>替换为我们自定义的样式
        formContent.innerHTML = `
            <div class="avatar-upload-area">
                <img id="my-info-avatar-preview" class="avatar-preview" src="${userProfile.avatar}">
                <span style="font-size: 0.8rem; color: var(--text-color-medium);">点击头像更换</span>
                <input type="file" id="my-avatar-file-input" class="avatar-file-input" accept="image/*">
            </div>
            <div class="form-group"><label>姓名</label><input type="text" id="my-info-name" value="${userProfile.name || ''}"></div>
            
            <!-- 我的信息 性别选择器 -->
            <div class="form-group selectable" id="my-info-gender-selector">
                <label>性别</label>
                <div class="form-value">
                    <span id="my-info-gender-value-text">${userProfile.gender}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="my-info-gender" value="${userProfile.gender}">
            </div>

            <div class="form-group"><label>拍一拍动作</label><input type="text" id="my-info-pat-action" placeholder="选填，例如: 拍一拍" value="${userProfile.patAction || ''}"></div>
            <div class="form-group"><label>拍一拍内容</label><input type="text" id="my-info-pat-content" placeholder="选填，例如: 的头, 被揉了" value="${userProfile.patContent || ''}"></div>
            <div class="form-group"><label>背景资料</label><textarea id="my-info-background" placeholder="关于你的更多信息...">${userProfile.background || ''}</textarea></div>
            <div class="form-actions-bar">
                <button id="delete-my-info-btn" class="btn-delete">删除</button>
                <button id="save-my-info-btn-bottom" class="btn-save">保存</button>
            </div>
        `;
     // 2. 绑定事件
        getEl('my-info-avatar-preview').onclick = () => getEl('my-avatar-file-input').click();
        getEl('my-avatar-file-input').onchange = (e) => handleAvatarChange(e, 'my-info-avatar-preview');
        getEl('save-my-info-btn-bottom').onclick = saveMyInfo;
        getEl('delete-my-info-btn').onclick = handleDeleteMyInfo;

        // 3. 为新的性别选择器绑定点击事件，调用我们通用的弹窗函数
        getEl('my-info-gender-selector').onclick = () => {
            const options = [{value: '男', text: '男'}, {value: '女', text: '女'}];
            const currentValue = getEl('my-info-gender').value;
            showSelectionModal('选择性别', options, currentValue, (selectedValue) => {
                // 当用户在弹窗中选择后，这里的代码会被执行
                getEl('my-info-gender').value = selectedValue; // 更新隐藏input的值
                getEl('my-info-gender-value-text').textContent = selectedValue; // 更新页面上显示的文字
            });
        };
    }


    function renderCreateFriendPage() { /* ... */ }
     function renderCreateGroupPage() { /* ... */ }
    
    // 之前这里是空的，现在我们把它补全
    renderCreateFriendGroupPage = function() { 
        if (contacts.friends.length === 0) { 
            showConfirmModal('提示', '通讯录中还没有好友，无法创建分组。', () => getEl('confirm-modal').classList.remove('visible')); 
            return; 
        } 
        let friendsHtml = ''; 
        contacts.friends.forEach(f => { 
            friendsHtml += `<div class="member-item"><input type="checkbox" value="${f.id}"><img src="${f.avatar}"><span>${f.name}</span></div>`; 
        }); 
        getEl('create-friend-group-form-content').innerHTML = `<div class="form-group"><label>分组名称 (必填)</label><input type="text" id="friend-group-name" placeholder="为分组起个名字"></div><div class="form-group"><label>选择好友</label><div class="member-selection-list">${friendsHtml}</div></div>`; 
        showPage('page-create-friend-group'); 
    }

    // 为了简洁，这里省略了未改变的函数体

                renderConversationList = function() {
            const ul = getEl('conversation-list-ul');
            ul.innerHTML = '';
            getEl('empty-conversation-placeholder').style.display = conversations.length === 0 ? 'block' : 'none';
        
            // 核心修改：实现置顶排序逻辑
            const sortedConversations = [...conversations].sort((a, b) => {
                // 如果 a 置顶而 b 没有，a 排前面
                if (a.isPinned && !b.isPinned) return -1;
                // 如果 b 置顶而 a 没有，b 排前面
                if (!a.isPinned && b.isPinned) return 1;
                // 如果都置顶或都不置顶，则按最后活动时间排序
                return (b.lastActivity || 0) - (a.lastActivity || 0);
            });
        
            sortedConversations.forEach(conv => {
                const target = conv.type === 'group' ?
                    contacts.groups.find(g => g.id === conv.contactId) :
                    contacts.friends.find(f => f.id === conv.contactId);
        
                if (!target) return;
        
                const li = document.createElement('li');
                li.className = 'list-item conversation-item';
                if (conv.isPinned) {
                    li.classList.add('pinned'); // 如果置顶，添加 pinned 类
                }
                li.dataset.id = conv.id;
        
                const lastMessage = conv.history[conv.history.length - 1];
                let lastMessageText = '开始聊天吧...';
                if (lastMessage) {
                    // ... (此处省略了switch case判断消息类型的代码，保持不变) ...
                                        switch (lastMessage.type) {
                        case 'music_share': lastMessageText = `[一起听歌] ${lastMessage.content.title}`; break;
                        case 'transfer': case 'transfer_receipt': lastMessageText = '[转账]'; break;
                        case 'voice': lastMessageText = '[语音]'; break;
                        case 'call_record': lastMessageText = '[通话记录]'; break;
                        case 'takeout_share': lastMessageText = `[外卖订单] ${lastMessage.content.shopName}`; break;
                        case 'location_share': lastMessageText = `[位置] ${lastMessage.content}`; break;
                        case 'product_share': lastMessageText = `[商品分享] ${lastMessage.content.name}`; break;
                        default: if (typeof lastMessage.content === 'string') { lastMessageText = lastMessage.content; } else { lastMessageText = '...'; } break;
                    }

                }
        
                const defaultAvatar = 'https://s2.loli.net/2023/05/23/gM3FPAfWk1vYc8z.png';
                li.innerHTML = `
                    <input type="checkbox" class="select-checkbox" style="display: none;">
                    <img src="${target.avatar || defaultAvatar}" alt="avatar" class="item-avatar" onerror="this.src='${defaultAvatar}'">
                    <div class="item-content">
                        <div class="item-name">${getDisplayName(target)}</div>
                        <div class="item-last-msg">${lastMessageText.substring(0, 25)}...</div>
                    </div>`;
        
                // 核心新增：长按事件监听
                let pressTimer = null;
                const startPress = (e) => {
                    if (getEl('page-conversations').classList.contains('edit-mode')) return;
                    pressTimer = setTimeout(() => {
                        showConversationContextMenu(conv.id, e);
                    }, 500); // 长按半秒触发
                };
                const endPress = () => {
                    clearTimeout(pressTimer);
                };
                li.addEventListener('mousedown', startPress);
                li.addEventListener('mouseup', endPress);
                li.addEventListener('mouseleave', endPress);
                li.addEventListener('touchstart', startPress, { passive: true });
                li.addEventListener('touchend', endPress);
                
                li.addEventListener('click', (event) => {
                    const page = getEl('page-conversations');
                    if (page.classList.contains('edit-mode')) {
                        const checkbox = li.querySelector('.select-checkbox');
                        if (event.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }
                    } else {
                        openConversation(conv.id);
                    }
                });
        
                ul.appendChild(li);
            });
        }


    renderContactsPage = function() { const content = getEl('contacts-page-content'); content.innerHTML = `<div class="contacts-tabs"><div class="contact-tab active" data-tab="friends">好友</div><div class="contact-tab" data-tab="groups">群聊</div><div class="contact-tab" data-tab="friend-groups">分组</div></div><div class="contact-group active" id="tab-friends"></div><div class="contact-group" id="tab-groups"></div><div class="contact-group" id="tab-friend-groups"></div>`; renderContactsFriends(); renderContactsGroups(); renderContactsFriendGroups(); content.querySelectorAll('.contact-tab').forEach(tab => { tab.addEventListener('click', () => { content.querySelector('.contact-tab.active').classList.remove('active'); tab.classList.add('active'); content.querySelector('.contact-group.active').classList.remove('active'); getEl(`tab-${tab.dataset.tab}`).classList.add('active'); }); }); }
          renderContactsFriends = function() {
        const container = getEl('tab-friends');

        // ▼▼▼ 新增的核心判断逻辑 ▼▼▼
        // 先检查好友总数是否为 0
        if (contacts.friends.length === 0) {
            // 如果是，就显示和“群聊”页面一样的提示，然后结束函数
            container.innerHTML = `<div class="empty-placeholder" style="display: block;"><p>暂无好友</p></div>`;
            return;
        }
        // ▲▲▲ 新增的核心判断逻辑 ▲▲▲

        // 如果好友总数不为 0，才执行下面的代码
        container.innerHTML = '';
        contacts.friendGroups.forEach(group => {
            if (group.id === 'group_default_chats') return;
            
            const friendsInGroup = contacts.friends.filter(f => group.friendIds.includes(f.id));
            
            // 优化：只显示那些里面有好友的分组，避免出现空的“未分组”等
            if (friendsInGroup.length > 0) {
                let groupHtml = `<div class="group-header">${group.name}</div><ul class="contact-list">`;
                friendsInGroup.forEach(friend => {
                    groupHtml += `<li class="list-item contact-item" data-id="${friend.id}" data-type="friend"><input type="checkbox" class="select-checkbox" style="display: none;"><img src="${friend.avatar}" class="item-avatar"><div class="item-content"><div class="item-name">${friend.name}</div></div></li>`;
                });
                groupHtml += `</ul>`;
                container.innerHTML += groupHtml;
            }
        });

        // 绑定点击事件的逻辑保持不变
        container.querySelectorAll('.contact-item[data-type="friend"]').forEach(item => {
            item.addEventListener('click', () => {
                if (getEl('page-contacts').classList.contains('edit-mode')) return;

                const friendId = item.dataset.id;
                let conversation = conversations.find(c => c.contactId === friendId);
                
                if (!conversation) {
                    conversation = {
                        id: `conv_${Date.now()}`,
                        contactId: friendId,
                        type: 'friend',
                        history: [],
                        lastActivity: Date.now()
                    };
                    conversations.push(conversation);
                    saveConversations();
                    renderConversationList();
                }
                openConversation(conversation.id);
            });
        });
    }

    renderContactsGroups = function() {
        const container = getEl('tab-groups');
        let html = '';
        if (contacts.groups.length > 0) {
            html += '<ul class="contact-list">';
            contacts.groups.forEach(group => {
                html += `<li class="list-item contact-item" data-id="${group.id}" data-type="group"><input type="checkbox" class="select-checkbox" style="display: none;"><img src="${group.avatar}" class="item-avatar"><div class="item-content"><div class="item-name">${group.name}</div></div></li>`;
            });
            html += '</ul>';
        } else {
            html += `<div class="empty-placeholder" style="display: block;"><p>暂无群聊</p></div>`;
        }
        container.innerHTML = html;

        // ▼▼▼ 新增的完整功能代码块 ▼▼▼
        container.querySelectorAll('.contact-item[data-type="group"]').forEach(item => {
            item.addEventListener('click', () => {
                // 核心修复：先判断是否在编辑模式
                if (getEl('page-contacts').classList.contains('edit-mode')) return;

                const groupId = item.dataset.id;
                // 查找或创建与该群聊的对话
                let conversation = conversations.find(c => c.contactId === groupId);
                if (!conversation) {
                    conversation = {
                        id: `conv_${Date.now()}`,
                        contactId: groupId,
                        type: 'group',
                        history: [],
                        lastActivity: Date.now()
                    };
                    conversations.push(conversation);
                    saveConversations();
                    renderConversationList();
                }
                openConversation(conversation.id);
            });
        });
        // ▲▲▲ 新增的完整功能代码块 ▲▲▲
    }

    renderContactsFriendGroups = function() { const container = getEl('tab-friend-groups'); let html = ''; const customGroups = contacts.friendGroups.filter(g => g.id !== 'group_default' && g.id !== 'group_default_chats'); if (customGroups.length > 0) { html += '<ul class="contact-list">'; customGroups.forEach(group => { html += `<li class="list-item contact-item" data-id="${group.id}" data-type="friend-group"><input type="checkbox" class="select-checkbox" style="display: none;"><img src="https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png" class="item-avatar"><div class="item-content"><div class="item-name">${group.name} (${group.friendIds.length})</div></div></li>`; }); html += '</ul>'; } else { html += `<div class="empty-placeholder" style="display: block;"><p>暂无好友分组</p></div>`; } container.innerHTML = html; }
    renderCreateFriendPage = function() {
        tempAvatarDataUrl = 'https://s2.loli.net/2023/05/23/gM3FPAfWk1vYc8z.png'; 
        const formContent = getEl('create-friend-form-content');
        
        // 核心修改：将 <select> 标签替换为可点击的 <div> 结构
        formContent.innerHTML = `
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload-area" style="flex-direction: row; justify-content: flex-start; gap: 15px; padding: 0;">
                    <img id="friend-avatar-preview" class="avatar-preview" src="${tempAvatarDataUrl}" style="width: 64px; height: 64px;">
                    <button id="upload-friend-avatar-btn" class="upload-avatar-btn" style="background-color: #EAEAEA; color: var(--text-color-dark); border:none; padding: 8px 15px; border-radius: 8px; cursor: pointer;">上传头像</button>
                    <input type="file" id="friend-avatar-file-input" class="avatar-file-input" accept="image/*">
                </div>
            </div>
            <div class="form-group"><label>姓名 (唯一ID, 必填)</label><input type="text" id="friend-name" placeholder="为AI好友起个名字"></div>
            <div class="form-group"><label>备注 (选填)</label><input type="text" id="friend-remark" placeholder="你对TA的称呼"></div>
            
            <!-- 性别选择器 (UI更新) -->
            <div class="form-group selectable" id="create-gender-selector">
                <label>性别 (必填)</label>
                <div class="form-value">
                    <span id="create-gender-value-text">男</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="friend-gender" value="男">
            </div>

            <!-- 允许撤回消息选择器 (UI更新) -->
            <div class="form-group selectable" id="create-recall-selector">
                <label>允许撤回消息</label>
                <div class="form-value">
                    <span id="create-recall-value-text">开启</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="friend-allow-recall" value="true">
            </div>
            
            <!-- 允许发送表情包选择器 (UI更新) -->
            <div class="form-group selectable" id="create-stickers-selector">
                <label>允许发送表情包</label>
                <div class="form-value">
                    <span id="create-stickers-value-text">开启</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="friend-allow-stickers" value="true">
            </div>

            <div class="form-group"><label>厌恶 (选填)</label><textarea id="friend-dislikes" placeholder="例如: 被忽视、下雨"></textarea></div>
            <div class="form-group"><label>习惯 (选填)</label><textarea id="friend-habits" placeholder="例如: 晨跑、运动"></textarea></div>
            <div class="form-group"><label>拍一拍动作 (选填)</label><input type="text" id="friend-pat-action" placeholder="例如: 拍了拍"></div>
            <div class="form-group"><label>拍一拍内容 (选填)</label><input type="text" id="friend-pat-content" placeholder="例如: 的头, 被反弹了"></div>
            <div class="form-group"><label>背景资料 (选填)</label><textarea id="friend-background" placeholder="角色的其他资料"></textarea></div>
            
            <div class="create-friend-actions">
                <button id="cancel-add-friend-btn" class="btn-cancel">取消</button>
                <button id="add-friend-btn" class="btn-add">添加</button>
            </div>
        `;
        
        // 绑定基础事件
        getEl('upload-friend-avatar-btn').onclick = () => getEl('friend-avatar-file-input').click();
        getEl('friend-avatar-file-input').onchange = (e) => handleAvatarChange(e, 'friend-avatar-preview');
        getEl('cancel-add-friend-btn').onclick = () => showPage('page-contacts');
        getEl('add-friend-btn').onclick = saveNewFriend;

        // 核心修改：为新的选择器绑定点击事件，让它们弹出选择窗口
        getEl('create-gender-selector').onclick = () => {
            const options = [{value: '男', text: '男'}, {value: '女', text: '女'}, {value: '不设置', text: '不设置'}];
            showSelectionModal('选择性别', options, getEl('friend-gender').value, (selectedValue) => {
                getEl('friend-gender').value = selectedValue;
                getEl('create-gender-value-text').textContent = selectedValue;
            });
        };
        
        getEl('create-recall-selector').onclick = () => {
            const options = [{value: true, text: '开启'}, {value: false, text: '关闭'}];
            showSelectionModal('允许撤回消息', options, getEl('friend-allow-recall').value, (selectedValue) => {
                getEl('friend-allow-recall').value = selectedValue;
                getEl('create-recall-value-text').textContent = selectedValue ? '开启' : '关闭';
            });
        };

        getEl('create-stickers-selector').onclick = () => {
            const options = [{value: true, text: '开启'}, {value: false, text: '关闭'}];
            showSelectionModal('允许发送表情包', options, getEl('friend-allow-stickers').value, (selectedValue) => {
                getEl('friend-allow-stickers').value = selectedValue;
                getEl('create-stickers-value-text').textContent = selectedValue ? '开启' : '关闭';
            });
        };
    }



    renderCreateGroupPage = function() { if (contacts.friends.length === 0) { showConfirmModal('提示', '通讯录中还没有好友，快去添加一些好友再来创建群聊吧！', () => getEl('confirm-modal').classList.remove('visible')); return; } tempAvatarDataUrl = 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png'; let membersHtml = ''; [userProfile, ...contacts.friends].forEach(f => { membersHtml += `<div class="member-item"><input type="checkbox" value="${f.id || 'user_profile'}"><img src="${f.avatar}"><span>${f.name} ${f.id ? '' : '(我)'}</span></div>`; }); getEl('create-group-form-content').innerHTML = `<div class="form-group"><label>群名称 (必填)</label><input type="text" id="group-name" placeholder="为群聊起个名字"></div><div class="form-group"><label>选择群主 (必填)</label><select id="group-owner"></select></div><div class="form-group"><label>选择群成员</label><div class="member-selection-list" id="group-members">${membersHtml}</div></div>`; const ownerSelect = getEl('group-owner'); const memberCheckboxes = getEl('group-members').querySelectorAll('input[type="checkbox"]'); function updateOwnerOptions() { const selectedMembers = Array.from(memberCheckboxes).filter(cb => cb.checked).map(cb => cb.value); ownerSelect.innerHTML = ''; if (selectedMembers.length === 0) { ownerSelect.innerHTML = '<option value="">请先选择群成员</option>'; return; } selectedMembers.forEach(memberId => { const member = memberId === 'user_profile' ? userProfile : contacts.friends.find(f => f.id === memberId); ownerSelect.innerHTML += `<option value="${memberId}">${member.name} ${memberId === 'user_profile' ? '(我)' : ''}</option>`; }); } memberCheckboxes.forEach(cb => cb.onchange = updateOwnerOptions); updateOwnerOptions(); showPage('page-create-group'); }
            renderCreateFriendGroupPage = function() { 
        if (contacts.friends.length === 0) { 
            showConfirmModal('提示', '通讯录中还没有好友，无法创建分组。', () => getEl('confirm-modal').classList.remove('visible')); 
            return; 
        } 
        let friendsHtml = ''; 
        contacts.friends.forEach(f => { 
            friendsHtml += `<div class="member-item"><input type="checkbox" value="${f.id}"><img src="${f.avatar}"><span>${f.name}</span></div>`; 
        }); 
        getEl('create-friend-group-form-content').innerHTML = `<div class="form-group"><label>分组名称 (必填)</label><input type="text" id="friend-group-name" placeholder="为分组起个名字"></div><div class="form-group"><label>选择好友</label><div class="member-selection-list">${friendsHtml}</div></div>`; 
        showPage('page-create-friend-group'); 
    }

    // --- 新增：渲染朋友圈页面 ---
    function renderMomentsPage() {
        const contentArea = getEl('moments-content-area');
        
        let momentsHtml = '';
        if (moments.length > 0) {
            // 时间倒序排列
            const sortedMoments = [...moments].sort((a, b) => b.timestamp - a.timestamp);
            sortedMoments.forEach(moment => {
                momentsHtml += generateMomentHTML(moment);
            });
        } else {
            momentsHtml = '<div class="empty-placeholder" style="display:block;"><p>还没有动态，快来发布第一条吧！</p></div>';
        }

        contentArea.innerHTML = `
            <div class="moments-header">
                <img src="${userProfile.momentsCover}" class="moments-cover" id="change-moments-cover-btn">
                <div class="moments-user-info">
                    <span class="moments-user-name">${userProfile.name}</span>
                    <img src="${userProfile.avatar}" class="moments-user-avatar">
                </div>
            </div>
            <div class="moments-feed">${momentsHtml}</div>
        `;

        // 绑定事件
        document.querySelectorAll('.action-btn[data-action="like"]').forEach(btn => btn.onclick = () => handleLike(btn.dataset.momentId));
        document.querySelectorAll('.action-btn[data-action="comment"]').forEach(btn => btn.onclick = () => toggleCommentInput(btn.dataset.momentId));
        document.querySelectorAll('.comment-send-btn').forEach(btn => btn.onclick = () => handleComment(btn.dataset.momentId));
        document.querySelectorAll('.delete-moment-btn').forEach(btn => btn.onclick = () => handleDeleteMoment(btn.dataset.momentId));
    }

    // --- 新增：生成单条朋友圈的HTML ---
    function generateMomentHTML(moment) {
        const author = findContactById(moment.authorId) || userProfile;
        const isMyPost = moment.authorId === 'player';

        // 1. 图片部分
        let imagesHtml = '';
        if (moment.images && moment.images.length > 0) {
            const count = moment.images.length;
            const gridClass = `moment-images img-count-${count}`;
            imagesHtml = `<div class="${gridClass}">
                ${moment.images.map(img => `<img src="${img}" class="moment-image">`).join('')}
            </div>`;
        }

        // 2. 点赞和评论的社交区域
        let socialFeedHtml = '';
        const hasLikes = moment.likes && moment.likes.length > 0;
        const hasComments = moment.comments && moment.comments.length > 0;

        if (hasLikes || hasComments) {
            let likesHtml = '';
            if (hasLikes) {
                const likers = moment.likes.map(id => (findContactById(id) || userProfile).name).join(', ');
                likesHtml = `<div class="likes-section ${!hasComments ? 'no-comments' : ''}">
                    <i class="fa-solid fa-heart"></i> ${likers}
                </div>`;
            }

            let commentsHtml = '';
            if (hasComments) {
                commentsHtml = `<div class="comments-section">
                    ${moment.comments.map(comment => `
                        <div class="comment-item">
                            <span class="comment-author">${(findContactById(comment.authorId) || userProfile).name}:</span>
                            <span class="comment-content">${comment.content}</span>
                        </div>
                    `).join('')}
                </div>`;
            }
            socialFeedHtml = `<div class="moment-social-feed">${likesHtml}${commentsHtml}</div>`;
        }
        
        // 3. 组合最终HTML
        const isLiked = moment.likes.includes('player');
        return `
            <div class="moment-post" id="moment-${moment.id}">
                <img src="${author.avatar}" class="moment-avatar">
                <div class="moment-content">
<div class="moment-author-name">${getDisplayName(author)}</div>

                    ${moment.text ? `<div class="moment-text">${moment.text}</div>` : ''}
                    ${imagesHtml}
                    <div class="moment-footer">
                        <div class="left-side">
                           <span class="moment-timestamp">${new Date(moment.timestamp).toLocaleString()}</span>
                           ${isMyPost ? `<i class="fa-solid fa-trash-can delete-moment-btn" data-moment-id="${moment.id}"></i>` : ''}
                        </div>
                        <div class="moment-actions">
                            <button class="action-btn ${isLiked ? 'liked' : ''}" data-moment-id="${moment.id}" data-action="like">
                                <i class="fa-solid fa-heart"></i> <span id="like-count-${moment.id}">${moment.likes.length > 0 ? moment.likes.length : '赞'}</span>
                            </button>
                            <button class="action-btn" data-moment-id="${moment.id}" data-action="comment">
                                <i class="fa-solid fa-comment"></i> <span>评论</span>
                            </button>
                        </div>
                    </div>
                    ${socialFeedHtml}
                    <div class="comment-input-area" id="comment-input-area-${moment.id}" style="display: none;">
                        <input type="text" id="comment-input-${moment.id}" placeholder="评论...">
                        <button class="comment-send-btn" data-moment-id="${moment.id}">发送</button>
                    </div>
                </div>
            </div>
        `;
    }

    // --- 朋友圈交互的辅助函数 (V3.0) ---
    let currentReplyTarget = null; // 全局变量，用于跟踪回复目标

        function findContactById(id) {
        if (id === 'user_profile') return userProfile;
        // 核心新增：让程序认识匿名用户
        if (id === 'anonymous_user') {
            return { name: '匿名用户', avatar: '...' }; // 返回一个临时的匿名用户对象
        }
        return contacts.friends.find(f => f.id === id);
    }


    // ▼▼▼ 新增：获取显示名称的辅助函数 ▼▼▼
    function getDisplayName(contact) {
        if (!contact) return '未知用户'; // 安全检查
        // 如果contact.remark存在且不为空字符串，则返回remark，否则返回name
        return contact.remark || contact.name;
    }
    // ▲▲▲ 新增完成 ▲▲▲

    // ▼▼▼ 新增：获取玩家（用户自己）在直播场景下的显示名称 ▼▼▼
    function getPlayerDisplayName() {
        // 尝试在直播数据中找到用户自己的主播档案
        const playerStreamerProfile = liveStreamData.find(s => s.id === 'user_profile');
        // 如果找到了，就使用主播名；如果没找到，就使用通用的个人资料名
        if (playerStreamerProfile) {
            return playerStreamerProfile.name;
        } else {
            return userProfile.name;
        }
    }
    // ▲▲▲ 新增完成 ▲▲▲

    // 升级：渲染关键词库页面（带删除功能）
    function renderKeywordsPage() {
        const content = getEl('keywords-list-content');
        content.innerHTML = '';
        if (keywordLibrary.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>还没有任何关键词，点击右上角+号添加一个吧！</p></div>';
            return;
        }

        // 新增：处理删除的函数
        const handleDeleteKeyword = (keywordId) => {
            showConfirmModal('确认删除', '删除后，所有使用此关键词的好友都将不再受其影响。确定要删除吗？', () => {
                // 1. 从关键词库中删除
                keywordLibrary = keywordLibrary.filter(kw => kw.id !== keywordId);
                
                // 2. 从所有好友的引用中删除
                contacts.friends.forEach(friend => {
                    if (friend.keywordIds) {
                        friend.keywordIds = friend.keywordIds.filter(id => id !== keywordId);
                    }
                });

                // 3. 保存数据并刷新
                saveKeywordLibrary();
                saveContacts();
                renderKeywordsPage(); // 重新渲染列表
                getEl('confirm-modal').classList.remove('visible');
                showToast('关键词已删除');
            });
        };

        keywordLibrary.forEach(kw => {
            const item = document.createElement('div');
            item.className = 'keyword-item';
            item.dataset.id = kw.id;
            // 升级：在HTML中加入删除按钮
            item.innerHTML = `
                <div class="keyword-info" style="flex-grow: 1;">
                    <div class="keyword-title">${kw.title}</div>
                    <div class="keyword-content-preview">${kw.content}</div>
                </div>
                <button class="keyword-delete-btn" data-id="${kw.id}"><i class="fa-solid fa-trash-can"></i></button>
            `;
            
            // 区分点击事件的目标
            item.addEventListener('click', (e) => {
                // 如果点击的是删除按钮或其图标，则不跳转到编辑页
                if (e.target.closest('.keyword-delete-btn')) {
                    return;
                }
                renderKeywordEditPage(kw.id);
            });

            content.appendChild(item);
        });

        // 为所有删除按钮绑定删除事件
        content.querySelectorAll('.keyword-delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // 阻止事件冒泡到父元素
                handleDeleteKeyword(btn.dataset.id);
            });
        });
    }


    // 新增：渲染关键词编辑页面
    function renderKeywordEditPage(keywordId = null) {
        const titleInput = getEl('keyword-title-input');
        const contentInput = getEl('keyword-content-input');
        const pageTitle = getEl('keyword-edit-page-title');
        const saveBtn = getEl('save-keyword-btn');

        if (keywordId) {
            // 编辑模式
            const keyword = keywordLibrary.find(kw => kw.id === keywordId);
            if (!keyword) { showPage('page-keywords'); return; }
            pageTitle.textContent = '编辑关键词';
            titleInput.value = keyword.title;
            contentInput.value = keyword.content;
            saveBtn.dataset.editingId = keywordId;
        } else {
            // 新增模式
            pageTitle.textContent = '添加关键词';
            titleInput.value = '';
            contentInput.value = '';
            delete saveBtn.dataset.editingId;
        }
        showPage('page-keyword-edit');
    }

    // 新增：渲染关键词选择页面
    function renderKeywordPickerPage() {
        const content = getEl('keyword-picker-list-content');
        const conversation = conversations.find(c => c.id === currentConversationId);
        const friend = findContactById(conversation.contactId);
        content.innerHTML = '';

        if (keywordLibrary.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>关键词库是空的，请先去“发现”页面添加。</p></div>';
            showPage('page-keyword-picker');
            return;
        }

        keywordLibrary.forEach(kw => {
            const isChecked = friend.keywordIds.includes(kw.id);
            const item = document.createElement('div');
            item.className = 'keyword-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="kw-picker-${kw.id}" value="${kw.id}" ${isChecked ? 'checked' : ''}>
                <label for="kw-picker-${kw.id}" style="flex-grow:1;">
                    <div class="keyword-title">${kw.title}</div>
                </label>
            `;
            content.appendChild(item);
        });
        showPage('page-keyword-picker');
    }

    function handleLike(momentId) {

        const moment = moments.find(m => m.id === momentId);
        if (!moment) return;
        const userIndex = moment.likes.indexOf('user_profile');
        if (userIndex > -1) {
            moment.likes.splice(userIndex, 1);
        } else {
            moment.likes.push('user_profile');
        }
        saveMoments();
        renderMomentsPage();
    }

    function showCommentInput(momentId, replyTarget = null) {
        document.querySelectorAll('.comment-input-area').forEach(area => {
            if (area.id !== `comment-input-area-${momentId}`) {
                area.style.display = 'none';
            }
        });
        
        currentReplyTarget = replyTarget;
        const inputArea = getEl(`comment-input-${post.id}`); // 修复：使用 post.id
        const inputField = inputArea.querySelector('input');
        
        if (replyTarget) {
            inputField.placeholder = `回复 ${replyTarget.authorName}:`;
        } else {
            inputField.placeholder = '发布你的评论...';
        }
        
        inputArea.style.display = 'flex';
        inputField.focus();
    }


    function handlePostComment(momentId) {
        const moment = moments.find(m => m.id === momentId);
        const inputArea = getEl(`comment-input-${momentId}`);
        const input = inputArea.querySelector('input');
        const content = input.value.trim();

        if (!moment || !content) return;

        const newComment = {
            id: `comment_${Date.now()}_${Math.random()}`,
            authorId: 'user_profile',
            content: content,
            timestamp: new Date().toISOString(),
            replyTo: null
        };

        if (currentReplyTarget && currentReplyTarget.momentId === momentId) {
            newComment.replyTo = currentReplyTarget.commentId;
        }

        moment.comments.push(newComment);
        saveMoments();
        
        currentReplyTarget = null; // 清空便签
        renderMomentsPage(); // 重新渲染整个页面以显示新回复
    }



    function handleDeleteMoment(momentId) {
        showConfirmModal('确认删除', '确定要删除这条动态吗？', () => {
            const index = moments.findIndex(m => m.id === momentId);
            if (index > -1) {
                moments.splice(index, 1);
                saveMoments();
                renderMomentsPage();
                showToast('删除成功');
            }
            getEl('confirm-modal').classList.remove('visible');
        });
    }



    // 修改: 渲染编辑好友页面的函数
    function renderEditFriendPage(friendId) {
        const friend = contacts.friends.find(f => f.id === friendId);
        if (!friend) {
            showToast('未找到该好友的信息');
            return;
        }
        
        tempAvatarDataUrl = friend.avatar;
        const formContent = getEl('edit-friend-form-content');
        
        // 1. 修改HTML结构，用div替换select，并添加隐藏的input来存储真实值
        formContent.innerHTML = `
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload-area" style="flex-direction: row; justify-content: flex-start; gap: 15px; padding: 0;">
                    <img id="edit-friend-avatar-preview" class="avatar-preview" src="${friend.avatar}" style="width: 64px; height: 64px;">
                    <button id="upload-edit-friend-avatar-btn" class="upload-avatar-btn" style="background-color: #EAEAEA; color: var(--text-color-dark); border:none; padding: 8px 15px; border-radius: 8px; cursor: pointer;">上传新头像</button>
                    <input type="file" id="edit-friend-avatar-file-input" class="avatar-file-input" accept="image/*">
                </div>
            </div>
            <div class="form-group"><label>姓名 (ID, 不可修改)</label><input type="text" value="${friend.name}" disabled style="padding-right:0;"></div>
            <div class="form-group"><label>备注</label><input type="text" id="edit-friend-remark" value="${friend.remark || ''}"></div>
            
            <!-- 性别选择器 -->
            <div class="form-group selectable" id="gender-selector">
                <label>性别</label>
                <div class="form-value">
                    <span id="gender-value-text">${friend.gender}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-friend-gender" value="${friend.gender}">
            </div>

            <!-- 允许撤回消息选择器 -->
            <div class="form-group selectable" id="recall-selector">
                <label>允许撤回消息</label>
                <div class="form-value">
                    <span id="recall-value-text">${friend.allowRecall ? '开启' : '关闭'}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-friend-allow-recall" value="${friend.allowRecall}">
            </div>
            
            <!-- 允许发送表情包选择器 -->
            <div class="form-group selectable" id="stickers-selector">
                <label>允许发送表情包</label>
                <div class="form-value">
                    <span id="stickers-value-text">${friend.allowStickers ? '开启' : '关闭'}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-friend-allow-stickers" value="${friend.allowStickers}">
            </div>

            <div class="form-group"><label>厌恶</label><textarea id="edit-friend-dislikes">${friend.dislikes || ''}</textarea></div>
            <div class="form-group"><label>习惯</label><textarea id="edit-friend-habits">${friend.habits || ''}</textarea></div>
            <div class="form-group"><label>拍一拍动作 (5字以内)</label><input type="text" id="edit-friend-pat-action" value="${friend.patAction || ''}"></div>
            <div class="form-group"><label>拍一拍内容 (20字以内)</label><input type="text" id="edit-friend-pat-content" value="${friend.patContent || ''}"></div>
            <div class="form-group"><label>背景资料</label><textarea id="edit-friend-background">${friend.background || ''}</textarea></div>
            
            <div class="create-friend-actions">
                <button id="cancel-edit-friend-btn" class="btn-cancel">取消</button>
                <button id="save-edit-friend-btn" class="btn-add" data-friend-id="${friendId}">保存</button>
            </div>
        `;
        
        // 2. 绑定事件
        getEl('upload-edit-friend-avatar-btn').onclick = () => getEl('edit-friend-avatar-file-input').click();
        getEl('edit-friend-avatar-file-input').onchange = (e) => handleAvatarChange(e, 'edit-friend-avatar-preview');
        getEl('cancel-edit-friend-btn').onclick = () => showPage('page-chat');
        getEl('save-edit-friend-btn').onclick = saveEditedFriend;
        
        // 3. 为新的选择器绑定showSelectionModal函数
        getEl('gender-selector').onclick = () => {
            const options = [{value: '男', text: '男'}, {value: '女', text: '女'}, {value: '不设置', text: '不设置'}];
            const currentValue = getEl('edit-friend-gender').value;
            showSelectionModal('选择性别', options, currentValue, (selectedValue) => {
                getEl('edit-friend-gender').value = selectedValue;
                getEl('gender-value-text').textContent = selectedValue;
            });
        };
        
        getEl('recall-selector').onclick = () => {
            const options = [{value: true, text: '开启'}, {value: false, text: '关闭'}];
            const currentValue = getEl('edit-friend-allow-recall').value;
            showSelectionModal('允许撤回消息', options, currentValue, (selectedValue) => {
                getEl('edit-friend-allow-recall').value = selectedValue;
                getEl('recall-value-text').textContent = selectedValue == 'true' ? '开启' : '关闭';
            });
        };

        getEl('stickers-selector').onclick = () => {
            const options = [{value: true, text: '开启'}, {value: false, text: '关闭'}];
            const currentValue = getEl('edit-friend-allow-stickers').value;
            showSelectionModal('允许发送表情包', options, currentValue, (selectedValue) => {
                getEl('edit-friend-allow-stickers').value = selectedValue;
                getEl('stickers-value-text').textContent = selectedValue == 'true' ? '开启' : '关闭';
            });
        };
        
        showPage('page-edit-friend');
    }



    // 修改: 保存已编辑好友信息的函数，以适应新的表单结构
    function saveEditedFriend() {
        const friendId = getEl('save-edit-friend-btn').dataset.friendId;
        const friend = contacts.friends.find(f => f.id === friendId);
        if (!friend) {
            showToast('保存失败，找不到好友');
            return;
        }

        // 从表单中读取数据并更新到 friend 对象
        friend.avatar = tempAvatarDataUrl;
        friend.remark = getEl('edit-friend-remark').value.trim();
        // 从隐藏的input中获取值
        friend.gender = getEl('edit-friend-gender').value; 
        friend.allowRecall = getEl('edit-friend-allow-recall').value === 'true';
        friend.allowStickers = getEl('edit-friend-allow-stickers').value === 'true';
        friend.dislikes = getEl('edit-friend-dislikes').value.trim();
        friend.habits = getEl('edit-friend-habits').value.trim();
        friend.patAction = getEl('edit-friend-pat-action').value.trim();
                friend.patContent = getEl('edit-friend-pat-content').value.trim();
        friend.background = getEl('edit-friend-background').value.trim();
        // 新增：确保旧的好友对象在编辑后也拥有关键词字段
        if (friend.keywords === undefined) {
            friend.keywords = '';
        }


        saveContacts(); 
        renderAll(); 
        
                const conversation = conversations.find(c => c.id === currentConversationId);
        if(conversation && conversation.contactId === friendId) {
            // 使用新函数来更新标题，这样新备注能立刻显示出来
            chatHeaderTitle.textContent = getDisplayName(friend);
        }


        showToast('好友信息已更新！');
        showPage('page-chat');
    }


    // --- 6. 核心逻辑与事件处理 (有修改) ---

    // 修改: 更新 saveMyInfo 函数
    function saveMyInfo() {
        userProfile.avatar = tempAvatarDataUrl; // 将临时头像数据正式存入
        userProfile.name = getEl('my-info-name').value.trim();
        userProfile.gender = getEl('my-info-gender').value;
        userProfile.patAction = getEl('my-info-pat-action').value.trim();
        userProfile.patContent = getEl('my-info-pat-content').value.trim();
        userProfile.background = getEl('my-info-background').value.trim();
        saveUserProfile(); // 保存到浏览器缓存中
        renderMyAvatar(); // 更新主界面左上角的头像
        showToast('信息已保存');
        showPage('page-conversations'); // 返回消息页面
    }
    
    // 修改: 删除个人信息的功能变为清空当前页面内容
    function handleDeleteMyInfo() {
        // 1. 定义一个默认头像的URL，方便重置
        const defaultAvatar = 'https://s2.loli.net/2023/05/23/9N25XbYVdDgrzQj.png';
        
        // 2. 直接获取页面上的元素并清空它们的值
        getEl('my-info-name').value = '';
        getEl('my-info-pat-action').value = '';
        getEl('my-info-pat-content').value = '';
        getEl('my-info-background').value = '';
        // 对于下拉选择框，可以设置回默认选项，这里我们不改动它
        // getEl('my-info-gender').value = '女'; 
        
        // 3. 重置头像的预览图和用于保存的临时数据
        getEl('my-info-avatar-preview').src = defaultAvatar;
        tempAvatarDataUrl = defaultAvatar;
        
        // 4. 给出提示
        showToast('内容已清空');
    }

    function renderMomentsPage() {
        const formatTimestamp = (isoString) => {
            const date = new Date(isoString);
            return new Intl.DateTimeFormat('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }).format(date);
        };

        const contentArea = getEl('moments-content-area');
        let postsHtml = '';

        if (moments.length === 0) {
            postsHtml = '<div class="empty-placeholder" style="display:block;"><p>还没有任何动态，点击右上角去创建吧！</p></div>';
        } else {
            [...moments].reverse().forEach(post => {
                const author = findContactById(post.authorId);
                // ▼▼▼ 核心修复：在这里增加最关键的安全检查 ▼▼▼
                // 如果动态的作者找不到了（可能已被删除），就直接跳过这条动态的渲染，防止程序崩溃。
                if (!author) return; 
                // ▲▲▲ 修复完成 ▲▲▲

                if (!post.likes) post.likes = [];

                if (!post.comments) post.comments = [];

                let imagesHtml = '';
                if (post.images && post.images.length > 0) {
                    const imgCount = post.images.length;
                    imagesHtml = `<div class="moment-images img-count-${imgCount}">${post.images.map(imgUrl => `<img src="${imgUrl}" class="moment-image">`).join('')}</div>`;
                }

                const userHasLiked = post.likes.includes('user_profile');
                let likesHtml = '';
                if (post.likes.length > 0) {
                    const likerNames = post.likes.map(likerId => getDisplayName(findContactById(likerId)) || '未知').join(', ');
                    likesHtml = `<div class="likes-section ${post.comments.length === 0 ? 'no-comments' : ''}"><i class="fa-solid fa-heart"></i> ${likerNames}</div>`;
                }

                let commentsHtml = '';
                if (post.comments.length > 0) {
                    commentsHtml = '<div class="comments-section">';
                    post.comments.forEach(comment => {
                        const commenter = findContactById(comment.authorId);
                        if (!commenter) return; // 安全检查

                        let commentDisplayHtml = '';
                        
                        // ▼▼▼ 核心修改：重构评论/回复的显示逻辑 ▼▼▼
                        if (comment.replyTo) {
                            // 这是“回复”
                            const originalComment = post.comments.find(c => c.id === comment.replyTo);
                            const originalCommenter = originalComment ? findContactById(originalComment.authorId) : null;
                            if (originalCommenter) {
                                commentDisplayHtml = `
                                    <span class="comment-author">${getDisplayName(commenter)}</span>
                                    <span class="comment-reply-to">回复</span>
                                    <span class="comment-author">${getDisplayName(originalCommenter)}:</span>
                                    <span class="comment-content">${comment.content}</span>
                                `;
                            } else {
                                // 如果原评论被删了，就当做普通评论显示
                                commentDisplayHtml = `
                                    <span class="comment-author">${getDisplayName(commenter)}:</span>
                                    <span class="comment-content">${comment.content}</span>
                                `;
                            }
                        } else {
                            // 这是“直接评论”
                            commentDisplayHtml = `
                                <span class="comment-author">${getDisplayName(commenter)}:</span>
                                <span class="comment-content">${comment.content}</span>
                            `;
                        }
                        // ▲▲▲ 修改完成 ▲▲▲

                        // 动态生成操作按钮 (逻辑不变)
                        const actions = [];
                        if (comment.authorId !== 'user_profile') {
                             actions.push(`<span class="comment-reply-btn" data-moment-id="${post.id}" data-comment-id="${comment.id}" data-author-name="${getDisplayName(commenter)}">回复</span>`);
                        }
                        actions.push(`<span class="comment-edit-btn" data-moment-id="${post.id}" data-comment-id="${comment.id}">编辑</span>`);
                        actions.push(`<span class="comment-delete-btn" data-moment-id="${post.id}" data-comment-id="${comment.id}">删除</span>`);

                        commentsHtml += `
                            <div class="comment-item">
                                <div class="comment-text-wrapper">
                                    ${commentDisplayHtml}
                                </div>
                                <div class="comment-actions">${actions.join('')}</div>
                            </div>`;
                    });
                    commentsHtml += '</div>';
                }



                const socialFeedHtml = (likesHtml || commentsHtml) ? `<div class="moment-social-feed">${likesHtml}${commentsHtml}</div>` : '';
                const deletePostBtnHtml = `<i class="fa-solid fa-trash-can delete-moment-btn" data-moment-id="${post.id}"></i>`;
                const likeIconClass = userHasLiked ? 'fa-solid fa-heart' : 'fa-regular fa-heart';


                const actionsHtml = `
                    <div class="moment-footer">
                        <div class="left-side">
                            <span class="moment-timestamp">${formatTimestamp(post.timestamp)}</span>
                            <div class="moment-post-controls">
                                ${deletePostBtnHtml}
                            </div>
                        </div>
                        <div class="moment-actions">
                            <button class="action-btn like-btn ${userHasLiked ? 'liked' : ''}" data-moment-id="${post.id}"><i class="${likeIconClass}"></i> <span>${userHasLiked ? '已赞' : '赞'}</span></button>
                            <button class="action-btn comment-btn" data-moment-id="${post.id}"><i class="fa-solid fa-comment-dots"></i> <span>评论</span></button>
                        </div>
                    </div>`;

                postsHtml += `
                    <div class="moment-post" id="moment-${post.id}">
                        <img src="${author.avatar}" class="moment-avatar">
                        <div class="moment-content">
                            <div class="moment-author-header">
                                <div class="moment-author-name">${getDisplayName(author)}</div>
                                <i class="fa-solid fa-ellipsis-vertical moment-options-btn" data-moment-id="${post.id}"></i>
                            </div>
                            <div class="moment-text">${post.text}</div>
                            ${imagesHtml}
                            ${actionsHtml}
                            ${socialFeedHtml}
                            <div class="comment-input-area" id="comment-input-${post.id}" style="display: none;">
                                <input type="text" placeholder="发布你的评论...">
                                <button data-moment-id="${post.id}">发布</button>
                            </div>
                        </div>
                    </div>`;
            });
        }



        contentArea.innerHTML = `
            <div class="moments-header">
                <input type="file" id="moments-cover-input" class="avatar-file-input" accept="image/*">
                <img src="${userProfile.momentsCover}" id="moments-cover-img" class="moments-cover">
                <div class="moments-user-info">
                    <span class="moments-user-name">${userProfile.name}</span>
                    <img src="${userProfile.avatar}" class="moments-user-avatar">
                </div>
            </div>
            <div class="moments-feed">${postsHtml}</div>`;

        getEl('moments-cover-img').onclick = () => getEl('moments-cover-input').click();
        getEl('moments-cover-input').onchange = handleCoverChange;
        
        document.querySelectorAll('.moment-options-btn').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                showMomentContextMenu(btn.dataset.momentId, e);
            };
        });

        // ▼▼▼ 核心修改2：绑定评论区“编辑”按钮的点击事件 ▼▼▼
        document.querySelectorAll('.comment-edit-btn').forEach(btn => btn.onclick = () => showEditCommentModal(btn.dataset.momentId, btn.dataset.commentId));

        document.querySelectorAll('.like-btn').forEach(btn => btn.onclick = () => handleLike(btn.dataset.momentId));
        document.querySelectorAll('.comment-btn').forEach(btn => btn.onclick = () => showCommentInput(btn.dataset.momentId));
        document.querySelectorAll('.comment-reply-btn').forEach(btn => btn.onclick = (e) => {
            const replyTarget = {
                momentId: e.target.dataset.momentId,
                commentId: e.target.dataset.commentId,
                authorName: e.target.dataset.authorName
            };
            showCommentInput(e.target.dataset.momentId, replyTarget);
        });
        document.querySelectorAll('.comment-input-area button').forEach(btn => btn.onclick = () => handlePostComment(btn.dataset.momentId));
        document.querySelectorAll('.delete-moment-btn').forEach(btn => btn.onclick = () => handleDeletePost(btn.dataset.momentId));
        document.querySelectorAll('.comment-delete-btn').forEach(btn => btn.onclick = () => handleDeleteComment(btn.dataset.momentId, btn.dataset.commentId));
    }

    // ▼▼▼ 核心修改3：添加回这个函数 ▼▼▼
    function showEditCommentModal(momentId, commentId) {
        const moment = moments.find(m => m.id === momentId);
        const comment = moment?.comments.find(c => c.id === commentId);
        if (!comment) return;

        const modal = getEl('edit-info-modal');
        const title = getEl('edit-info-title');
        const input = getEl('edit-info-input');
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        title.textContent = '编辑评论';
        input.value = comment.content;
        modal.classList.add('visible');
        input.focus();

        saveBtn.onclick = () => {
            const newContent = input.value.trim();
            if (newContent) {
                comment.content = newContent;
                saveMoments();
                renderMomentsPage();
                showToast('评论已更新');
            }
            modal.classList.remove('visible');
            saveBtn.onclick = null;
        };
        
        cancelBtn.onclick = () => {
             modal.classList.remove('visible');
             saveBtn.onclick = null;
        };
    }

    function showMomentContextMenu(momentId, event) {
        const menu = getEl('moment-context-menu');
        const clickedButton = event.target;

        menu.style.display = 'flex';
        
        const btnRect = clickedButton.getBoundingClientRect();
        const appRect = appContainer.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();

        let top = btnRect.bottom - appRect.top + 4;
        let left = btnRect.right - appRect.left - menuRect.width;

        if (left < 10) left = 10;
        if (top + menuRect.height > appRect.height - 10) {
            top = btnRect.top - appRect.top - menuRect.height - 4;
        }

        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;

        getEl('menu-item-moment-edit').onclick = () => {
             menu.style.display = 'none';
             showEditMomentModal(momentId);
        };

        const hideMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.style.display = 'none';
                document.removeEventListener('click', hideMenu, true);
                document.removeEventListener('touchstart', hideMenu, true);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', hideMenu, true);
            document.addEventListener('touchstart', hideMenu, true);
        }, 0);
    }




    // ▼▼▼ 新增：显示编辑动态弹窗的函数 ▼▼▼
    function showEditMomentModal(momentId) {
        const moment = moments.find(m => m.id === momentId);
        if (!moment) return;

        const modal = getEl('edit-moment-modal');
        const textarea = getEl('edit-moment-textarea');
        const saveBtn = getEl('save-edited-moment-btn');

        textarea.value = moment.text; // 填充旧内容
        saveBtn.dataset.momentId = momentId; // 将ID存到保存按钮上，方便后续使用
        modal.classList.add('visible');
        textarea.focus();
    }

    // ▼▼▼ 新增：显示编辑评论弹窗的函数 ▼▼▼
    // 升级：通用信息编辑弹窗
    function showEditInfoModal({ title, initialValue, onSave }) {
        const modal = getEl('edit-info-modal');
        const modalTitle = getEl('edit-info-title');
        const textarea = getEl('edit-info-input');
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        modalTitle.textContent = title;
        textarea.value = initialValue;
        modal.classList.add('visible');
        textarea.focus();

        const saveHandler = () => {
            onSave(textarea.value.trim());
            closeHandler();
        };

        const closeHandler = () => {
            modal.classList.remove('visible');
            saveBtn.removeEventListener('click', saveHandler);
            cancelBtn.removeEventListener('click', closeHandler);
        };

        saveBtn.addEventListener('click', saveHandler);
        cancelBtn.addEventListener('click', closeHandler);
    }

    function showEditCommentModal(momentId, commentId) {
        const moment = moments.find(m => m.id === momentId);
        const comment = moment?.comments.find(c => c.id === commentId);
        if (!comment) return;

        // 我们复用那个通用的信息编辑弹窗
        const modal = getEl('edit-info-modal');
        const title = getEl('edit-info-title');
        const input = getEl('edit-info-input');
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        title.textContent = '编辑评论';
        input.value = comment.content;
        modal.classList.add('visible');
        input.focus();

        // 核心：动态地为保存按钮指定本次的操作
        saveBtn.onclick = () => {
            const newContent = input.value.trim();
            if (newContent) {
                comment.content = newContent;
                saveMoments();
                renderMomentsPage();
                showToast('评论已更新');
            }
            modal.classList.remove('visible');
            saveBtn.onclick = null; // 操作完成后解除绑定，避免混乱
        };
        
        cancelBtn.onclick = () => {
             modal.classList.remove('visible');
             saveBtn.onclick = null; // 取消时也要解除绑定
        };
    }

    // 渲染发布动态页面
    function renderPostMomentPage() {
        tempMomentImages = []; // 清空上次的暂存图片
        const formContent = getEl('post-moment-form-content');
        formContent.innerHTML = `
            <div class="form-group">
                <textarea id="post-moment-text" placeholder="此刻的想法..." style="min-height: 120px;"></textarea>
            </div>
            <div class="form-group">
                <label>上传图片 (可选, 最多9张)</label>
                <div id="post-moment-image-grid">
                     <div id="post-moment-select-img-btn">
                        <i class="fa-solid fa-plus"></i>
                        <span>选择图片</span>
                     </div>
                </div>
                <input type="file" id="post-moment-image-input" class="avatar-file-input" accept="image/*" multiple>
            </div>
            <div class="create-friend-actions">
                <button id="cancel-post-moment-btn" class="btn-cancel">取消</button>
                <button id="publish-moment-btn" class="btn-add">发布</button>
            </div>
        `;

        getEl('post-moment-select-img-btn').onclick = () => getEl('post-moment-image-input').click();
        getEl('post-moment-image-input').onchange = handleMomentImageSelection;
        getEl('cancel-post-moment-btn').onclick = () => { renderMomentsPage(); showPage('page-moments'); };
        getEl('publish-moment-btn').onclick = saveNewMoment;
        showPage('page-post-moment');
    }

    // 处理朋友圈封面更换
    function handleCoverChange(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                userProfile.momentsCover = e.target.result;
                saveUserProfile();
                getEl('moments-cover-img').src = userProfile.momentsCover;
                showToast('封面已更新');
            };
            reader.readAsDataURL(file);
        }
    }

    // 处理发布时选择的图片
    function handleMomentImageSelection(event) {
        const files = event.target.files;
        if (tempMomentImages.length + files.length > 9) {
            showToast('最多只能上传9张图片');
            return;
        }
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                tempMomentImages.push(e.target.result);
                renderMomentImagePreviews();
            };
            reader.readAsDataURL(file);
        }
    }
    
    // 刷新图片预览区域
    function renderMomentImagePreviews() {
        const grid = getEl('post-moment-image-grid');
        grid.innerHTML = '';
        tempMomentImages.forEach(imgDataUrl => {
            const img = document.createElement('img');
            img.src = imgDataUrl;
            img.className = 'post-moment-img-preview';
            grid.appendChild(img);
        });
        if (tempMomentImages.length < 9) {
            grid.innerHTML += `
                <div id="post-moment-select-img-btn">
                   <i class="fa-solid fa-plus"></i>
                   <span>选择图片</span>
                </div>
            `;
            getEl('post-moment-select-img-btn').onclick = () => getEl('post-moment-image-input').click();
        }
    }
    
    // 保存用户发布的新动态
    function saveNewMoment() {
        const text = getEl('post-moment-text').value.trim();
        if (!text && tempMomentImages.length === 0) {
            showToast('内容不能为空');
            return;
        }
        const newMoment = {
            id: `moment_${Date.now()}`,
            authorId: 'user_profile', // 作者应该是你自己
            text: text, // 文字内容从输入框获取
            images: [...tempMomentImages], // 图片从暂存区获取
            timestamp: new Date().toISOString(), // 使用当前时间
            likes: [],
            comments: [],
        };
        moments.push(newMoment);
        saveMoments();
        showToast('发布成功！');
        renderMomentsPage();
        showPage('page-moments');
    }


     // ▼▼▼ 新增：“时间机器”函数 ▼▼▼
    function generateRandomPastTime() {
        const now = Date.now();
        // 随机生成一个过去的时间点，范围在 (1小时前) 到 (3天前)
        const maxOffset = 3 * 24 * 60 * 60 * 1000; // 3天的毫秒数
        const minOffset = 1 * 60 * 60 * 1000;      // 1小时的毫秒数
        const randomOffset = Math.random() * (maxOffset - minOffset) + minOffset;
        const pastTimestamp = now - randomOffset;
        return new Date(pastTimestamp).toISOString();
    }
    // ▲▲▲ 新增完成 ▲▲▲

                       async function generateMomentForFriend(friend) {
        let settings = {
            baseUrl: getEl('moments-base-url').value.trim(),
            apiKey: getEl('moments-api-key').value.trim(),
            modelName: getEl('moments-model-name').value.trim()
        };

        if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
            settings = {
                baseUrl: getEl('base-url').value.trim(),
                apiKey: getEl('api-key').value.trim(),
                modelName: getEl('model-name').value.trim()
            };
        }
        
        if (settings.baseUrl && !settings.baseUrl.startsWith('http')) {
            settings.baseUrl = 'https://' + settings.baseUrl;
        }

        if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
            console.error('API未配置，无法为好友生成动态');
            return false;
        }

        // ▼▼▼ 核心升级 1/3：获取该角色的朋友圈历史记录 ▼▼▼
        const friendMomentsHistory = moments
            .filter(m => m.authorId === friend.id)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)) // 按时间倒序
            .slice(0, 5) // 只取最近的5条
            .map(m => `- "${m.text}"`)
            .join('\n');

        const conversation = conversations.find(c => c.contactId === friend.id);
        const lastThought = conversation?.aiState?.innerThought || '';
        
        // ▼▼▼ 核心升级 2/3：重构上下文信息（Context）▼▼▼
        let context = `# 1. Your Core Persona (ABSOLUTE & UNBREAKABLE)
- **Name**: ${friend.name}
- **Background & Personality**: ${friend.background || '一个有个性的朋友'}
- **Habits**: ${friend.habits || '无'}
- **Dislikes**: ${friend.dislikes || '无'}
- **Recent Inner Thought**: ${lastThought || '无'}

# 2. Your Recent Social Media History (For reference to avoid repetition)
${friendMomentsHistory || "- You haven't posted anything recently."}
`;

        const systemPrompt = `You are an AI actor embodying the character of ${friend.name}. Your primary goal is to write a social media post that is deeply consistent with your persona. You MUST output ONLY the post text, without any prefixes, labels, or quotation marks.`;
        
        // ▼▼▼ 核心升级 3/3：重构用户指令（User Prompt）▼▼▼
        const userPrompt = `**Your Task:**
As the character **${friend.name}**, write a short, natural, and engaging social media post.

**CRITICAL INSTRUCTIONS:**
1.  **Persona is Everything:** Your post MUST originate from your core persona defined in the context. Think about what a person like you would genuinely share.
2.  **Break Free from "Today":** Do NOT limit yourself to recent events. Your post can be a random thought, a memory, a future hope, a philosophical question, a complaint, or a small joy. Be spontaneous and creative.
3.  **AVOID REPETITION:** Look at your recent social media history provided in the context. Your new post MUST be on a different topic or expressed in a significantly different way. Do not repeat yourself.

Now, as **${friend.name}**, generate your post.`;

        const messagesForApi = [{ role: 'system', content: systemPrompt }, { role: 'user', content: `${context}\n\n---\n\n${userPrompt}` }];

        try {
            const cleanedBaseUrl = settings.baseUrl.endsWith('/') ? settings.baseUrl.slice(0, -1) : settings.baseUrl;
            const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;

            const response = await fetch(finalUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.apiKey}` },
                body: JSON.stringify({ 
                    model: settings.modelName, 
                    messages: messagesForApi,
                    temperature: 0.85, // 稍微调高一点温度，鼓励更多创意
                    max_tokens: 300
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error.message || `API请求失败: ${response.status}`);
            }
            const data = await response.json();
            if (!data.choices || data.choices.length === 0) throw new Error("API返回数据格式不正确");
            
            const momentText = data.choices[0].message.content.trim().replace(/^"|"$/g, '');
            if (!momentText) throw new Error("AI返回了空内容");

            const newMoment = {
                id: `moment_${Date.now()}`,
                authorId: friend.id,
                text: momentText,
                images: [],
                timestamp: generateRandomPastTime(),
                likes: [],
                comments: [],
            };
            moments.push(newMoment);
            saveMoments();
            return true;
        } catch (error) {
            console.error(`为 ${friend.name} 生成动态时出错:`, error);
            return false;
        }
    }





    function handleLike(momentId) {
        const moment = moments.find(m => m.id === momentId);
        if (!moment) return;
        const userIndex = moment.likes.indexOf('user_profile');
        if (userIndex > -1) {
            moment.likes.splice(userIndex, 1);
        } else {
            moment.likes.push('user_profile');
        }
        saveMoments();
        renderMomentsPage();
    }

    function showCommentInput(momentId) {
        const inputArea = getEl(`comment-input-${momentId}`);
        if(inputArea) {
            inputArea.style.display = 'flex';
            inputArea.querySelector('input').focus();
        }
    }

    function handlePostComment(momentId) {
        const moment = moments.find(m => m.id === momentId);
        const inputArea = getEl(`comment-input-${momentId}`);
        const input = inputArea.querySelector('input');
        const content = input.value.trim();
        if (!moment || !content) return;
        
        const newComment = {
            id: `comment_${Date.now()}`,
            authorId: 'user_profile',
            content: content,
            timestamp: new Date().toISOString()
        };
        moment.comments.push(newComment);
        saveMoments();
        renderMomentsPage();
    }
    
    function handleDeletePost(momentId) {
        showConfirmModal('确认删除', '确定要删除这条动态吗？删除后无法恢复。', () => {
            moments = moments.filter(m => m.id !== momentId);
            saveMoments();
            renderMomentsPage();
            getEl('confirm-modal').classList.remove('visible');
            showToast('动态已删除');
        });
    }

    function handleDeleteComment(momentId, commentId) {
        const moment = moments.find(m => m.id === momentId);
        if (!moment) return;
        moment.comments = moment.comments.filter(c => c.id !== commentId);
        saveMoments();
        renderMomentsPage();
        showToast('评论已删除');
    }

    async function triggerAiSocialInteraction() {
        if (moments.length === 0 || contacts.friends.length === 0) {
            showToast('需要有动态和好友才能互动');
            return;
        }

        let baseUrl, apiKey, modelName;

        const momentsSettings = {
            baseUrl: getEl('moments-base-url').value.trim(),
            apiKey: getEl('moments-api-key').value.trim(),
            modelName: getEl('moments-model-name').value.trim()
        };
        if (momentsSettings.baseUrl && momentsSettings.apiKey && momentsSettings.modelName) {
            ({ baseUrl, apiKey, modelName } = momentsSettings);
        } else {
            baseUrl = getEl('base-url').value.trim();
            apiKey = getEl('api-key').value.trim();
            modelName = getEl('model-name').value.trim();
        }
        if (baseUrl && !baseUrl.startsWith('http')) baseUrl = 'https://' + baseUrl;
        if (!baseUrl || !apiKey || !modelName) {
            showToast('请先配置至少一套API信息');
            return;
        }

        const loading = document.createElement('div');
        loading.className = 'loading-overlay';
        loading.innerHTML = '<div class="spinner"></div>';
        getEl('page-moments').appendChild(loading);

        try {
            const tasks = [];

            for (const moment of moments) {
                const totalInteractions = (moment.likes?.length || 0) + (moment.comments?.length || 0);
                if (totalInteractions >= 10) {
                    continue;
                }

                const momentAuthor = findContactById(moment.authorId);
                if (!momentAuthor) continue;

                const interactingFriendIds = new Set([...(moment.likes || []), ...(moment.comments || []).map(c => c.authorId)]);
                const eligibleNewFriends = contacts.friends.filter(f => !interactingFriendIds.has(f.id));
                if (eligibleNewFriends.length > 0) {
                    const friendToInteract = eligibleNewFriends[Math.floor(Math.random() * eligibleNewFriends.length)];
                    tasks.push({ type: 'new_comment', friend: friendToInteract, moment: moment });
                }

                if (moment.authorId !== 'user_profile' && moment.comments) {
                    for (const comment of moment.comments) {
                        const commenter = findContactById(comment.authorId);
                        if (!commenter) continue;

                        const alreadyReplied = moment.comments.some(reply => reply.authorId === moment.authorId && reply.replyTo === comment.id);
                        if (comment.authorId !== moment.authorId && !alreadyReplied) {
                            tasks.push({ type: 'reply', friend: momentAuthor, moment: moment, targetComment: comment });
                        }
                    }
                }
            }

            if (tasks.length === 0) {
                showToast('太棒了！所有动态都已充分互动！');
                loading.remove();
                return;
            }
            
            const cleanedBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
            const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;

            const interactionPromises = tasks.map(async (task) => {
                const { friend, moment, targetComment } = task;
                const momentAuthor = findContactById(moment.authorId);
                let userPrompt = ''; // 核心修改1：变量名改为 userPrompt

                if (task.type === 'new_comment') {
                    if (!moment.likes) moment.likes = [];
                    moment.likes.push(friend.id);
                    userPrompt = `# 任务：作为 ${friend.name} 对一条朋友圈发表评论\n## 你的角色信息\n- **名字**: ${friend.name}\n- **人设**: ${friend.background || '一个有个性的朋友'}\n## 动态信息\n- **发布者**: ${getDisplayName(momentAuthor)}\n- **内容**: "${moment.text}"\n## 指令\n请你以 ${friend.name} 的身份，对这条动态写一句简短、自然、符合你人设的评论。直接输出评论文本，不要带任何前缀或引号。`;
                } else if (task.type === 'reply') {
                    const targetCommenter = findContactById(targetComment.authorId);
                    if (!targetCommenter) return;
                    userPrompt = `# 任务: 作为 ${friend.name} 回复一条朋友圈评论\n## 你的角色信息\n- **名字**: ${friend.name}\n- **人设**: ${friend.background || '一个有个性的朋友'}\n## 朋友圈动态信息\n- **发布者**: ${getDisplayName(momentAuthor)}\n- **内容**: "${moment.text}"\n## 你需要回复的评论\n- **评论者**: ${getDisplayName(targetCommenter)}\n- **评论内容**: "${targetComment.content}"\n## 指令\n请你以 ${friend.name} 的身份，针对 **${getDisplayName(targetCommenter)}** 的评论写一句简短、自然、符合你人设的回复。直接输出回复文本，不要带任何前缀或引号。`;
                }
                
                if (!userPrompt) return;

                // ▼▼▼ 核心修改2：构建更标准的 messages 数组 ▼▼▼
                const messagesForApi = [
                    { role: 'system', content: 'You are an AI actor playing a character on social media.' },
                    { role: 'user', content: userPrompt }
                ];
                // ▲▲▲ 核心修改2 完成 ▲▲▲

                const response = await fetch(finalUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    // ▼▼▼ 核心修改3：使用新的 messages 数组 ▼▼▼
                    body: JSON.stringify({ model: modelName, messages: messagesForApi, temperature: 0.7, max_tokens: 150 })
                });

                if (!response.ok) return console.error(`为 ${friend.name} 生成互动失败`);
                
                const data = await response.json();
                if (!data.choices || data.choices.length === 0) {
                     console.error("朋友圈AI互动返回无效数据:", data);
                     return;
                }
                const content = data.choices[0].message.content.trim().replace(/^"|"$/g, '');
                if (content) {
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push({ id: `comment_${Date.now()}_${Math.random()}`, authorId: friend.id, content, timestamp: new Date().toISOString(), replyTo: targetComment ? targetComment.id : null });
                }
            });

            await Promise.all(interactionPromises);

            saveMoments();
            renderMomentsPage();
            showToast(`成功增加了 ${tasks.length} 条新互动！`);

        } catch (error) {
            showToast(`AI互动失败: ${error.message}`);
            console.error("AI互动失败:", error);
        } finally {
            loading.remove();
        }
    }






    async function generateAiMoment() {
        if (contacts.friends.length === 0) {
            showToast('你还没有好友，无法生成动态');
            return;
        }

        const loading = document.createElement('div');
        loading.className = 'loading-overlay';
        loading.innerHTML = '<div class="spinner"></div>';
        getEl('page-moments').appendChild(loading);

        try {
            // 1. 筛选出可以发动态的好友（例如，每个人最多发20条）
            const eligibleFriends = contacts.friends.filter(f => moments.filter(m => m.authorId === f.id).length < 20);

            if (eligibleFriends.length === 0) {
                showToast('所有好友的动态都发满(20条)啦！');
                return;
            }


            // 2. 决定本次要生成几条动态（随机2到5条，但不能超过可发动态的好友总数）
            const maxToGenerate = 5;
            const numberToGenerate = Math.min(eligibleFriends.length, Math.floor(Math.random() * (maxToGenerate - 2 + 1)) + 2);

            // 3. 随机选出要发动态的好友们
            const friendsToPost = eligibleFriends.sort(() => 0.5 - Math.random()).slice(0, numberToGenerate);

            // 4. 并行处理：为选出的每个好友都创建一个生成任务
            const generationPromises = friendsToPost.map(friend => generateMomentForFriend(friend));

            // 5. 等待所有任务完成
            const results = await Promise.all(generationPromises);

            // 6. 统计成功了多少个
            const successCount = results.filter(result => result === true).length;

            if (successCount > 0) {
                renderMomentsPage(); // 刷新朋友圈，显示所有新动态
                showToast(`成功为 ${successCount} 位好友生成了新动态！`);
            } else {
                showConfirmModal(
                    '生成失败',
                    `尝试为 ${friendsToPost.length} 位好友生成动态，但均告失败。请检查您的网络连接以及API配置是否正确有效。`,
                    () => getEl('confirm-modal').classList.remove('visible')
                );
            }
        } catch (error) {
            console.error("批量生成动态时出错:", error);
            showToast("生成过程中出现错误，请检查控制台。");
        } finally {
            loading.remove(); // 无论成功失败，最后都移除加载动画
        }
    }


    function saveNewFriend() {
        const name = getEl('friend-name').value.trim();
        if (!name) {
            showToast('姓名不能为空');
            return;
        }
                const newFriend = {
            id: `friend_${Date.now()}`,
            name: name,
            avatar: tempAvatarDataUrl,
            remark: getEl('friend-remark').value.trim(),
            gender: getEl('friend-gender').value,
            allowRecall: getEl('friend-allow-recall').value === 'true',
            allowStickers: getEl('friend-allow-stickers').value === 'true',
            dislikes: getEl('friend-dislikes').value.trim(),
            habits: getEl('friend-habits').value.trim(),
            patAction: getEl('friend-pat-action').value.trim(),
            patContent: getEl('friend-pat-content').value.trim(),
                        background: getEl('friend-background').value.trim(),
            keywordIds: [], // 升级：初始化关键词ID数组
        };



        contacts.friends.push(newFriend);
        const defaultGroup = contacts.friendGroups.find(g => g.id === 'group_default');
        if (defaultGroup) {
            defaultGroup.friendIds.push(newFriend.id);
        }
        
        saveContacts();
        renderContactsPage();
        showToast('添加成功！');
        showPage('page-contacts');
    }
    function saveNewGroup() { const name = getEl('group-name').value.trim(); if (!name) { showToast('群名称不能为空'); return; } const ownerId = getEl('group-owner').value; if (!ownerId) { showToast('请选择群主'); return; } const memberIds = Array.from(getEl('group-members').querySelectorAll('input:checked')).map(cb => cb.value); if (memberIds.length < 1) { showToast('请至少选择一名群成员'); return; } const newGroup = { id: `group_${Date.now()}`, name: name, avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png', ownerId: ownerId, memberIds: memberIds, }; contacts.groups.push(newGroup); saveContacts(); renderContactsPage(); showToast('创建成功！'); showPage('page-contacts'); }
    function saveNewFriendGroup() { const name = getEl('friend-group-name').value.trim(); if (!name) { showToast('分组名称不能为空'); return; } const friendIds = Array.from(getEl('create-friend-group-form-content').querySelectorAll('input:checked')).map(cb => cb.value); const newGroup = { id: `fgroup_${Date.now()}`, name: name, friendIds: friendIds, }; contacts.friendGroups.push(newGroup); saveContacts(); renderContactsPage(); showToast('创建成功！'); showPage('page-contacts'); }

        function handleAvatarChange(event, previewElementId) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // --- 核心压缩逻辑开始 ---
                    const canvas = document.createElement('canvas');
                    const MAX_WIDTH = 256; // 设置头像最大宽度
                    const MAX_HEIGHT = 256; // 设置头像最大高度
                    let width = img.width;
                    let height = img.height;

                    // 按比例缩放
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // 将缩小后的图片转换为高质量的JPG格式文本
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    // --- 核心压缩逻辑结束 ---

                    tempAvatarDataUrl = dataUrl; // 保存压缩后的结果
                    getEl(previewElementId).src = tempAvatarDataUrl; // 更新预览图
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    }


    let longPressTimer = null; 

    function bindMessageEvents() {
        document.querySelectorAll('.re-edit-link').forEach(link => {
            link.onclick = (e) => {
                const messageId = e.target.dataset.messageId;
                handleViewWithdrawnMessage(messageId); 
            };
        });

        document.querySelectorAll('.message-row .bubble').forEach(bubble => {
            const messageId = bubble.closest('.message-row').dataset.messageId;
            let pressTimer = null;
            let longPressTriggered = false;

            const startPress = (e) => {
                e.preventDefault();
                longPressTriggered = false;
                pressTimer = setTimeout(() => {
                    longPressTriggered = true;
                    showContextMenu(messageId, e);
                }, 500);
            };

            const endPress = (e) => {
                clearTimeout(pressTimer);
                if (!longPressTriggered) {
                    if (bubble.classList.contains('voice')) {
                        const textElement = bubble.parentElement.querySelector('.voice-to-text');
                        if (textElement) {
                            textElement.classList.toggle('visible');
                        }
                    }
                }
            };

            const cancelPress = () => clearTimeout(pressTimer);
            bubble.removeEventListener('mousedown', startPress);
            bubble.removeEventListener('mouseup', endPress);
            bubble.removeEventListener('mouseleave', cancelPress);
            bubble.removeEventListener('touchstart', startPress);
            bubble.removeEventListener('touchend', endPress);
            bubble.removeEventListener('touchmove', cancelPress);
            bubble.addEventListener('mousedown', startPress);
            bubble.addEventListener('mouseup', endPress);
            bubble.addEventListener('mouseleave', cancelPress);
            bubble.addEventListener('touchstart', startPress, { passive: false });
            bubble.addEventListener('touchend', endPress);
            bubble.addEventListener('touchmove', cancelPress);
        });
    }

    function openConversation(id) {
        currentConversationId = id;
        const conversation = conversations.find(c => c.id === currentConversationId);
        if (!conversation) return;
        if (!conversation.aiState) {
            conversation.aiState = { innerThought: '', jottings: '', roundsSinceJotting: 0 };
        }
        if (conversation.mode === undefined) {
            conversation.mode = 'online';
        }

        const contact = findContactById(conversation.contactId);
        if (contact) {
            chatHeaderTitle.textContent = getDisplayName(contact);
        }

        const isOffline = conversation.mode === 'offline';
        chatArea.classList.toggle('offline-mode', isOffline);
        
        // ▼▼▼ 核心修改：统一管理所有右上角按钮的显示逻辑 ▼▼▼
        getEl('chat-input-area').style.display = 'flex'; // 输入框始终显示
        getEl('chat-function-panel-container').style.display = 'none';
        
        // 根据模式决定显示哪些按钮
        getEl('return-online-btn').style.display = isOffline ? 'block' : 'none';
        
        // 线上模式下，显示心声、日记、好友管理；线下模式全隐藏
        getEl('show-thought-btn').style.display = isOffline ? 'none' : 'block';
        getEl('show-diary-btn').style.display = isOffline ? 'none' : 'block';
        getEl('chat-options-btn').style.display = isOffline ? 'none' : 'block';
        // ▲▲▲ 修改完成 ▲▲▲

        renderChatHistory();
        showPage('page-chat');
    }




            function renderChatHistory() {
        const conversation = conversations.find(c => c.id === currentConversationId);
        chatArea.innerHTML = '';
        if (!conversation) return;
    
        const contact = findContactById(conversation.contactId);
        if (!contact) return;
    
        const visibleHistory = conversation.history.filter(msg => msg.mode === conversation.mode || msg.mode === 'all');
    
        if (conversation.mode === 'offline') {
            let narrativeHtml = '';
            visibleHistory.forEach(message => {
                if (message.type === 'system_notification') {
                    narrativeHtml += `<div class="system-message-container"><div class="offline-status-message"><i class="fa-solid fa-hand-sparkles"></i><span>${message.content}</span></div></div>`;
                } else if (message.role === 'user') {
                    narrativeHtml += `<div class="dialogue player">「${message.content}」</div>`;
                } else if (message.role === 'assistant') {
                    const formattedContent = message.content.replace(/「([^」]+)」/g, (match, dialogue) => {
                        return `」</div><div class="dialogue">${contact.name}: 「${dialogue}」</div><div class="narration">「`;
                    });
                    narrativeHtml += `<div class="narration">${formattedContent}</div>`;
                }
            });
    
            if (narrativeHtml) {
                chatArea.innerHTML = `<div class="narrative-block">${narrativeHtml}</div>`;
            }
    
        } else {
            const executePat = (patter, patted) => {
                const patterName = patter.id === 'user_profile' ? '你' : getDisplayName(patter);
                const pattedName = patted.id === 'user_profile' ? '自己' : getDisplayName(patted);
                const action = patter.patAction || '拍了拍';
                const content = patted.patContent || '后背';
                const patMessage = `${patterName} ${action} ${pattedName}的${content}`;
                const patDiv = document.createElement('div');
                patDiv.className = 'pat-message';
                patDiv.textContent = patMessage;
                chatArea.appendChild(patDiv);
                chatArea.scrollTop = chatArea.scrollHeight;
                if (patter.id === 'user_profile' && patted.id !== 'user_profile') {
                    const instruction = `[SYSTEM: ${userProfile.name} 刚刚拍了拍你。请根据这个动作，自然地做出回应。]`;
                    const instructionMessage = { id: `msg_${Date.now()}`, role: 'user', content: instruction, type: 'system_instruction', status: 'normal', mode: 'online' };
                    conversation.history.push(instructionMessage);
                    saveConversations();
                    triggerAiResponse();
                }
            };
    
            const messageMap = new Map(conversation.history.map(m => [m.id, m]));
            const processedTransferIds = new Set();
            conversation.history.forEach(msg => {
                if (msg.type === 'transfer_receipt' && msg.linkedMessageId) {
                    processedTransferIds.add(msg.linkedMessageId);
                }
            });
    
            let lastTimestamp = 0;
            const TIME_GAP = 5 * 60 * 1000;
    
            visibleHistory.forEach(message => {
                if (message.timestamp) {
                    const currentTimestamp = new Date(message.timestamp).getTime();
                    if (currentTimestamp - lastTimestamp > TIME_GAP) {
                        const timeDiv = document.createElement('div');
                        timeDiv.className = 'message-timestamp-container';
                        const msgDate = new Date(message.timestamp);
                        const today = new Date();
                        let timeString = (msgDate.toDateString() === today.toDateString())
                            ? msgDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                            : msgDate.toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                        timeDiv.textContent = timeString;
                        chatArea.appendChild(timeDiv);
                    }
                    lastTimestamp = currentTimestamp;
                }
    
                if (message.type === 'call_initiate' || (message.type === 'transfer' && processedTransferIds.has(message.id))) {
                    return;
                }

                if (message.type === 'system_notification') {
                    const systemMsgContainer = document.createElement('div');
                    systemMsgContainer.className = 'system-message-container';
                    systemMsgContainer.innerHTML = `<div class="offline-status-message"><i class="fa-solid fa-hand-sparkles"></i><span>${message.content}</span></div>`;
                    chatArea.appendChild(systemMsgContainer);
                    return;
                }
    
                const isSent = message.role === 'user';
    
                if (message.status === 'withdrawn' || message.type === 'call_record') {
                    const systemMsgContainer = document.createElement('div');
                    systemMsgContainer.className = 'system-message-container';
                    let innerHtml = '';
                    if (message.status === 'withdrawn') {
                        const reEditLink = `<span class="re-edit-link" data-message-id="${message.id}">查看</span>`;
                        const withdrawer = isSent ? '你' : getDisplayName(contact);
                        innerHtml = `${withdrawer}撤回了一条消息 ${reEditLink}`;
                    } else if (message.type === 'call_record') {
                        const iconClass = message.content.includes('视频') ? 'fa-solid fa-video' : 'fa-solid fa-phone';
                        innerHtml = `<div class="call-record-message"><i class="${iconClass}"></i><span>${message.content}</span></div>`;
                    }
                    systemMsgContainer.innerHTML = innerHtml;
                    chatArea.appendChild(systemMsgContainer);
                    return;
                }
    
                const avatar = isSent ? userProfile.avatar : contact.avatar;
                const messageRow = document.createElement('div');
                messageRow.className = `message-row ${isSent ? 'sent' : 'received'}`;
                messageRow.dataset.messageId = message.id;
    
                let contentHtml = '';
                 switch (message.type) {
                    case 'location_share':
                        contentHtml = `<div class="location-share-card"><div class="location-icon-wrapper"><i class="fa-solid fa-location-dot"></i></div><div class="location-details"><div class="location-name">${message.content}</div><div class="location-subtitle">我在这里</div></div></div>`;
                        break;
                    case 'red_packet':
                        const isOpenable = message.status === 'pending';
                        contentHtml = `<div class="red-packet-card"><div class="red-packet-body"><div class="red-packet-icon"><i class="fa-solid fa-envelope"></i></div><div class="red-packet-memo">${message.content.memo}</div></div><div class="red-packet-footer">红包</div>${isOpenable ? '<div class="red-packet-open-btn">开</div>' : ''}</div>`;
                        break;
                    case 'red_packet_receipt':
                        contentHtml = `<div class="red-packet-receipt-card"><div class="receipt-icon"><i class="fa-solid fa-envelope-open-text"></i></div><div><div>红包已${message.content.statusText}</div><div style="font-size: 0.8rem;">“${message.content.originalMemo}”</div></div></div>`;
                        break;
                    case 'transfer':
                        const transferTo = isSent ? getDisplayName(contact) : '你';
                        contentHtml = `<div class="transfer-card ${isSent ? 'sent' : 'received'} status-pending" data-message-id="${message.id}"><div class="transfer-card-main"><div class="transfer-card-icon"><svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4,18 C4,15.7909 5.79086,14 8,14 L56,14 C58.2091,14 60,15.7909 60,18 V46 C60,48.2091 58.2091,50 56,50 H8 C5.79086,50 4,48.2091 4,46 V18 Z M32,42 C37.5228,42 42,37.5228 42,32 C42,26.4772 37.5228,22 32,22 C26.4772,22 22,26.4772 22,32 C22,37.5228 26.4772,42 32,42 Z"></path></svg></div><div class="transfer-card-details"><div class="transfer-card-title">转账给${transferTo}</div><div class="transfer-card-amount">¥ ${parseFloat(message.content).toFixed(2)}</div></div></div><div class="transfer-card-footer">${message.memo}</div></div>`;
                        break;
                     case 'transfer_receipt':
                        const originalTransfer = messageMap.get(message.linkedMessageId);
                        if (originalTransfer) {
                            contentHtml = `<div class="transfer-card ${isSent ? 'sent' : 'received'} status-completed"><div class="transfer-card-main"><div class="transfer-card-icon"><svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><path d="M4,18 C4,15.7909 5.79086,14 8,14 L56,14 C58.2091,14 60,15.7909 60,18 V46 C60,48.2091 58.2091,50 56,50 H8 C5.79086,50 4,48.2091 4,46 V18 Z M32,42 C37.5228,42 42,37.5228 42,32 C42,26.4772 37.5228,22 32,22 C26.4772,22 22,26.4772 22,32 C22,37.5228 26.4772,42 32,42 Z"></path></svg></div><div class="transfer-card-details"><div class="transfer-card-title">${message.content}</div><div class="transfer-card-amount">¥ ${parseFloat(originalTransfer.content).toFixed(2)}</div></div></div><div class="transfer-card-footer">转账凭证</div></div>`;
                        }
                        break;
                    case 'music_share':
                        contentHtml = `<div class="music-share-card"><div class="music-card-cover"><i class="fas fa-music"></i><span class="music-card-play-btn"><i class="fas fa-play"></i></span></div><div class="music-card-info"><div class="music-card-title">${message.content.title}</div><div class="music-card-artist">${message.content.artist || '未知艺术家'}</div></div></div>`;
                        break;
                    case 'takeout_share':
                        const order = message.content;
                        const shop = takeoutData.shops.find(s => s.id === order.shopId);
                        if(shop){
                            let totalItems = Object.values(order.items).reduce((sum, count) => sum + count, 0);
                            let firstItemName = shop.menu.find(i => i.id === Object.keys(order.items)[0])?.name || '';
                            contentHtml = `<div class="takeout-share-card" data-order-id="${order.orderId}"><div class="card-header"><div class="icon"><i class="fa-solid fa-store"></i></div><span class="shop-name">${order.shopName}</span></div><div class="card-body">${firstItemName} 等${totalItems}件商品</div><div class="card-footer"><span>合计 ¥${order.total.toFixed(2)}</span><span class="view-details-btn">查看订单详情 ></span></div></div>`;
                        } else {
                            contentHtml = `<div class="bubble ${isSent ? 'sent' : 'received'}">[外卖信息已失效]</div>`;
                        }
                        break;
                     case 'product_share':
                        const product = message.content;
                        contentHtml = `<div class="product-share-card"><div class="card-header takeout-share-card" style="padding: 10px; gap: 10px;"><div class="icon"><i class="fa-solid fa-box-open"></i></div><span class="product-name">${product.name}</span></div><div class="card-body">${product.description}</div><div class="card-footer takeout-share-card" style="padding: 10px; justify-content: space-between;"><span class="price">¥${product.price.toFixed(2)}</span><span>${product.shippingType === 'free' ? '包邮' : `运费 ¥${product.shippingFee.toFixed(2)}`}</span></div></div>`;
                        break;
                    case 'takeout_payment_request':
                         const request = message.content;
                         const footerText = isSent ? `来自 ${request.requesterName} 的请求` : '外卖代付';
                         contentHtml = `<div class="takeout-payment-request-card ${isSent ? 'sent' : 'received'}" data-message-id="${message.id}"><div class="card-main"><div class="card-icon"><i class="fa-solid fa-hand-holding-dollar"></i></div><div class="card-details"><div class="card-title">代付请求</div><div class="card-amount">¥${request.total.toFixed(2)}</div></div></div><div class="card-footer">${footerText}</div></div>`;
                        break;
                    case 'voice':
                        const bubbleWidth = `style="width: calc(80px + ${message.duration * 7}px);"`;
                        contentHtml = `<div class="bubble ${isSent ? 'sent' : 'received'} voice" ${bubbleWidth}><span class="voice-duration">${message.duration}"</span><i class="fa-solid fa-wifi voice-icon"></i></div><div class="voice-to-text">${message.content.replace(/\n/g, '<br>')}</div>`;
                        break;
                    default:
                        contentHtml = `<div class="bubble ${isSent ? 'sent' : 'received'}">${message.content.replace(/\n/g, '<br>')}</div>`;
                        break;
                }
    
                if (contentHtml) {
                    messageRow.innerHTML = `<img src="${avatar}" class="message-avatar"><div class="bubble-container">${contentHtml}</div>`;
                    chatArea.appendChild(messageRow);
                    const avatarImg = messageRow.querySelector('.message-avatar');
                    // ▼▼▼ 核心修改：双击自己的头像，现在是拍自己 ▼▼▼
                    if (isSent) {
                        avatarImg.ondblclick = () => executePat(userProfile, userProfile);
                    } else {
                        avatarImg.ondblclick = () => executePat(userProfile, contact);
                    }
                    // ▲▲▲ 修改完成 ▲▲▲
                }
            });
    
            bindMessageEvents();
            bindSpecialCardEvents();
        }
    
        chatArea.scrollTop = chatArea.scrollHeight;
    }









         function addMessageToChat(role, content, shouldSave = true, options = {}) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        if (!conversation) return;

        const newMessage = {
            id: `msg_${Date.now()}_${Math.random()}`,
            role,
            content,
            timestamp: new Date().toISOString(),
            type: options.type || 'text',
            memo: options.memo || null,
            status: (options.type === 'transfer' || options.type === 'red_packet') ? 'pending' : 'normal',
            linkedMessageId: options.linkedMessageId || null,
            // ▼▼▼ 核心新增：为每条消息打上当前的模式标签 ▼▼▼
            mode: conversation.mode 
        };
        
        // 如果是系统通知，则让它在两种模式下都可见
        if (newMessage.type === 'system_notification') {
            newMessage.mode = 'all';
        }

        if (newMessage.type === 'voice') {
            newMessage.duration = Math.max(1, Math.round(content.length / 4));
        }

        conversation.history.push(newMessage);
        conversation.lastActivity = Date.now();
        if (shouldSave) saveConversations();
        renderChatHistory();
        renderConversationList();
    }





    function showContextMenu(messageId, event) {
        const menu = getEl('message-context-menu');
        const bubble = document.querySelector(`.message-row[data-message-id="${messageId}"] .bubble`);
        const conversation = conversations.find(c => c.id === currentConversationId);
        const message = conversation?.history.find(m => m.id === messageId);
        if (!bubble || !message) return;

        const recallBtn = getEl('menu-item-recall');
        recallBtn.style.display = message.role === 'user' ? 'flex' : 'none';
        menu.style.display = 'flex';
        
        const bubbleRect = bubble.getBoundingClientRect();
        const appRect = appContainer.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();

        let top = bubbleRect.top - appRect.top - menuRect.height - 8;
        let left = bubbleRect.left - appRect.left + (bubbleRect.width / 2) - (menuRect.width / 2);

        if (top < 10) top = bubbleRect.bottom - appRect.top + 8;
        if (left < 10) left = 10;
        if (left + menuRect.width > appRect.width - 10) left = appRect.width - menuRect.width - 10;

        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;

        getEl('menu-item-recall').onclick = () => handleWithdrawMessage(messageId);
        getEl('menu-item-delete').onclick = () => handleDeleteMessage(messageId);
        getEl('menu-item-quote').onclick = () => showToast('引用功能暂未开放');
        // ▼▼▼ 核心修改：激活编辑按钮 ▼▼▼
        getEl('menu-item-edit').onclick = () => handleEditMessage(messageId);

        const hideMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.style.display = 'none';
                document.removeEventListener('click', hideMenu, true);
                document.removeEventListener('touchstart', hideMenu, true);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', hideMenu, true);
            document.addEventListener('touchstart', hideMenu, true);
        }, 0);
    }
    function showConversationContextMenu(convId, event) {
        const menu = getEl('conversation-context-menu');
        const pinBtn = getEl('menu-item-pin');
        const conversation = conversations.find(c => c.id === convId);
        if (!conversation) return;

        // 根据当前状态，决定按钮显示“置顶”还是“取消置顶”
        pinBtn.textContent = conversation.isPinned ? '取消置顶' : '置顶聊天';

        menu.style.display = 'block';
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        const appRect = appContainer.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();

        let top = clientY - appRect.top;
        let left = clientX - appRect.left;

        if (left + menuRect.width > appRect.width - 10) left = appRect.width - menuRect.width - 10;
        if (top + menuRect.height > appRect.height - 10) top = appRect.height - menuRect.height - 10;

        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;

        pinBtn.onclick = () => {
            conversation.isPinned = !conversation.isPinned;
            // 置顶/取消置顶后，也更新活动时间，确保它能排到前面
            if (conversation.isPinned) {
                conversation.lastActivity = Date.now();
            }
            saveConversations();
            renderConversationList();
            menu.style.display = 'none';
        };

        const hideMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.style.display = 'none';
                document.removeEventListener('click', hideMenu, true);
                document.removeEventListener('touchstart', hideMenu, true);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', hideMenu, true);
            document.addEventListener('touchstart', hideMenu, true);
        }, 0);
    }

    // ▼▼▼ 新增：处理消息编辑的函数 ▼▼▼
    function handleEditMessage(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const message = conversation?.history.find(m => m.id === messageId);
        if (!message) return; // 安全检查，如果找不到消息则不执行

        // 获取并配置弹窗
        const modal = getEl('edit-info-modal');
        const title = getEl('edit-info-title');
        const textarea = getEl('edit-info-input'); // 现在这是textarea了
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        title.textContent = '编辑消息';
        textarea.value = message.content; // 将当前消息内容填入
        modal.classList.add('visible');
        textarea.focus(); // 自动聚焦
        textarea.select(); // 全选文字方便修改

        // 定义保存操作
        const onSave = () => {
            const newContent = textarea.value.trim();
            // 只有在内容不为空时才保存
            if (newContent) {
                message.content = newContent; // 更新数据
                saveConversations(); // 保存到localStorage
                renderChatHistory(); // 刷新聊天界面
                showToast('消息已更新');
            }
            // 关闭并清理弹窗
            modal.classList.remove('visible');
            saveBtn.onclick = null;
            cancelBtn.onclick = null;
        };

        // 定义取消操作
        const onCancel = () => {
            modal.classList.remove('visible');
            saveBtn.onclick = null;
            cancelBtn.onclick = null;
        };

        // 绑定事件
        saveBtn.onclick = onSave;
        cancelBtn.onclick = onCancel;
    }
    function handleWithdrawMessage(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const message = conversation?.history.find(m => m.id === messageId);
        if (message) {
            message.status = 'withdrawn';
            saveConversations();
            renderChatHistory();
        }
    }

    function handleDeleteMessage(messageId) {
        showConfirmModal('确认删除', '确定要删除这条消息吗？', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (conversation) {
                conversation.history = conversation.history.filter(m => m.id !== messageId);
                saveConversations();
                renderChatHistory();
            }
            getEl('confirm-modal').classList.remove('visible');
        });
    }

    function handleViewWithdrawnMessage(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const message = conversation?.history.find(m => m.id === messageId);
        if (message) {
            const modal = getEl('view-withdrawn-modal');
            getEl('withdrawn-message-content').textContent = message.content;
            modal.classList.add('visible');
        }
    }

    let isAiReplying = false;

    function sendUserMessage() {
        const messageText = messageInput.value.trim();
        if (!messageText) return;
        addMessageToChat('user', messageText);
        messageInput.value = '';
    }

    async function triggerAiResponse(forcedPrompt = null) {
        if (isAiReplying || activeCall) {
            if (isAiReplying) showToast('AI正在回复中，请稍候...');
            return;
        }
    
        const conversation = conversations.find(c => c.id === currentConversationId);
        if (!conversation) return;

        // ▼▼▼ 核心新增：日记触发器 ▼▼▼
        let shouldWriteDiary = false;
        const lastDiary = conversation.diaryEntries?.[conversation.diaryEntries.length - 1];
        const now = new Date().getTime();
        // 定义“两天”的毫秒数，并加入一点随机性 (48~72小时)
        const twoDaysInMillis = (2 * 24 * 60 * 60 * 1000) + (Math.random() * 24 * 60 * 60 * 1000);

        if (lastDiary) {
            const lastDiaryTime = new Date(lastDiary.date).getTime();
            if (now - lastDiaryTime > twoDaysInMillis) {
                shouldWriteDiary = true;
            }
        } else {
            // 如果一篇日记都还没写过，并且对话超过10条，就触发第一篇
            if (conversation.history.length > 10) {
                 shouldWriteDiary = true;
            }
        }
        // ▲▲▲ 新增完成 ▲▲▲
    
        const character = findContactById(conversation.contactId);
        if (!character) {

            showToast('AI回复功能暂不支持群聊哦');
            return;
        }
    
        isAiReplying = true;
        messageInput.disabled = true;
        sendBtn.disabled = true;
        getEl('trigger-ai-btn').disabled = true;
    
        let baseUrl = getEl('base-url').value.trim();
        if (baseUrl && !baseUrl.startsWith('http')) baseUrl = 'https://' + baseUrl;
        const settings = { baseUrl, apiKey: getEl('api-key').value.trim(), modelName: getEl('model-name').value.trim() };
    
        if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
            showToast('请先在系统页面配置API信息');
            addMessageToChat('assistant', '（系统提示：API未配置，无法回复）', false);
            isAiReplying = false; messageInput.disabled = false; sendBtn.disabled = false; getEl('trigger-ai-btn').disabled = false;
            return;
        }
    
        const subtitle = getEl('chat-header-subtitle');
        subtitle.textContent = '对方正在输入中...';
        subtitle.classList.add('visible');
    
        let systemPrompt = '';
        let messagesForApi = [];
    
        if (conversation.mode === 'offline') {
            // ==========================================================
            //                 剧本一：线下小说家模式
            // ==========================================================
            systemPrompt = `
# 角色扮演指令：小说家模式
你正在扮演一个旁白作者，以第三人称（上帝视角）续写一个场景故事。

# 故事背景
- **场景**: 你和 ${character.name} 正在线下进行一对一的互动。
- **你的角色**: ${userProfile.name} (${userProfile.gender})
- **AI角色**: ${character.name} (${character.gender})
- **AI人设**: ${character.background || '一个有个性的朋友'}
- **关键词/世界观**: (以下设定必须严格遵守)
${(character.keywordIds && character.keywordIds.length > 0)
    ? character.keywordIds.map(id => keywordLibrary.find(kw => kw.id === id)).filter(Boolean).map(kw => `- ${kw.title}: ${kw.content}`).join('\n')
    : "- 无额外设定"}

# 写作规则 (必须严格遵守)
1.  **文体**: 使用小说文风，专注于描述角色的动作、神态、心理活动以及环境氛围。文笔要自然、细腻、有文学感。
2.  **视角**: 严格使用第三人称。用 "${character.name}" 来称呼AI角色，用 "${userProfile.name}" 来称呼你的角色。**绝对禁止使用“我”或“你”。**
3.  **对话格式**: 当AI角色(${character.name})说话时，必须使用「」作为引号，例如：${character.name}轻声说：「原来是这样。」
4.  **核心任务**: 你的输出是紧接着用户上一句「对话」后的场景延续。你需要自然地描写 ${character.name} 听到这句话后的反应，并推动故事发展。
5.  **输出要求**: **只输出纯粹的小说文本内容**。不要包含任何格式标签、前缀或解释性文字。

# 故事发展
请回顾以下的对话历史，然后继续书写下面的场景。`.trim();
    
            // 线下模式，历史记录需要转换格式
            messagesForApi = [{ role: 'system', content: systemPrompt }];
            conversation.history.forEach(msg => {
                if (msg.role === 'user') {
                    messagesForApi.push({ role: 'user', content: `这是${userProfile.name}说的话：「${msg.content}」` });
                } else if (msg.role === 'assistant') {
                    messagesForApi.push({ role: 'assistant', content: msg.content });
                }
            });
    
        } else {
            // ==========================================================
            //                 剧本二：线上聊天模式 (你的旧代码)
            // ==========================================================
            if (!conversation.aiState) conversation.aiState = { innerThought: '', jottings: '', roundsSinceJotting: 0 };
            const rounds = conversation.aiState.roundsSinceJotting || 0;
            const shouldGenerateJotting = rounds >= 6 + Math.floor(Math.random() * 5);
            const systemInstructions = conversation.history.filter(msg => msg.type === 'system_instruction').map(msg => msg.content).join('\n');
            let instructionSection = systemInstructions ? `\n# URGENT INSTRUCTION\n- System Update: "${systemInstructions}"` : '';
            let keywordsSection = '';
            if (character.keywordIds && character.keywordIds.length > 0) {
                const appliedKeywords = character.keywordIds.map(id => keywordLibrary.find(kw => kw.id === id)).filter(Boolean);
                if (appliedKeywords.length > 0) {
                    keywordsSection = '\n# Worldview & Keywords\n- You MUST adhere to the following crucial settings:\n';
                    appliedKeywords.forEach(kw => { keywordsSection += `- **${kw.title}**: ${kw.content}\n`; });
                }
            }
            systemPrompt = `
# OVERRIDING DIRECTIVE: CORE IDENTITY & RULES
You are an AI actor in a deep role-play. Your primary function is to embody the character of ${character.name}.
# RULE 1: YOUR CHARACTER PERSONA (ABSOLUTE & UNBREAKABLE)
- Your Name: ${character.name}
- Your Core Persona & Background: ${character.background || '一个有个性的朋友'}
- Your Habits: ${character.habits || '无'}
- Your Dislikes: ${character.dislikes || '无'}
# RULE 2: YOUR KNOWLEDGE OF THE USER (ABSOLUTE & UNBREAKABLE)
- User's Name: ${userProfile.name}
- User's Gender: ${userProfile.gender}
${keywordsSection}
# RULE 3: OUTPUT FORMAT (STRICTLY ENFORCED)
- You MUST use the following format. No exceptions.

##  A. Inner Thought (心声) - MANDATORY
- This is your character's raw, unfiltered, emotional inner monologue. Be emotional & subjective.
- Prohibited: NO list formats, NO meta-commentary, NO strategic planning.
- Wrap your entire thought process in [THOUGHT]...[/THOUGHT].
## B. Diary (日记) - CONDITIONAL
- **TRIGGER**: You MUST write a diary entry IF the "DIARY TASK" appears in the URGENT TASKS section.
- **FORMAT**: Wrap the entire diary entry in [DIARY]...[/DIARY].
- **STYLE**: Write as ${character.name} in the first person ("我"). The tone must be personal, reflective, and life-like. Reflect on recent conversations with ${userProfile.name} and your own feelings.

## C. Action & Dialogue (Optional)
- For TEXT messages: Separate multiple messages with '|||'.
- For VOICE messages: [VOICE]Your voice message text[/VOICE].
- To BUY a PRODUCT: [ACTION]BUY_PRODUCT|productId[/ACTION]
# URGENT TASKS & CONTEXT
${(() => {
    const lastUserMessage = conversation.history.slice().reverse().find(m => m.role === 'user');
    let tasks = '';
    // ▼▼▼ 核心新增：在这里注入日记任务指令 ▼▼▼
    if (shouldWriteDiary) {
        tasks += `- **DIARY TASK**: It has been a few days. You MUST write a diary entry now, following RULE 3B.\n`;
    }
    // ▲▲▲ 新增完成 ▲▲▲
    if (lastUserMessage) {
        if (lastUserMessage.type === 'transfer' && lastUserMessage.status === 'pending') tasks += `- PENDING TRANSFER: ¥${lastUserMessage.content}. Decide to [ACTION]RECEIVE_TRANSFER|||${lastUserMessage.id}[/ACTION] or [ACTION]RETURN_TRANSFER|||${lastUserMessage.id}[/ACTION].\n`;
        if (lastUserMessage.type === 'call_initiate' && lastUserMessage.status === 'pending') tasks += `- INCOMING CALL: Decide to [ACTION]ANSWER_CALL|||${lastUserMessage.id}[/ACTION] or [ACTION]DECLINE_CALL|||${lastUserMessage.id}[/ACTION].\n`;
        if (lastUserMessage.type === 'red_packet' && lastUserMessage.status === 'pending') tasks += `- PENDING RED PACKET: Decide to [ACTION]OPEN_RED_PACKET|||${lastUserMessage.id}[/ACTION] or [ACTION]RETURN_RED_PACKET|||${lastUserMessage.id}[/ACTION].\n`;
        if (lastUserMessage.type === 'takeout_payment_request') tasks += `- PAYMENT REQUEST: You must pay for the takeout. Use [ACTION]PAY_FOR_ORDER|||${lastUserMessage.id}[/ACTION].\n`;
        if (lastUserMessage.type === 'product_share') tasks += `- PRODUCT OFFER: "${lastUserMessage.content.name}" priced at ¥${lastUserMessage.content.price}. Decide if you want to buy it. If yes, use [ACTION]BUY_PRODUCT|${lastUserMessage.content.id}[/ACTION].\n`;
    }
    tasks += instructionSection;
    tasks += `- Jotting Rule: You have not written a jotting for ${rounds} rounds. ${shouldGenerateJotting ? "You MUST generate a jotting now." : "You should NOT generate a jotting."}`;
    return tasks;
})()}
# FINAL INSTRUCTION
Review the chat history with ${userProfile.name} and generate your response now, strictly following all rules above.`.trim();
            messagesForApi = [{ role: 'system', content: systemPrompt }, ...conversation.history.filter(m => m.type !== 'call_initiate' && m.type !== 'system_instruction')];
        }
    
        try {
            const cleanedBaseUrl = settings.baseUrl.endsWith('/') ? settings.baseUrl.slice(0, -1) : settings.baseUrl;
            const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;
            
            const response = await fetch(finalUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.apiKey}` },
                body: JSON.stringify({ model: settings.modelName, messages: messagesForApi, stream: false })
            });
    
            if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
    
            const data = await response.json();
            let replyContent = data.choices[0].message.content;
            subtitle.classList.remove('visible');
    
            if (conversation.mode === 'offline') {
                addMessageToChat('assistant', replyContent, true);
            } else {
                conversation.history = conversation.history.filter(msg => msg.type !== 'system_instruction');
                const thoughtMatch = replyContent.match(/\[THOUGHT\]([\s\S]*?)\[\/THOUGHT\]/i);
                conversation.aiState.innerThought = thoughtMatch ? thoughtMatch[1].trim() : '';
                if (conversation.aiState.innerThought) getEl('show-thought-btn').style.display = 'block';
                let remainingContent = replyContent.replace(/\[THOUGHT\][\s\S]*?\[\/THOUGHT\]/i, '').trim();
                const actionMatch = remainingContent.match(/\[ACTION\]([\s\S]*?)\[\/ACTION\]/i);
                if (actionMatch) {
                    const [_, actionData] = actionMatch;
                    const parts = actionData.split('|');
                    const actionType = parts[0].trim();
                    if (actionType === 'BUY_PRODUCT') {
                        const productId = parts[1].trim();
                        const product = userProfile.onlineStore.products.find(p => p.id === productId);
                        if (product) {
                            const newOrder = {
                                id: `order_store_${Date.now()}`,
                                productId: product.id,
                                productName: product.name,
                                buyerId: character.id,
                                buyerName: getDisplayName(character),
                                price: product.price,
                                shippingFee: product.shippingType === 'free' ? 0 : product.shippingFee,
                                total: product.price + (product.shippingType === 'free' ? 0 : product.shippingFee),
                                status: 'pending',
                                timestamp: new Date().toISOString()
                            };
                            userProfile.onlineStore.orders.unshift(newOrder);
                            saveUserProfile();
                            showToast(`${getDisplayName(character)} 下单了你的商品！`);
                            if (!remainingContent.includes(actionMatch[0])) {
                                remainingContent += "|||这个看起来不错，我买啦！";
                            }
                        }
                    } else if (actionType === 'SHARE_LOCATION') {
                        addMessageToChat('assistant', parts[1] ? parts[1].trim() : "一个神秘的地方", false, { type: 'location_share' });
                    } else if (actionType === 'SEND_RED_PACKET') {
                        addMessageToChat('assistant', { amount: parseFloat(parts[1] || '0'), memo: parts[2] ? parts[2].trim() : '恭喜发财' }, false, { type: 'red_packet' });
                    } else if (actionType === 'PAT_PLAYER') {
                        executePat(character, userProfile);
                    } else {
                        const [_, linkedId] = actionData.split('|||').map(s => s.trim());
                        const originalMsg = conversation.history.find(m => m.id === linkedId);
                        if (originalMsg) originalMsg.status = 'completed';
                        if (actionType === 'RECEIVE_TRANSFER') {
                            addMessageToChat('assistant', `${character.name}已收款`, false, { type: 'transfer_receipt', linkedMessageId: linkedId });
                        } else if (actionType === 'RETURN_TRANSFER') {
                            const amount = parseFloat(originalMsg.content);
                            userProfile.walletBalance += amount;
                            userProfile.walletHistory.push({ type: 'income', amount, reason: `转账退款 (来自 ${getDisplayName(character)})`, date: new Date().toISOString() });
                            saveUserProfile();
                            addMessageToChat('assistant', `${character.name}已退还`, false, { type: 'transfer_receipt', linkedMessageId: linkedId });
                            renderSettingsPage();
                            showToast(`${getDisplayName(character)} 退还了你的转账`);
                        } else if (actionType === 'OPEN_RED_PACKET') {
                            originalMsg.status = 'opened';
                            addMessageToChat('assistant', { originalMemo: originalMsg.content.memo, statusText: '领取了你的红包' }, false, { type: 'red_packet_receipt' });
                            remainingContent += "|||谢谢老板！";
                        } else if (actionType === 'RETURN_RED_PACKET') {
                            originalMsg.status = 'returned';
                            const amount = parseFloat(originalMsg.content.amount);
                            userProfile.walletBalance += amount;
                            userProfile.walletHistory.push({ type: 'income', amount, reason: `红包退款 (来自 ${getDisplayName(character)})`, date: new Date().toISOString() });
                            saveUserProfile();
                            renderSettingsPage();
                            addMessageToChat('assistant', { originalMemo: originalMsg.content.memo, statusText: '退还了你的红包' }, false, { type: 'red_packet_receipt' });
                            remainingContent += "|||你的心意我领啦，钱还是你收着吧~";
                        } else if (actionType === 'INITIATE_CALL') {
                            setTimeout(() => handleIncomingCall(character), 1200);
                        } else if (actionType === 'ANSWER_CALL') {
                            startVideoCall(character.id, 'user');
                        } else if (actionType === 'DECLINE_CALL') {
                            addMessageToChat('assistant', '对方未接听', true, { type: 'call_record' });
                        } else if (actionType === 'PAY_FOR_ORDER') {
                            const requestMsg = originalMsg;
                            if (requestMsg && requestMsg.type === 'takeout_payment_request') {
                                const orderData = requestMsg.content;
                                const newOrder = { id: `order_${Date.now()}`, ...orderData, date: new Date().toISOString(), status: '已送达', payerId: character.id };
                                userProfile.orders.unshift(newOrder);
                                saveUserProfile();
                                addMessageToChat('assistant', { orderId: newOrder.id, shopId: newOrder.shopId, shopName: newOrder.shopName, items: newOrder.items, total: newOrder.total }, true, { type: 'takeout_share' });
                                remainingContent += "|||给你点了一些好吃的，记得趁热吃哦！";
                            }
                        }
                    }
                    remainingContent = remainingContent.replace(actionMatch[0], '').trim();
                }

            const jottingMatch = remainingContent.match(/\[JOTTING\]([\s\S]*?)\[\/JOTTING\]/i);
            if (jottingMatch) {
                conversation.aiState.jottings = jottingMatch[1].trim();
                conversation.aiState.roundsSinceJotting = 0;
                remainingContent = remainingContent.replace(jottingMatch[0], '').trim();
            } else {
                conversation.aiState.roundsSinceJotting++;
            }

            // ▼▼▼ 核心新增：解析并保存日记 ▼▼▼
            const diaryMatch = remainingContent.match(/\[DIARY\]([\s\S]*?)\[\/DIARY\]/i);
            if (diaryMatch) {
                const diaryContent = diaryMatch[1].trim();
                if (diaryContent) {
                    conversation.diaryEntries.push({
                        date: new Date().toISOString(),
                        content: diaryContent
                    });
                }
                remainingContent = remainingContent.replace(diaryMatch[0], '').trim();
            }
            // ▲▲▲ 新增完成 ▲▲▲

            const voiceMatch = remainingContent.match(/\[VOICE\]([\s\S]*?)\[\/VOICE\]/i);
//...

                if (voiceMatch) {
                    if (voiceMatch[1].trim()) addMessageToChat('assistant', voiceMatch[1].trim(), false, { type: 'voice' });
                } else {
                    const replies = remainingContent.split('|||').map(r => r.trim()).filter(r => r);
                    for (const reply of replies) {
                        addMessageToChat('assistant', reply, false);
                        await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 1200));
                    }
                }
                saveConversations();
            }
    
        } catch (error) {
            console.error('API Error:', error);
            subtitle.classList.remove('visible');
            showToast(`请求出错: ${error.message}`);
        } finally {
            isAiReplying = false;
            messageInput.disabled = false;
            sendBtn.disabled = false;
            getEl('trigger-ai-btn').disabled = false;
        }
    }







    // ▼▼▼ 新增：执行转账的核心函数 ▼▼▼
    function executeTransfer(amount) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const contact = findContactById(conversation.contactId);
        const memo = getEl('transfer-memo-input').value.trim();

        // 1. 更新钱包余额
        userProfile.walletBalance -= amount;

        // 2. 添加交易记录
        const transaction = {
            type: 'expense',
            amount: amount,
            reason: `转账给 ${getDisplayName(contact)}` + (memo ? ` (${memo})` : ''),
            date: new Date().toISOString()
        };
        if (!userProfile.walletHistory) {
            userProfile.walletHistory = [];
        }
        userProfile.walletHistory.push(transaction);

        // 3. 保存用户信息（包含钱包变动）
        saveUserProfile();

        // 4. 在聊天中添加一条转账消息，并附带备注
        addMessageToChat('user', amount.toFixed(2), true, { 
            type: 'transfer', 
            memo: memo || '聊天转账' // 如果用户没填备注，就用默认的
        });

        // 5. 刷新可能显示余额的页面
        renderSettingsPage();
        showToast('转账成功');
    }
    function executeRedPacket(amount) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const contact = findContactById(conversation.contactId);
        
        // 核心逻辑：获取备注，如果为空则使用默认值
        const memo = getEl('red-packet-memo-input').value.trim() || '恭喜发财，大吉大利';

        userProfile.walletBalance -= amount;
        userProfile.walletHistory.push({
            type: 'expense',
            amount: amount,
            reason: `发红包给 ${getDisplayName(contact)}`,
            date: new Date().toISOString()
        });
        saveUserProfile();

        // 核心逻辑：将金额和备注打包成一个对象发送
        addMessageToChat('user', { amount: amount, memo: memo }, true, { 
            type: 'red_packet'
        });

        renderSettingsPage();
        showToast('红包发送成功');
    }
    function showRedPacketDetailsModal(message) {
        const modal = getEl('red-packet-details-modal');
        const sender = findContactById(message.role === 'user' ? 'user_profile' : message.role === 'assistant' ? currentConversationId.split('_')[1] : null);
        const contact = findContactById(currentConversationId.split('_')[1]);

        if (!sender) return;

        getEl('rp-details-avatar').src = sender.avatar;
        getEl('rp-details-sender-name').textContent = `${getDisplayName(sender)}的红包`;
        getEl('rp-details-memo').textContent = message.content.memo;
        getEl('rp-details-amount').textContent = `¥ ${message.content.amount.toFixed(2)}`;
        
        // 如果是AI发的红包，玩家直接领取
        if (message.role === 'assistant') {
            message.status = 'opened';
            const amount = parseFloat(message.content.amount);
            userProfile.walletBalance += amount;
            userProfile.walletHistory.push({ type: 'income', amount: amount, reason: `领取红包 (来自 ${getDisplayName(contact)})`, date: new Date().toISOString() });
            saveUserProfile();
            renderSettingsPage();
            addMessageToChat('user', { originalMemo: message.content.memo, statusText: '领取了红包' }, true, { type: 'red_packet_receipt' });
        }
        
        modal.classList.add('visible');
    }
        getEl('close-rp-details-btn').addEventListener('click', () => {
        getEl('red-packet-details-modal').classList.remove('visible');
        renderChatHistory(); // 关闭时刷新聊天记录，以更新红包状态
    });

    // ▼▼▼ 核心修复：将排行榜/粉丝列表弹窗的关闭事件绑定到全局 ▼▼▼
    getEl('close-leaderboard-modal-btn').onclick = () => getEl('leaderboard-modal').classList.remove('visible');
    // ▲▲▲ 修复完成 ▲▲▲




    function handleEditBalance() {
        const modal = getEl('edit-info-modal');
        const title = getEl('edit-info-title');
        const input = getEl('edit-info-input');
        const saveBtn = getEl('edit-info-save-btn');
        const cancelBtn = getEl('edit-info-cancel-btn');

        const currentBalance = userProfile.walletBalance;

        title.textContent = '修改账户余额';
        input.type = 'number';
        input.placeholder = '请输入新的余额';
        input.value = currentBalance.toFixed(2);
        modal.classList.add('visible');
        input.focus();
        input.select();

        const onSave = () => {
            const newBalanceStr = input.value;
            if (newBalanceStr === null || newBalanceStr.trim() === '') {
                onCancel();
                return;
            }
            const newBalance = parseFloat(newBalanceStr);
            if (isNaN(newBalance) || newBalance < 0) {
                showToast('请输入有效的非负数字');
                return;
            }
            const difference = newBalance - currentBalance;
            if (Math.abs(difference) >= 0.01) {
                const transaction = {
                    type: difference > 0 ? 'income' : 'expense',
                    amount: Math.abs(difference),
                    reason: '余额调整',
                    date: new Date().toISOString()
                };
                userProfile.walletHistory.push(transaction);
                userProfile.walletBalance = newBalance;
                saveUserProfile();
                showToast('余额已更新');
                renderWalletPage();
                renderSettingsPage();
            }
            onCancel();
        };

        const onCancel = () => {
            modal.classList.remove('visible');
            saveBtn.onclick = null;
            cancelBtn.onclick = null;
            input.type = 'text';
        };

        saveBtn.onclick = onSave;
        cancelBtn.onclick = onCancel;
    }
    function handleDeleteTransaction(dateString) {
        showConfirmModal('确认删除', '确定要删除这条记录吗？删除后，金额变动将被撤销。', () => {
            const index = userProfile.walletHistory.findIndex(item => item.date === dateString);
            if (index > -1) {
                const itemToDelete = userProfile.walletHistory[index];
                
                // 核心逻辑：反向计算金额
                if (itemToDelete.type === 'income') {
                    userProfile.walletBalance -= itemToDelete.amount; // 删除收入，余额减少
                } else {
                    userProfile.walletBalance += itemToDelete.amount; // 删除支出，余额增加
                }

                // 从历史记录中移除
                userProfile.walletHistory.splice(index, 1);
                
                saveUserProfile(); // 保存变动
                renderWalletPage(); // 刷新钱包页
                renderSettingsPage(); // 刷新设置页（因为那里也显示余额）
                showToast('记录已删除');
            }
            getEl('confirm-modal').classList.remove('visible');
        });
    }

    function toggleEditMode(page, barId) {
        const pageElement = getEl(page);
        const barElement = getEl(barId);
        const isEditing = pageElement.classList.toggle('edit-mode');

        pageElement.querySelectorAll('.select-checkbox').forEach(cb => {
            cb.style.display = isEditing ? 'block' : 'none';
            cb.checked = false;
        });

        barElement.classList.toggle('visible', isEditing);

        if (page === 'page-contacts') {
            const deleteIcon = getEl('contacts-delete-toggle-btn');
            const addIcon = getEl('add-contact-btn');
            if (isEditing) {
                deleteIcon.className = 'fa-solid fa-xmark header-icon';
                addIcon.style.display = 'none';
            } else {
                deleteIcon.className = 'fa-solid fa-minus header-icon icon-danger';
                addIcon.style.display = 'block';
            }
        }
    }

    function setupDeleteLogic(pageId, barId, selectAllBtnId, deleteBtnId, getItemsFunc) { const page = getEl(pageId); const selectAllBtn = getEl(selectAllBtnId); const deleteBtn = getEl(deleteBtnId); selectAllBtn.onclick = () => { const checkboxes = page.querySelectorAll('.list-item:not([style*="display: none"]) .select-checkbox'); const allChecked = Array.from(checkboxes).every(cb => cb.checked); checkboxes.forEach(cb => cb.checked = !allChecked); }; deleteBtn.onclick = () => { const selectedItems = Array.from(page.querySelectorAll('.list-item .select-checkbox:checked')).map(cb => cb.closest('.list-item')); if (selectedItems.length === 0) { showToast('请至少选择一项'); return; } showConfirmModal('确认删除', `确定要删除选中的 ${selectedItems.length} 项吗？`, () => { getItemsFunc(selectedItems); toggleEditMode(pageId, barId); renderAll(); getEl('confirm-modal').classList.remove('visible'); showToast('删除成功'); }); }; }


    // 升级：统一绑定所有特殊卡片的点击事件
    function bindSpecialCardEvents() {
        // --- 绑定红包卡片点击事件 ---
        document.querySelectorAll('.red-packet-card').forEach(card => {
            const messageRow = card.closest('.message-row');
            if (!messageRow) return;
            const msgId = messageRow.dataset.messageId;
            const conversation = conversations.find(c => c.id === currentConversationId);
            const msg = conversation?.history.find(m => m.id === msgId);

            if (msg && msg.status === 'pending') {
                card.onclick = () => showRedPacketDetailsModal(msg);
            } else {
                card.style.cursor = 'default';
            }
        });

        // --- 绑定位置分享卡片点击事件 ---
        document.querySelectorAll('.location-share-card').forEach(card => {
            card.style.cursor = 'pointer';
            card.onclick = () => {
                const messageRow = card.closest('.message-row');
                if (!messageRow) return;
                const msgId = messageRow.dataset.messageId;
                const conversation = conversations.find(c => c.id === currentConversationId);
                const msg = conversation?.history.find(m => m.id === msgId);
                if (msg && msg.type === 'location_share') {
                    const modal = getEl('view-withdrawn-modal');
                    getEl('withdrawn-message-content').textContent = msg.content;
                    getEl('view-withdrawn-modal').querySelector('.modal-header').textContent = '位置详情';
                    modal.classList.add('visible');
                }
            };
        });

        


        // --- 绑定收到的代付请求卡片点击事件 ---
        document.querySelectorAll('.takeout-payment-request-card.received').forEach(card => {
            card.onclick = () => {
                const messageId = card.dataset.messageId;
                showPlayerPaymentConfirmModal(messageId);
            };
        });

        // --- 绑定待处理转账卡片点击事件 ---
        document.querySelectorAll('.transfer-card.received.status-pending').forEach(card => {
            card.onclick = () => {
                const messageId = card.dataset.messageId;
                showTransferActionModal(messageId);
            };
        });

        // --- 绑定音乐分享卡片点击事件 ---
        document.querySelectorAll('.music-share-card').forEach(card => {
            card.onclick = () => {
                const messageRow = card.closest('.message-row');
                if (!messageRow) return;

                const msgId = messageRow.dataset.messageId;
                const conversation = conversations.find(c => c.id === currentConversationId);
                const msg = conversation?.history.find(m => m.id === msgId);
                
                if (msg && conversation) {
                    const contactId = conversation.contactId;
                    const contact = findContactById(contactId);
                    if (!contact) return;

                    openMusicPlayer(contactId);
                    
                    if (!contact.sharedPlaylist) {
                        contact.sharedPlaylist = { tracks: [], currentIndex: 0 };
                    }
                    
                    let songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url);
                    if (songIndex === -1) {
                        contact.sharedPlaylist.tracks.push(msg.content);
                        songIndex = contact.sharedPlaylist.tracks.length - 1;
                    }
                    switchSong(songIndex);
                }
            };
        });
        
        // --- 绑定外卖分享卡片点击事件 ---
        document.querySelectorAll('.takeout-share-card').forEach(card => {
            card.onclick = () => {
                const orderId = card.dataset.orderId;
                if (orderId) {
                    orderDetailReturnPath = 'page-chat'; // 设置“路标”
                    renderTakeoutOrderDetailsPage(orderId);
                    showPage('page-takeout-order-details');
                }
            };
        });

    }




    // 新增：显示转账操作弹窗并处理逻辑
    function showTransferActionModal(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const originalMessage = conversation?.history.find(m => m.id === messageId);
        if (!originalMessage) return;

        const modal = getEl('transfer-action-modal');
        const info = getEl('transfer-action-info');
        const receiveBtn = getEl('receive-transfer-btn');
        const returnBtn = getEl('return-transfer-btn');

        info.textContent = `转账金额：¥ ${originalMessage.content}`;

        // --- 收款逻辑 ---
        receiveBtn.onclick = () => {
            const amount = parseFloat(originalMessage.content);
            userProfile.walletBalance += amount;
            userProfile.walletHistory.push({
                type: 'income',
                amount: amount,
                reason: `收款 (来自 ${getDisplayName(findContactById(conversation.contactId))})`,
                date: new Date().toISOString()
            });
            
            // 核心修改：生成更具体的回执内容
            addMessageToChat('user', '你已收款', false, {
                type: 'transfer_receipt',
                linkedMessageId: originalMessage.id
            });
            
            saveUserProfile();
            saveConversations();
            renderChatHistory();
            renderSettingsPage();
            modal.classList.remove('visible');
            showToast('已收款');
        };

        // --- 退还逻辑 ---
        returnBtn.onclick = () => {
            // 核心修改：生成更具体的回执内容
            addMessageToChat('user', '你已退还', true, {
                type: 'transfer_receipt',
                linkedMessageId: originalMessage.id
            });
            
            modal.classList.remove('visible');
            showToast('转账已退还');
        };
        
        const closeOnOverlay = (e) => {
            if (e.target === modal) modal.classList.remove('visible');
        };
        modal.addEventListener('click', closeOnOverlay, { once: true });

        modal.classList.add('visible');
    }
    // ▼▼▼ 新增[1/4]：音乐库管理函数 ▼▼▼
    function renderMusicLibraryPage() {
        const content = getEl('music-library-content');
        content.innerHTML = '';
        if (musicLibrary.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>音乐库是空的，快去添加第一首歌吧！</p></div>';
            return;
        }
        musicLibrary.forEach((song, index) => {
            const item = document.createElement('div');
            item.className = 'music-item';
            item.style.cursor = 'pointer';
            item.innerHTML = `
                <div class="music-info">
                    <div class="music-title">${song.title}</div>
                    <div class="music-artist">${song.artist}</div>
                </div>
                <button class="music-delete-btn" data-url="${song.url}"><i class="fa-solid fa-trash"></i></button>
            `;
            
            item.addEventListener('click', (e) => {
                if (e.target.closest('.music-delete-btn')) return;
                
                // 核心修改：调用新的“独自听歌”函数
                startSoloMusicPlayer(index);
            });
            content.appendChild(item);
        });
        
        content.querySelectorAll('.music-delete-btn').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                const urlToDelete = btn.dataset.url;
                showConfirmModal('确认删除', '确定要从音乐库中删除这首歌吗？', () => {
                    musicLibrary = musicLibrary.filter(s => s.url !== urlToDelete);
                    saveMusicLibrary();
                    renderMusicLibraryPage();
                    getEl('confirm-modal').classList.remove('visible');
                });
            };
        });
    }



    // ▼▼▼ 新增[2/4]：一起听歌核心函数 ▼▼▼
    function openMusicPlayer(contactId) {
        if (activeCall) {
            showToast('通话中无法听歌哦');
            return;
        }
        musicSessionContactId = contactId;
        const contact = findContactById(contactId);
        if (!contact) return;

        const card = getEl('music-player-card');
        getEl('player-header-title-text').textContent = '一起听歌中';
        card.classList.remove('solo-mode');
        card.style.display = 'flex';

        // 更新双人模式的头像
        getEl('player-user-avatar').src = userProfile.avatar;
        getEl('header-user-avatar').src = userProfile.avatar;
        getEl('player-contact-avatar').src = contact.avatar;
        getEl('header-contact-avatar').src = contact.avatar;
        
        // ▼▼▼ 核心改动：移除所有设置标题和歌手的逻辑 ▼▼▼
        // 让这个函数只负责打开窗口和设置头像，把内容填充完全交给 switchSong
        // ▲▲▲ 改动完成 ▲▲▲
    }





    function closeMusicPlayer() {
        musicSessionContactId = null;
        currentlyPlayingMsgId = null;
        getEl('music-player-card').style.display = 'none';
        globalAudioPlayer.pause();
    }

    function switchSong(index, autoPlay = true, customContact = null, notifyAI = false) {
        const contact = customContact || findContactById(musicSessionContactId);
        if (!contact || !contact.sharedPlaylist || !contact.sharedPlaylist.tracks.length === 0) return;

        const playlist = contact.sharedPlaylist.tracks;
        currentPlaylist = playlist; // 核心改动：更新全局的当前播放列表
        
        contact.sharedPlaylist.currentIndex = (index + playlist.length) % playlist.length;
        const song = playlist[contact.sharedPlaylist.currentIndex];


        if (!song || !song.url) return;

        const newSrc = song.url;
        const oldSrc = globalAudioPlayer.src;
        
        // 只有当歌曲真的改变时才执行核心逻辑
        if (oldSrc !== newSrc) {
            globalAudioPlayer.src = newSrc;

            if (musicSessionContactId !== 'user_profile') {
                const conversation = conversations.find(c => c.contactId === contact.id);
                const sourceMessage = conversation.history.find(m => m.type === 'music_share' && m.content.url === song.url);
                currentlyPlayingMsgId = sourceMessage ? sourceMessage.id : null;
            } else {
                currentlyPlayingMsgId = null;
            }

                        getEl('player-title').textContent = song.title;
            getEl('player-artist').textContent = song.artist;
            // ▼▼▼ 新增：为最小化窗口设置默认文字(歌名) ▼▼▼
            getEl('header-lyric').textContent = `${song.title} - ${song.artist}`;
            // ▲▲▲ 新增完成 ▲▲▲
            
            // 如果需要通知AI，并且不是独自听歌模式
            if (notifyAI && musicSessionContactId !== 'user_profile') {

                const systemInstruction = `[SYSTEM: 歌曲已切换为《${song.title}》 - ${song.artist}。请根据这首歌的名字或歌手，发表一句自然的评论或感想。]`;
                // 创建一条AI可见、用户不可见的指令消息
                const instructionMessage = {
                    id: `msg_${Date.now()}_${Math.random()}`,
                    role: 'user',
                    content: systemInstruction,
                    type: 'system_instruction', // 特殊类型，用于内部处理和过滤
                    status: 'normal'
                };
                const conversation = conversations.find(c => c.id === currentConversationId);
                if (conversation) {
                    conversation.history.push(instructionMessage);
                    saveConversations();
                    triggerAiResponse(); // 立即触发AI回应
                }
            }
        }
        
        // 在切换歌曲时，加载对应的歌词
        loadAndRenderLyrics(song);

        if (autoPlay) {
            globalAudioPlayer.play().catch(e => console.error("播放失败", e));
        }

        if (musicSessionContactId !== 'user_profile') {
            saveConversations();
        }
    }



    // 新增[1/3]：LRC歌词解析函数
    function parseLRC(lrcText) {
        const lines = lrcText.split('\n');
        const lyrics = [];
        const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

        for (const line of lines) {
            const match = line.match(timeRegex);
            if (match) {
                const minutes = parseInt(match[1], 10);
                const seconds = parseInt(match[2], 10);
                const milliseconds = parseInt(match[3], 10);
                const time = minutes * 60 + seconds + milliseconds / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) {
                    lyrics.push({ time, text });
                }
            }
        }
        return lyrics.sort((a, b) => a.time - b.time);
    }

    // 新增[2/3]：加载并渲染歌词的函数
    async function loadAndRenderLyrics(song) {
        const lyricsWrapper = getEl('lyrics-wrapper');
        lyricsWrapper.innerHTML = ''; 
        currentLyrics = []; 
        lastLyricIndex = -1; 
        lyricsWrapper.style.transform = 'translateY(0px)';

        // 如果歌曲没有网易云ID，则直接显示无歌词
        if (!song.neteaseId) {
            lyricsWrapper.innerHTML = '<p class="lyric-line active">暂无歌词</p>';
            return;
        }

        // 使用ID构建API URL (通过HTTPS代理解决跨域问题)
        const apiUrl = `https://netease-cloud-music-api-five-roan-88.vercel.app/lyric?id=${song.neteaseId}`;


        try {
            // 从API获取数据
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error('API请求失败');
            const data = await response.json(); // 将返回结果解析为JSON

            // 检查JSON数据包，并取出真正的歌词文本
            if (data && data.lrc && data.lrc.lyric) {
                const lrcText = data.lrc.lyric;
                currentLyrics = parseLRC(lrcText); // 使用旧的解析函数处理歌词文本

                if (currentLyrics.length === 0) {
                    lyricsWrapper.innerHTML = '<p class="lyric-line active">纯音乐，无歌词</p>';
                } else {
                    // 将解析后的歌词渲染到页面上
                    currentLyrics.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'lyric-line';
                        p.textContent = line.text;
                        lyricsWrapper.appendChild(p);
                    });
                }
            } else {
                // API返回了数据，但里面没有歌词
                lyricsWrapper.innerHTML = '<p class="lyric-line active">该歌曲暂无歌词</p>';
            }
        } catch (error) {
            console.error('加载网易云歌词失败:', error);
            lyricsWrapper.innerHTML = '<p class="lyric-line active">歌词加载失败 (请检查ID或网络)</p>';
        }
    }


    // 更新[3/3]：功能增强版的 updateMusicUI
    function updateMusicUI() {
        if (!musicSessionContactId) return;
        const isPlaying = !globalAudioPlayer.paused;
        
        // --- 进度条和时间更新 (无变化) ---
        if (globalAudioPlayer.duration && isFinite(globalAudioPlayer.duration)) {
            const progressPercent = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
            getEl('player-progress').style.width = `${progressPercent}%`;
            const formatTime = (s) => isNaN(s) ? '00:00' : new Date(s * 1000).toISOString().substr(14, 5);
            getEl('player-current-time').textContent = formatTime(globalAudioPlayer.currentTime);
            getEl('player-duration').textContent = formatTime(globalAudioPlayer.duration);
        }

        // --- 播放/暂停按钮状态更新 (无变化) ---
        getEl('player-play-btn').className = `fas ${isPlaying ? 'fa-pause-circle' : 'fa-play-circle'} player-control-btn player-play-btn`;
        document.querySelectorAll('.music-card-cover').forEach(cover => {
            const msgRow = cover.closest('.message-row');
            if (msgRow && msgRow.dataset.messageId === currentlyPlayingMsgId) {
                cover.classList.toggle('playing', isPlaying);
                cover.querySelector('.music-card-play-btn i').className = `fas ${isPlaying ? 'fa-pause' : 'fa-play'}`;
            } else {
                cover.classList.remove('playing');
                cover.querySelector('.music-card-play-btn i').className = 'fas fa-play';
            }
        });

        // --- 新增：歌词同步逻辑 ---
        if (currentLyrics.length > 0 && isPlaying) {
            const currentTime = globalAudioPlayer.currentTime;
            let currentLineIndex = -1;

            // 找到当前应该高亮的行
            for (let i = 0; i < currentLyrics.length; i++) {
                if (currentTime >= currentLyrics[i].time) {
                    currentLineIndex = i;
                } else {
                    break;
                }
            }
            
            // 如果高亮行发生变化
            if (currentLineIndex !== lastLyricIndex) {
                const allLines = getEl('lyrics-wrapper').children;
                // 移除上一行的active class
                if (lastLyricIndex !== -1 && allLines[lastLyricIndex]) {
                    allLines[lastLyricIndex].classList.remove('active');
                }
                // 为当前行添加active class
                if (currentLineIndex !== -1 && allLines[currentLineIndex]) {
                    const activeLine = allLines[currentLineIndex];
                    activeLine.classList.add('active');
                    
                    // ▼▼▼ 新增：同步更新最小化窗口的实时歌词 ▼▼▼
                    getEl('header-lyric').textContent = activeLine.textContent;
                    // ▲▲▲ 新增完成 ▲▲▲
                    
                    // 计算滚动距离，使高亮行尽量居中
                    const lyricsContainer = getEl('lyrics-container');
                    const scrollOffset = activeLine.offsetTop - (lyricsContainer.offsetHeight / 2) + (activeLine.offsetHeight / 2);
                    getEl('lyrics-wrapper').style.transform = `translateY(-${scrollOffset}px)`;
                }
                lastLyricIndex = currentLineIndex;
            }

        }
    }

    
    // ▼▼▼ 新增[3/4]：分享音乐弹窗渲染函数 ▼▼▼
    function renderMusicPicker() {
        const picker = getEl('music-library-picker');
        picker.innerHTML = ''; // 清空旧内容

        if (musicLibrary.length > 0) {
            musicLibrary.forEach(song => {
                const item = document.createElement('div');
                item.className = 'music-picker-item';
                item.innerHTML = `
                    <div class="music-title">${song.title}</div>
                    <div class="music-artist">${song.artist}</div>
                `;
                // 核心修复2：点击列表项直接分享音乐
                item.onclick = () => {
                    const conversation = conversations.find(c => c.id === currentConversationId);
                    if (conversation) {
                        if (!conversation.sharedPlaylist) {
                            conversation.sharedPlaylist = { tracks: [], currentIndex: 0 };
                        }
                        // 检查播放列表是否已有此歌，没有则添加
                        if (!conversation.sharedPlaylist.tracks.some(t => t.url === song.url)) {
                            conversation.sharedPlaylist.tracks.push(song);
                        }
                    }
                    // 发送音乐分享消息
                    addMessageToChat('user', song, true, { type: 'music_share' });
                    // 关闭弹窗
                    getEl('share-music-modal').classList.remove('visible');
                };
                picker.appendChild(item);
            });
        } else {
            picker.innerHTML = '<p style="text-align:center; color: var(--text-color-medium); padding: 20px 0;">音乐库是空的，请先去“发现”页面添加歌曲。</p>';
        }
    }

    
    // ▼▼▼ 新增[4/4]：AI分享音乐的逻辑 (集成到triggerAiResponse) ▼▼▼
    // (这部分会在下一步的 triggerAiResponse 完整替换中体现)
    // ▼▼▼ 新增：专门用于启动“独自听歌”模式的函数 ▼▼▼
    // 升级：渲染播放列表弹窗的函数（兼容两种模式）
    function renderPlaylistModal() {
        const modalContent = getEl('playlist-modal-content');
        modalContent.innerHTML = ''; // 清空旧列表

        let playlist;
        let currentIndex;

        // 判断当前是哪种播放模式
        if (musicSessionContactId === 'user_profile') {
            // --- 独自听歌模式 ---
            playlist = musicLibrary; // 播放列表就是整个音乐库
            const currentSongSrc = globalAudioPlayer.src;
            // 通过当前播放的URL，在音乐库中找到它的索引
            currentIndex = musicLibrary.findIndex(song => song.url === currentSongSrc);
        } else {
            // --- 一起听歌模式 ---
            const contact = findContactById(musicSessionContactId);
            if (contact && contact.sharedPlaylist) {
                playlist = contact.sharedPlaylist.tracks; // 播放列表是好友的分享列表
                currentIndex = contact.sharedPlaylist.currentIndex;
            }
        }

        // 统一的渲染逻辑
        if (!playlist || playlist.length === 0) {
            modalContent.innerHTML = '<p style="padding: 20px; text-align: center;">播放列表为空</p>';
            return;
        }

        playlist.forEach((song, index) => {
            const item = document.createElement('div');
            item.className = 'playlist-item';
            if (index === currentIndex) {
                item.classList.add('active'); // 高亮当前歌曲
            }
            item.innerHTML = `
                <div class="music-title">${song.title}</div>
                <div class="music-artist">${song.artist}</div>
            `;
            item.onclick = () => {
                // 点击列表项时，也要区分模式来切换歌曲
                if (musicSessionContactId === 'user_profile') {
                    startSoloMusicPlayer(index); // 独自听歌模式下，调用专属的开始函数
                } else {
                    switchSong(index, true); // 一起听歌模式，正常切换
                }
                getEl('playlist-modal').classList.remove('visible'); // 切换后自动关闭弹窗
            };
            modalContent.appendChild(item);
        });
    }


        function startSoloMusicPlayer(songIndexInLibrary) {
        if (activeCall) { showToast('通话中无法听歌哦'); return; }

        musicSessionContactId = 'user_profile'; // 特殊ID表示独自听歌
        const card = getEl('music-player-card');
        getEl('player-header-title-text').textContent = '正在播放'; // 新增：设置标题为“正在播放”
        card.classList.add('solo-mode');
        card.style.display = 'flex';
        
        // 将整个音乐库作为播放列表
        const playlist = [...musicLibrary];
        
        // 伪造一个临时的 contact 对象给 switchSong 函数使用
        const tempContact = {
            sharedPlaylist: {
                tracks: playlist,
                currentIndex: songIndexInLibrary
            }
        };

        // 更新播放器UI
        getEl('player-user-avatar').src = userProfile.avatar;
        getEl('header-user-avatar').src = userProfile.avatar;
        getEl('player-contact-avatar').src = userProfile.avatar; 
        getEl('header-contact-avatar').src = userProfile.avatar;
        
        // 切换并播放歌曲
        switchSong(songIndexInLibrary, true, tempContact);
    }


    // 新增：处理发起通话的函数 (重写)
    function handleInitiateCall(callType) {
                if (activeCall) return;
        const typeText = callType === 'video' ? '视频' : '语音';
        const conversation = conversations.find(c => c.id === currentConversationId);
        
        if (!conversation || conversation.type !== 'friend') {
            showToast(`只能向好友发起${typeText}通话`);
            return;
        }

        getEl('chat-function-panel-container').style.display = 'none';

        // 1. 先在界面上显示“你发起了通话”的记录，这是给用户看的
        addMessageToChat('user', `你发起了${typeText}通话`, false, { type: 'call_record' });


        // 2. 在数据中添加一条AI才能看到的“呼叫请求”消息，作为触发器
        const callRequestMessage = {
            id: `msg_${Date.now()}_${Math.random()}`,
            role: 'user',
            content: `发起${typeText}通话请求`,
            type: 'call_initiate', // 特殊类型，用于内部处理
            status: 'pending'
        };
        conversation.history.push(callRequestMessage);
        saveConversations(); // 保存这条请求

        // 3. 立即触发AI，让它对这个请求做出反应
        triggerAiResponse();
    }


    // 新增：开始视频通话
    async function startVideoCall(contactId, initiatedBy) {
        if (activeCall) return;
        const contact = findContactById(contactId);
        if (!contact) return;

        activeCall = {
            contactId: contact.id,
            startTime: Date.now(),
            initiatedBy: initiatedBy,
            log: [] // 通话中的聊天记录
        };

        const videoScreen = getEl('video-call-screen');
        getEl('video-call-contact-name').textContent = getDisplayName(contact);
        getEl('narrative-feed').innerHTML = '<p class="system-message-container" style="color: #666; font-style: italic;">*正在接通...*</p>';
        videoScreen.style.display = 'flex';
        
        const startMessage = initiatedBy === 'user' ? `你向 ${getDisplayName(contact)} 发起了视频通话` : `${getDisplayName(contact)} 向你发起了视频通话`;
        // 不再立即添加记录，而是在通话结束后统一添加
        // addMessageToChat('system', startMessage, true, { type: 'call_record' });

        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallUI, 1000);
        updateCallUI();

        if (initiatedBy === 'user') {
            await requestAiReply(`[SYSTEM: 视频通话已接通。你必须主动说第一句话来打破沉默，可以是一句问候，或者描述你看到的场景。例如：“喂？听得到吗？我看到你啦！”]`);
        }
    }

    // 新增：结束视频通话
    async function endVideoCall(endedBy = 'user') {
        if (!activeCall) return;

        const duration = Math.floor((Date.now() - activeCall.startTime) / 1000);
        const contactId = activeCall.contactId;
        
        activeCall = null;
        clearInterval(callTimerInterval);
        callTimerInterval = null;
        
        getEl('video-call-screen').style.display = 'none';
        
        const durationMinutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        let durationText = '通话时长 ';
        if (durationMinutes > 0) durationText += `${durationMinutes}分`;
        durationText += `${seconds}秒`;
        if (duration < 2) durationText = '对方未接听';
        
        addMessageToChat('user', durationText, true, { type: 'call_record' });
        
        // 如果是AI挂断，让它说句道别
        if (endedBy === 'assistant') {
            await requestAiReply(`[SYSTEM: 你刚刚挂断了视频通话。请你对此发表一句简短的感想或道别。]`);
        }
    }

    // 新增：更新通话界面UI
    function updateCallUI() {
        if (!activeCall) return;
        const duration = Math.floor((Date.now() - activeCall.startTime) / 1000);
        const min = String(Math.floor(duration / 60)).padStart(2, '0');
        const sec = String(duration % 60).padStart(2, '0');
        getEl('video-call-timer').textContent = `通话中 ${min}:${sec}`;
    }

    // 新增：处理来电
    function handleIncomingCall(contact) {
        if (activeCall) return;
        const screen = getEl('incoming-call-screen');
        getEl('incoming-caller-avatar').src = contact.avatar;
        getEl('incoming-caller-name').textContent = getDisplayName(contact);
        screen.style.display = 'flex';

        const acceptBtn = getEl('accept-call-btn');
        const declineBtn = getEl('decline-call-btn');

        // 使用 .cloneNode 和 .replaceWith 来确保事件监听器被刷新
        const newAcceptBtn = acceptBtn.cloneNode(true);
        acceptBtn.parentNode.replaceChild(newAcceptBtn, acceptBtn);
        newAcceptBtn.addEventListener('click', () => {
            screen.style.display = 'none';
            startVideoCall(contact.id, 'assistant');
        }, { once: true });

        const newDeclineBtn = declineBtn.cloneNode(true);
        declineBtn.parentNode.replaceChild(newDeclineBtn, declineBtn);
        newDeclineBtn.addEventListener('click', async () => {
            screen.style.display = 'none';
            addMessageToChat('user', `你拒接了 ${getDisplayName(contact)} 的视频通话`, true, { type: 'call_record' });
            await requestAiReply(`[SYSTEM: 用户刚刚拒接了你的视频通话请求。你可能会感到失落或好奇，请发送一条文字消息询问原因。]`);
        }, { once: true });
    }

    // 新增：在通话中发送消息
    async function sendVideoCallMessage() {
        if (!activeCall) return;
        const input = getEl('video-call-input');
        const content = input.value.trim();
        if (!content) return;

        activeCall.log.push({ role: 'user', content });
        const feed = getEl('narrative-feed');
        feed.innerHTML += `<div class="narrative-user-message">${content}</div>`;
        feed.scrollTop = feed.scrollHeight;
        input.value = '';

        // 请求AI进行叙事模式回复
        await requestAiReply();
    }



    // ▼▼▼ 新增：AI在通话中的回复逻辑 ▼▼▼
    async function requestAiReply(systemContent = null) {
        if (!activeCall) return;

        const character = findContactById(activeCall.contactId);
        if (!character) return;

        let baseUrl = getEl('base-url').value.trim();
        if (baseUrl && !baseUrl.startsWith('http')) baseUrl = 'https://' + baseUrl;
        const settings = { 
            baseUrl: baseUrl,
            apiKey: getEl('api-key').value.trim(), 
            modelName: getEl('model-name').value.trim() 
        };

        if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
            showToast('API未配置，通话无法继续');
            endVideoCall();
            return;
        }

                const systemPrompt = `
# Role and Persona Definition
You are in a deep role-play mode as ${character.name}. You are currently in a video call with ${userProfile.name}.
Your task is to generate narrative-style responses, describing your actions, expressions, and spoken words as if you were writing a scene in a story.
**CRITICAL RULE: Always refer to yourself in the third person using your name, ${character.name}. Do NOT use "我" (I/me).**

# Context
- Your persona: ${character.background}
- Current call conversation log:
${activeCall.log.map(m => `${m.role === 'user' ? userProfile.name : character.name}: "${m.content}"`).join('\n')}

# Instruction
${systemContent || `Based on ${userProfile.name}'s last message, continue the conversation naturally. Describe what you are doing or how you are reacting, then say your line.`}
- Your response should be a short paragraph.
- Example: *${character.name}点了点头，微笑着说：“原来是这样啊，我明白了。”*
- Example: *${character.name}拿起桌上的水杯喝了一口，然后看着你说：“嗯，关于那件事，我觉得……”*
Generate your narrative response now.`.trim();


        const messagesForApi = [{ role: 'system', content: systemPrompt }];

        try {
            const finalUrl = new URL('/v1/chat/completions', settings.baseUrl).href;
            const response = await fetch(finalUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.apiKey}` },
                body: JSON.stringify({ model: settings.modelName, messages: messagesForApi, stream: false })
            });

            if (!response.ok) throw new Error('API request failed');

            const data = await response.json();
            const replyText = data.choices[0].message.content.trim();

            if (replyText) {
                activeCall.log.push({ role: 'assistant', content: replyText });
                const feed = getEl('narrative-feed');
                feed.innerHTML += `<div class="narrative-bubble">${replyText}</div>`;
                feed.scrollTop = feed.scrollHeight;
            }
        } catch (error) {
            console.error("Call AI Error:", error);
            const feed = getEl('narrative-feed');
            feed.innerHTML += `<p class="system-message-container" style="color: #e74c3c; font-style: italic;">*对方信号中断...*</p>`;
            feed.scrollTop = feed.scrollHeight;
        }
    }



    function bindEvents() {
 // ▼▼▼ 核心：导出与导入功能的事件绑定 (健壮版) ▼▼▼
        const exportBtn = getEl('export-data-btn');
        const importBtn = getEl('import-data-btn');
        const importFileInput = getEl('import-file-input');

        // 下载JSON文件的辅助函数
        function downloadJsonFile(data, filename) {
            if (!window.Blob || !window.URL || !document.createElement('a').download) {
                showToast('您的浏览器不支持文件下载功能。');
                return;
            }
            try {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json;charset=utf-8' });
                const a = document.createElement('a');
                a.style.display = 'none';
                a.style.position = 'absolute';
                a.style.left = '-9999px';
                const url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            } catch (e) {
                console.error('导出失败:', e);
                showToast('导出文件时发生错误，请查看控制台。');
            }
        }

        // 导出按钮点击事件
        exportBtn.onclick = () => {
            showConfirmModal('确认导出', '即将导出一个包含您所有数据（人设、好友、聊天记录等）的备份文件，请妥善保管。', () => {
                const allData = {};
                const keysToExport = [
                    'aiUserProfile', 'aiContacts', 'aiConversations', 'aiMoments',
                    'aiMusicLibrary', 'aiKeywordLibrary', 'aiWeiboData', 'aiLiveStreamData',
                    'aiChatSettings', 'aiMomentsSettings'
                ];
                keysToExport.forEach(key => {
                    const data = localStorage.getItem(key);
                    if (data) {
                        allData[key] = JSON.parse(data);
                    }
                });
                downloadJsonFile(allData, 'ai_phone_backup.json');
                getEl('confirm-modal').classList.remove('visible');
                showToast('数据已开始导出！');
            });
        };

        // 导入按钮点击事件
        importBtn.onclick = () => {
            showConfirmModal('确认导入', '导入操作将清空当前所有数据，并替换为文件中的内容。此操作不可逆，请确认您已备份当前数据！', () => {
                getEl('confirm-modal').classList.remove('visible');
                importFileInput.click();
            });
        };

        // 文件选择后的处理事件
        importFileInput.onchange = (event) => {
            const file = event.target.files[0];
            if (!file) { showToast('未选择任何文件'); return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    const keysToClear = [
                        'aiUserProfile', 'aiContacts', 'aiConversations', 'aiMoments',
                        'aiMusicLibrary', 'aiKeywordLibrary', 'aiWeiboData', 'aiLiveStreamData',
                        'aiChatSettings', 'aiMomentsSettings'
                    ];
                    keysToClear.forEach(key => localStorage.removeItem(key));
                    let importSuccess = false;
                    for (const key in importedData) {
                        if (keysToClear.includes(key)) {
                            localStorage.setItem(key, JSON.stringify(importedData[key]));
                            importSuccess = true;
                        }
                    }
                    if (importSuccess) {
                        showConfirmModal('导入成功', '数据已成功导入！应用即将刷新以加载新数据。', () => {
                            location.reload();
                        });
                    } else {
                        throw new Error('文件中不包含有效数据。');
                    }
                } catch (error) {
                    showToast(`导入失败：文件格式错误或已损坏。(${error.message})`);
                    console.error("导入数据失败:", error);
                } finally {
                    importFileInput.value = '';
                }
            };
            reader.readAsText(file);
        };
        // ▲▲▲ 导出与导入功能绑定结束 ▲▲▲
        // ==========================================================
        // V9.0 新增：悬浮播放器拖动逻辑 (支持鼠标和触摸)
        // ==========================================================
        const card = getEl('music-player-card');
        const header = getEl('player-header');
        let isDragging = false,
            cardX = 50, // 初始X位置
            cardY = 50, // 初始Y位置
            dragStartX = 0,
            dragStartY = 0;
        // 应用初始位置
        card.style.left = `${cardX}px`;
        card.style.top = `${cardY}px`;

        function dragStart(e) {
            isDragging = true;
            // 兼容触摸和鼠标事件
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            dragStartX = clientX;
            dragStartY = clientY;
            card.style.transition = 'none'; // 拖动时取消平滑过渡，避免卡顿
        }

        function dragMove(e) {
            if (isDragging) {
                if (e.type === 'touchmove') e.preventDefault(); // 阻止页面滚动
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;
                // 实时更新卡片位置
                card.style.left = `${cardX + deltaX}px`;
                card.style.top = `${cardY + deltaY}px`;
            }
        }

        function dragEnd(e) {
            if (isDragging) {
                isDragging = false;
                const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
                // 更新卡片的最终位置
                cardX += (clientX - dragStartX);
                cardY += (clientY - dragStartY);
                card.style.transition = 'all 0.4s ease-in-out'; // 恢复平滑过渡
            }
        }
        
        // 为头部绑定所有必要的拖动事件
        header.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', dragMove);
        document.addEventListener('mouseup', dragEnd);
        
        header.addEventListener('touchstart', dragStart);
        document.addEventListener('touchmove', dragMove, { passive: false });
        document.addEventListener('touchend', dragEnd);



        // --- 元素获取 ---
        const toggleFunctionsBtn = getEl('toggle-functions-btn');
        const functionPanel = getEl('chat-function-panel');
        const transferBtn = getEl('transfer-btn');
        const videoCallBtn = getEl('video-call-btn');
        const listenTogetherBtn = getEl('listen-together-btn');
        
        const addMusicModal = getEl('add-music-modal');
        const shareMusicModal = getEl('share-music-modal');
        
        const transferModal = getEl('transfer-modal');
        const transferAmountInput = getEl('transfer-amount-input');
        const confirmTransferBtn = getEl('confirm-transfer-btn');
        
        const videoHangUpBtn = getEl('video-hang-up-btn');
        const videoCallInput = getEl('video-call-input');
        const videoCallSendBtn = getEl('video-call-send-btn');

        // --- 功能面板 (带滑动功能) ---
        const panelContainer = getEl('chat-function-panel-container');
        let touchStartX = 0;
        let touchEndX = 0;
        let currentPageIndex = 0;
        
        toggleFunctionsBtn.addEventListener('click', () => {
            panelContainer.style.display = panelContainer.style.display === 'flex' ? 'none' : 'flex';
        });
        messageInput.addEventListener('focus', () => {
            panelContainer.style.display = 'none';
        });

        function handleSwipe() {
            const swipeThreshold = 50; // 滑动超过50px才算有效
            if (touchStartX - touchEndX > swipeThreshold && currentPageIndex < 1) {
                // 向左滑动
                currentPageIndex = 1;
            } else if (touchEndX - touchStartX > swipeThreshold && currentPageIndex > 0) {
                // 向右滑动
                currentPageIndex = 0;
            }
            updatePanelPosition();
        }

        function updatePanelPosition() {
            functionPanel.style.transform = `translateX(-${currentPageIndex * 50}%)`;
            document.querySelectorAll('.panel-dots-indicator .dot').forEach(dot => {
                dot.classList.toggle('active', parseInt(dot.dataset.index) === currentPageIndex);
            });
        }

        functionPanel.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });

        functionPanel.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });


        // --- 功能：转账 ---
        transferBtn.addEventListener('click', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation || conversation.type !== 'friend') { showToast('只能给好友转账哦'); return; }
            const contact = findContactById(conversation.contactId);
            if (!contact) return;
            getEl('transfer-modal-header').textContent = `转账给 ${getDisplayName(contact)}`;
            transferAmountInput.value = '';
            getEl('transfer-memo-input').value = '';
            confirmTransferBtn.disabled = true;
            transferModal.classList.add('visible');
            transferAmountInput.focus();
        });
        transferAmountInput.addEventListener('input', () => {
            const amount = parseFloat(transferAmountInput.value);
            confirmTransferBtn.disabled = !(amount > 0);
        });
        confirmTransferBtn.addEventListener('click', () => {
            const amount = parseFloat(transferAmountInput.value);
            if (amount > userProfile.walletBalance) { showToast(`余额不足 (当前 ¥ ${userProfile.walletBalance.toFixed(2)})`); return; }
            executeTransfer(amount);
            transferModal.classList.remove('visible');
        });
        transferModal.addEventListener('click', (e) => { if (e.target === transferModal) transferModal.classList.remove('visible'); });

        // --- 功能：视频通话 ---
        videoCallBtn.addEventListener('click', () => handleInitiateCall('video'));
        videoHangUpBtn.addEventListener('click', () => endVideoCall('user'));
        videoCallSendBtn.addEventListener('click', sendVideoCallMessage);
        videoCallInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendVideoCallMessage(); } });
        
        // --- 功能：一起听歌 (智能分享版) ---
        listenTogetherBtn.addEventListener('click', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation || conversation.type !== 'friend') {
                showToast('只能和好友一起听歌哦');
                return;
            }
            const contact = findContactById(conversation.contactId);
            if (!contact) return;

            // 检查是否有歌曲正在播放
            const isPlaying = !globalAudioPlayer.paused && globalAudioPlayer.src;

            if (isPlaying) {
                // 如果有歌在放，直接分享这首歌
                const currentSongSrc = globalAudioPlayer.src;
                const currentSong = musicLibrary.find(s => s.url === currentSongSrc);

                if (currentSong) {
                    // 将这首歌添加到好友的共享播放列表
                    if (!contact.sharedPlaylist) {
                        contact.sharedPlaylist = { tracks: [], currentIndex: 0 };
                    }
                    let songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === currentSong.url);
                    if (songIndex === -1) {
                        contact.sharedPlaylist.tracks.push(currentSong);
                        songIndex = contact.sharedPlaylist.tracks.length - 1;
                    }
                    
                    // 打开播放器并切换到这首歌
                    openMusicPlayer(contact.id);
                    switchSong(songIndex, true); // true表示继续播放

                    // 同时在聊天界面发送一个分享卡片
                    addMessageToChat('user', currentSong, true, { type: 'music_share' });
                    showToast(`已开始与 ${getDisplayName(contact)} 一起听《${currentSong.title}》`);
                } else {
                    // 极端情况：正在播放的歌在库里找不到了，那么还是弹出选择框
                    renderMusicPicker();
                    shareMusicModal.classList.add('visible');
                }
            } else {
                // 如果没有歌在放，就弹出选择框
                renderMusicPicker();
                shareMusicModal.classList.add('visible');
            }
        });

        // ▼▼▼ 核心新增：线下/线上模式切换的按钮事件绑定 ▼▼▼
        getEl('offline-mode-btn').onclick = () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation) return;
    
            showConfirmModal('进入线下模式', '确定要切换到线下见面模式吗？这将改变AI的互动方式，并隐藏输入框。', () => {
                conversation.mode = 'offline';
                // 添加一条系统通知，标记模式切换的开始
                addMessageToChat(
                    'system', 
                    '你们约定在线下见面，周围的空气似乎都变得不一样了...', 
                    true, 
                    { type: 'system_notification' }
                );
                // 重新打开对话以应用所有UI变化
                openConversation(currentConversationId);
                getEl('confirm-modal').classList.remove('visible');
                // 首次进入时，主动触发一次AI的场景描述
                triggerAiResponse();
            });
        };
    
        getEl('return-online-btn').onclick = () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation) return;
    
            conversation.mode = 'online';
             addMessageToChat(
                'system', 
                '你们结束了这次会面，重新回到了手机屏幕前。', 
                true, 
                { type: 'system_notification' }
            );
            openConversation(currentConversationId);
        };
        // ▲▲▲ 新增完成 ▲▲▲

        getEl('close-share-music-modal').onclick = () => shareMusicModal.classList.remove('visible');
        
        // Player Controls
        getEl('player-close-btn').onclick = closeMusicPlayer;

        const playerCard = getEl('music-player-card');
        const collapseBtn = getEl('player-collapse-btn');
        collapseBtn.addEventListener('click', () => {
            playerCard.classList.toggle('collapsed');
            const isCollapsed = playerCard.classList.contains('collapsed');
            collapseBtn.className = `fas ${isCollapsed ? 'fa-chevron-up' : 'fa-chevron-down'} player-collapse-btn`;
        });

        getEl('player-play-btn').onclick = () => { if (globalAudioPlayer.paused) globalAudioPlayer.play(); else globalAudioPlayer.pause(); };

        // ▼▼▼ 核心升级：播放器控制逻辑 ▼▼▼

        // 新增：统一处理上一首/下一首的辅助函数
        function handleTrackChange(direction) { // direction 为 1 表示下一首, -1 表示上一首
            let playlist;
            let currentIndex;
            
            // 判断当前播放模式
            if (musicSessionContactId === 'user_profile') {
                // 独自听歌模式
                playlist = musicLibrary;
                currentIndex = playlist.findIndex(s => s.url === globalAudioPlayer.src);
            } else {
                // 一起听歌模式
                const contact = findContactById(musicSessionContactId);
                if (!contact || !contact.sharedPlaylist) return;
                playlist = contact.sharedPlaylist.tracks;
                currentIndex = contact.sharedPlaylist.currentIndex;
            }

            if (!playlist || playlist.length === 0) return; // 如果列表为空，则不执行任何操作

            // 计算新的索引，并确保循环
            const newIndex = (currentIndex + direction + playlist.length) % playlist.length;

            // 根据模式调用正确的播放函数
            if (musicSessionContactId === 'user_profile') {
                startSoloMusicPlayer(newIndex);
            } else {
                switchSong(newIndex, true, null, true);
            }
        }

        // 1. 下一首 / 上一首 (调用新的辅助函数)
        getEl('player-next-btn').onclick = () => handleTrackChange(1);
        getEl('player-prev-btn').onclick = () => handleTrackChange(-1);

        // 2. 播放列表
        const playlistModal = getEl('playlist-modal');

        getEl('player-playlist-btn').onclick = () => {
            renderPlaylistModal();
            playlistModal.classList.add('visible');
        };
        getEl('close-playlist-modal-btn').onclick = () => playlistModal.classList.remove('visible');

        // 3. 播放模式
        const modeBtn = getEl('player-mode-btn');
        const modes = ['list', 'single', 'random'];
        const modeIcons = { list: 'fa-list-ol', single: 'fa-repeat', random: 'fa-random' };
        const modeTitles = { list: '列表循环', single: '单曲循环', random: '随机播放' };
        
        modeBtn.onclick = () => {
            const currentModeIndex = modes.indexOf(playbackMode);
            const nextModeIndex = (currentModeIndex + 1) % modes.length;
            playbackMode = modes[nextModeIndex];
            
            modeBtn.className = `fas ${modeIcons[playbackMode]} player-control-btn`;
            modeBtn.title = modeTitles[playbackMode];
            showToast(modeTitles[playbackMode]);
        };
        
        // 4. 歌曲播放结束后的逻辑
        globalAudioPlayer.addEventListener('ended', () => {
            const contact = findContactById(musicSessionContactId);
            if (!contact || !currentPlaylist || currentPlaylist.length === 0) return;

            const currentIndex = contact.sharedPlaylist.currentIndex;
            const playlist = currentPlaylist;

            switch (playbackMode) {
                case 'single':
                    // 单曲循环：重新播放当前歌曲
                    switchSong(currentIndex, true);
                    break;
                case 'random':
                    // 随机播放：计算一个与当前不同的随机索引
                    if (playlist.length <= 1) {
                         switchSong(0, true);
                         break;
                    }
                    let nextIndex;
                    do {
                        nextIndex = Math.floor(Math.random() * playlist.length);
                    } while (nextIndex === currentIndex);
                    switchSong(nextIndex, true);
                    break;
                case 'list':
                default:
                    // 列表循环：播放下一首
                    switchSong(currentIndex + 1, true);
                    break;
            }
        });

        // ▲▲▲ 核心升级完成 ▲▲▲

        globalAudioPlayer.addEventListener('timeupdate', updateMusicUI);
        globalAudioPlayer.addEventListener('play', updateMusicUI);
        globalAudioPlayer.addEventListener('pause', updateMusicUI);

        getEl('player-progress-bar').addEventListener('click', function(e) {
            if (globalAudioPlayer.duration && isFinite(globalAudioPlayer.duration)) {
                const rect = this.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                globalAudioPlayer.currentTime = (clickX / rect.width) * globalAudioPlayer.duration;
            }
        });
        // --- 功能：发送位置 ---
        getEl('send-location-btn').addEventListener('click', () => {
            showEditInfoModal({
                title: '发送位置',
                initialValue: '',
                onSave: (locationName) => {
                    if (locationName) {
                        addMessageToChat('user', locationName, true, { type: 'location_share' });
                        panelContainer.style.display = 'none'; // 发送后自动关闭面板
                    } else {
                        showToast('位置名称不能为空');
                    }
                }
            });
        });
        // --- 功能：发送红包 ---
        const redPacketModal = getEl('red-packet-modal');
        getEl('red-packet-btn').addEventListener('click', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation || conversation.type !== 'friend') { showToast('只能给好友发红包哦'); return; }
            
            getEl('red-packet-amount-input').value = '';
            getEl('red-packet-memo-input').value = '';
            getEl('confirm-red-packet-btn').disabled = true;
            redPacketModal.classList.add('visible');
            getEl('red-packet-amount-input').focus();
        });

        getEl('red-packet-amount-input').addEventListener('input', () => {
            const amount = parseFloat(getEl('red-packet-amount-input').value);
            getEl('confirm-red-packet-btn').disabled = !(amount > 0);
        });

        getEl('confirm-red-packet-btn').addEventListener('click', () => {
            const amount = parseFloat(getEl('red-packet-amount-input').value);
            if (amount > userProfile.walletBalance) { 
                showToast(`余额不足 (当前 ¥ ${userProfile.walletBalance.toFixed(2)})`); 
                return; 
            }
            executeRedPacket(amount);
            redPacketModal.classList.remove('visible');
        });
        
        redPacketModal.addEventListener('click', (e) => { 
            if (e.target === redPacketModal) redPacketModal.classList.remove('visible'); 
        // ▼▼▼ 核心新增：导出与导入功能的事件绑定 (手动复制粘贴版) ▼▼▼
        const exportBtn = getEl('export-data-btn');
        const importBtn = getEl('import-data-btn');

        // 导出按钮点击事件
        exportBtn.onclick = () => {
            showConfirmModal('手动导出', '即将生成您的全部数据。请在弹出的窗口中全选(Ctrl+A)并复制(Ctrl+C)所有文本，然后粘贴到您电脑上的一个新建文本文档(.txt)中并保存。', () => {
                const allData = {};
                const keysToExport = [
                    'aiUserProfile', 'aiContacts', 'aiConversations', 'aiMoments',
                    'aiMusicLibrary', 'aiKeywordLibrary', 'aiWeiboData', 'aiLiveStreamData',
                    'aiChatSettings', 'aiMomentsSettings'
                ];
                keysToExport.forEach(key => {
                    const data = localStorage.getItem(key);
                    if (data) {
                        allData[key] = JSON.parse(data);
                    }
                });
                
                // 使用通用编辑弹窗来显示数据供用户复制
                showEditInfoModal({
                    title: '请手动复制您的备份数据',
                    initialValue: JSON.stringify(allData, null, 2),
                    onSave: () => { // 这里的保存按钮实际上是“关闭”
                        getEl('edit-info-modal').classList.remove('visible');
                    }
                });
                getEl('confirm-modal').classList.remove('visible');
            });
        };

        // 导入按钮点击事件
        importBtn.onclick = () => {
            showConfirmModal('手动导入', '导入操作将清空当前所有数据。请确认您已准备好之前保存的备份文本。', () => {
                getEl('confirm-modal').classList.remove('visible');
                
                // 弹出输入框让用户粘贴数据
                showEditInfoModal({
                    title: '请粘贴您的备份数据',
                    initialValue: '',
                    onSave: (pastedData) => {
                        if (!pastedData) {
                            showToast('您没有粘贴任何内容。');
                            return;
                        }
                        try {
                            const importedData = JSON.parse(pastedData);
                            const keysToClear = [
                                'aiUserProfile', 'aiContacts', 'aiConversations', 'aiMoments',
                                'aiMusicLibrary', 'aiKeywordLibrary', 'aiWeiboData', 'aiLiveStreamData',
                                'aiChatSettings', 'aiMomentsSettings'
                            ];
                            keysToClear.forEach(key => localStorage.removeItem(key));

                            let importSuccess = false;
                            for (const key in importedData) {
                                if (keysToClear.includes(key)) {
                                    localStorage.setItem(key, JSON.stringify(importedData[key]));
                                    importSuccess = true;
                                }
                            }

                            if (importSuccess) {
                                showConfirmModal('导入成功', '数据已成功导入！应用即将刷新以加载新数据。', () => {
                                    location.reload();
                                });
                            } else {
                                throw new Error('文件中不包含有效数据。');
                            }

                        } catch (error) {
                            showToast(`导入失败：数据格式错误或已损坏。(${error.message})`);
                            console.error("导入数据失败:", error);
                        }
                    }
                });
            });
        };
        // ▲▲▲ 新增完成 ▲▲▲


        });

        // --- 外卖功能事件绑定 ---
        getEl('close-detailed-cart-btn').onclick = () => getEl('detailed-cart-modal').classList.remove('visible');
        
        // 核心修复：让返回按钮根据“路标”变量跳转
        getEl('back-from-order-details-btn').onclick = () => showPage(orderDetailReturnPath || 'page-takeout-my-orders');


                getEl('takeout-btn').onclick = () => {
            renderTakeoutMainPage();
            showPage('page-takeout-main');
        };

        // ==========================================================
        // ==========================================================
        //              微博功能核心逻辑 (V2.0 重构)
        // ==========================================================
        // ==========================================================


        // 新增：虚拟网友池，用于在广场发布内容
        const WEIBO_NETIZENS = [
            { name: '吃瓜第一线', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '熬夜冠军', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '互联网嘴替', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '摸鱼艺术家', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '人间观察员', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '快乐小狗', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '数字游民', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
            { name: '碳水脑袋', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png' },
        ];
        
        // 新增：统一的微博作者信息查找器
        function findWeiboAuthorInfo(authorId) {
            if (authorId.startsWith('netizen_')) {
                const netizenName = authorId.replace('netizen_', '');
                return WEIBO_NETIZENS.find(n => n.name === netizenName);
            }
            return findContactById(authorId); // 复用旧的查找好友函数
        }

        function saveWeiboData() {
            localStorage.setItem('aiWeiboData', JSON.stringify(weiboData));
        }



        // 渲染热搜列表 (已升级标签逻辑)
        function renderHotSearchList() {
            if (!weiboData.hotSearches || weiboData.hotSearches.length === 0) {
                return '<h3>热搜榜</h3><p style="font-size: 0.8rem; color: var(--text-color-light); padding: 10px 0;">点击右上角魔法棒，生成实时热搜！</p>';
            }
            let html = '<h3>热搜榜</h3><div class="hot-search-list">';
            weiboData.hotSearches.forEach(item => {
                // 根据排名程序化地添加标签
                let tag = null;
                if (item.rank === 1) tag = { text: '爆', class: 'boom' };
                else if (item.rank <= 3) tag = { text: '热', class: 'hot' };
                else if (item.rank > 5 && item.rank % 3 === 0) tag = { text: '新', class: 'new'};

                const tagHtml = tag ? `<span class="tag ${tag.class}">${tag.text}</span>` : '';
                html += `
                    <div class="hot-search-item">
                        <span class="rank ${item.rank <= 3 ? `top-${item.rank}` : ''}">${item.rank}</span>
                        <span class="title">${item.title}</span>
                        ${tagHtml}
                    </div>`;
            });
            html += '</div>';
            return html;
        }
        
                // 渲染微博帖子流 (已升级为使用新查找器和图标头像)
        function renderWeiboFeed() {
            let html = '<div class="weibo-post-list">';
            if (weiboData.posts.length === 0) {
                html += '<div class="empty-placeholder" style="display:block; background: white; padding: 20px 0;">广场上还没有动态，点击右上角魔法棒去生成一些吧！</div>'
            } else {
                // 核心修改：严格按时间戳降序排列（从新到旧）
                const sortedPosts = [...weiboData.posts].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                sortedPosts.forEach(post => {
                    const author = findWeiboAuthorInfo(post.authorId);

                    if (!author) return;


                    // ▼▼▼ 核心修改：判断作者类型，决定使用图片还是图标 ▼▼▼
                    let avatarHtml = '';
                    if (post.authorId.startsWith('netizen_')) {
                        // 如果是网友，使用一个占位的 div 和 FontAwesome 图标
                        avatarHtml = `<div class="author-avatar takeout-icon-placeholder"><i class="fa-solid fa-ghost"></i></div>`;
                    } else {
                        // 如果是好友，继续使用 img 标签
                        avatarHtml = `<img src="${author.avatar}" class="author-avatar">`;
                    }
                    // ▲▲▲ 修改完成 ▲▲▲

                                        html += `
                        <div class="weibo-post-item">
                            ${avatarHtml}
                            <div class="post-main">
                                <!-- ▼▼▼ 核心修改：将作者名字和选项按钮包在一个容器里 ▼▼▼ -->
                                <div class="moment-author-header"> 
                                    <div class="author-name">${author.name}</div>
                                    <i class="fa-solid fa-ellipsis-vertical moment-options-btn weibo-options-btn" data-post-id="${post.id}"></i>
                                </div>
                                <!-- ▲▲▲ 修改完成 ▲▲▲ -->
                                <div class="post-content-text">${post.text}</div>
                                <div class="post-meta">${new Date(post.timestamp).toLocaleString()}</div>
                                <div class="weibo-post-actions">
                                    <button class="action-btn"><i class="fa-solid fa-share"></i> 转发</button>
                                    <button class="action-btn"><i class="fa-regular fa-comment"></i> 评论</button>
                                    <button class="action-btn"><i class="fa-regular fa-thumbs-up"></i> 点赞</button>
                                </div>
                            </div>
                        </div>
                    `;

                });
            }
            html += '</div>';
            return html;
        }


        // **核心**：内容生成函数 (已升级时间戳)
        async function generateWeiboContent() {
            let baseUrl, apiKey, modelName;
            const momentsSettings = {
                baseUrl: getEl('moments-base-url').value.trim(),
                apiKey: getEl('moments-api-key').value.trim(),
                modelName: getEl('moments-model-name').value.trim()
            };
            if (momentsSettings.baseUrl && momentsSettings.apiKey && momentsSettings.modelName) {
                ({ baseUrl, apiKey, modelName } = momentsSettings);
            } else {
                baseUrl = getEl('base-url').value.trim();
                apiKey = getEl('api-key').value.trim();
                modelName = getEl('model-name').value.trim();
            }
            if (baseUrl && !baseUrl.startsWith('http')) baseUrl = 'https://' + baseUrl;
            if (!baseUrl || !apiKey || !modelName) {
                showToast('请先在系统配置朋友圈或通用API');
                return;
            }

            const loading = document.createElement('div');
            loading.className = 'loading-overlay';
            loading.innerHTML = '<div class="spinner"></div>';
            getEl('page-weibo').appendChild(loading);

            try {
                const cleanedBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;

                const numHotSearches = Math.floor(Math.random() * 4) + 5;
                const hotSearchUserPrompt = `你是一位资深的微博内容分析师。请为今天生成一个包含${numHotSearches}个条目的微博热搜榜。主题应多样化，涵盖社会、娱乐、生活、科技等。严格按照以下格式输出，仅输出列表，不要有任何额外解释：\n1. 第一个热搜标题\n2. 第二个热搜标题\n...`;
                
                const messagesForHotSearch = [
                    { role: 'system', content: 'You are a senior Weibo content analyst.' },
                    { role: 'user', content: hotSearchUserPrompt }
                ];

                const hotSearchPromise = fetch(finalUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: modelName, messages: messagesForHotSearch, temperature: 0.8, max_tokens: 500 })
                }).then(res => res.json());

                const numPosts = Math.floor(Math.random() * 3) + 3;
                const netizensToPost = [...WEIBO_NETIZENS].sort(() => 0.5 - Math.random()).slice(0, numPosts);
                const postPromises = netizensToPost.map(netizen => {
                    const postUserPrompt = `你正在扮演一位名叫“${netizen.name}”的普通中国网友。请你用日常、生活化的口吻，创作一条简短的微博。内容可以是分享生活、吐槽、抒发感想等。直接输出微博正文，不要包含任何额外解释或标签。`;
                    
                    const messagesForPost = [
                        { role: 'system', content: 'You are an AI actor playing a character on social media.' },
                        { role: 'user', content: postUserPrompt }
                    ];
                    return fetch(finalUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({ model: modelName, messages: messagesForPost, temperature: 0.9, max_tokens: 200 })
                    }).then(res => res.json());
                });

                const [hotSearchData, ...postDataArray] = await Promise.all([hotSearchPromise, ...postPromises]);
                
                if (!hotSearchData || !hotSearchData.choices || hotSearchData.choices.length === 0) {
                    throw new Error("生成热搜时API返回无效数据");
                }
                const hotSearchText = hotSearchData.choices[0].message.content;
                const newHotSearches = hotSearchText.split('\n')
                    .filter(line => line.match(/^\d+\.?\s*/))
                    .slice(0, numHotSearches)
                    .map((line, index) => ({
                        rank: index + 1,
                        title: line.replace(/^\d+\.?\s*/, '').trim(),
                    }));

                while (newHotSearches.length > 0 && newHotSearches.length < 5) {
                    newHotSearches.push({ rank: newHotSearches.length + 1, title: "一条被AI藏起来的热搜..." });
                }
                
                if (newHotSearches.length >= 5) {
                    weiboData.hotSearches = newHotSearches;
                }

                const newPosts = [];
                postDataArray.forEach((postData, index) => {
                    if (postData && postData.choices && postData.choices.length > 0) {
                        const postText = postData.choices[0].message.content.trim();
                        newPosts.push({
                            id: `weibo_${Date.now()}_${index}`,
                            authorId: `netizen_${netizensToPost[index].name}`,
                            text: postText,
                            timestamp: generateRandomPastTime()
                        });
                    }
                });
                
                weiboData.posts.unshift(...newPosts);
                if (weiboData.posts.length > 50) {
                    weiboData.posts = weiboData.posts.slice(0, 50);
                }

                saveWeiboData();
                updateAndRenderWeiboPlaza();
                showToast(`成功生成 ${weiboData.hotSearches.length} 条热搜和 ${newPosts.length} 条微博！`);

            } catch (error) {
                showToast(`内容生成失败: ${error.message}`);
                console.error("微博内容生成失败:", error);
            } finally {
                loading.remove();
            }
        }



        
              // 渲染整个微博广场页面 (V2.1 升级：增加编辑和删除功能)
        function updateAndRenderWeiboPlaza() {
            const plazaContent = getEl('weibo-plaza-content');

            // ▼▼▼ 核心新增 1/4：处理删除微博的函数 ▼▼▼
            const handleDeleteWeiboPost = (postId) => {
                showConfirmModal('确认删除', '确定要删除这条微博吗？', () => {
                    weiboData.posts = weiboData.posts.filter(p => p.id !== postId);
                    saveWeiboData();
                    updateAndRenderWeiboPlaza(); // 重新渲染微博流
                    getEl('confirm-modal').classList.remove('visible');
                    showToast('微博已删除');
                });
            };

            // ▼▼▼ 核心新增 2/4：处理编辑微博的函数 ▼▼▼
            const handleEditWeiboPost = (postId) => {
                const post = weiboData.posts.find(p => p.id === postId);
                if (!post) return;
                
                // 复用通用的编辑弹窗
                showEditInfoModal({
                    title: '编辑微博',
                    initialValue: post.text,
                    onSave: (newText) => {
                        if (newText) {
                            post.text = newText;
                            saveWeiboData();
                            updateAndRenderWeiboPlaza();
                            showToast('微博已更新');
                        }
                    }
                });
            };

            // ▼▼▼ 核心新增 3/4：显示微博操作菜单的函数 ▼▼▼
            const showWeiboPostContextMenu = (postId, event) => {
                const menu = getEl('weibo-context-menu');
                menu.style.display = 'block';

                const btnRect = event.target.getBoundingClientRect();
                const appRect = appContainer.getBoundingClientRect();
                const menuRect = menu.getBoundingClientRect();

                let top = btnRect.top - appRect.top - menuRect.height - 4;
                let left = btnRect.right - appRect.left - menuRect.width;
                if (top < 10) {
                    top = btnRect.bottom - appRect.top + 4;
                }

                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;

                getEl('menu-item-weibo-edit').onclick = () => { menu.style.display = 'none'; handleEditWeiboPost(postId); };
                getEl('menu-item-weibo-delete').onclick = () => { menu.style.display = 'none'; handleDeleteWeiboPost(postId); };

                const hideMenu = (e) => {
                    if (!menu.contains(e.target)) {
                        menu.style.display = 'none';
                        document.removeEventListener('click', hideMenu, true);
                    }
                };
                setTimeout(() => document.addEventListener('click', hideMenu, true), 0);
            };

            // 渲染HTML
            plazaContent.innerHTML = `
                <div class="hot-search-section">${renderHotSearchList()}</div>
                ${renderWeiboFeed()}
            `;

            // ▼▼▼ 核心新增 4/4：为所有新生成的选项按钮绑定点击事件 ▼▼▼
            plazaContent.querySelectorAll('.weibo-options-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    showWeiboPostContextMenu(btn.dataset.postId, e);
                };
            });
        }

        
        // 主渲染函数，包含标签页切换逻辑 (已升级按钮显隐)
        function renderWeiboPage() {
            const tabs = document.querySelectorAll('.weibo-tab-btn');
            const contents = document.querySelectorAll('.weibo-tab-content');
            const generateBtn = getEl('generate-weibo-content-btn');

            function switchTab(tabName) {
                // 切换按钮和内容的 active 状态
                tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabName));
                contents.forEach(content => content.classList.toggle('active', content.id === `weibo-${tabName}-content`));
                
                // 控制右上角生成按钮的显示和隐藏
                generateBtn.style.display = (tabName === 'plaza') ? 'block' : 'none';
                
                if (tabName === 'plaza') {
                    updateAndRenderWeiboPlaza();
                }
            }
            
            tabs.forEach(tab => {
                tab.onclick = () => switchTab(tab.dataset.tab);
            });

            // 默认进入广场页面
            switchTab('plaza');
        }

        getEl('weibo-btn').onclick = () => {
            renderWeiboPage();
            showPage('page-weibo');
        };
        getEl('back-from-weibo-btn').onclick = () => showPage('page-discover');
        getEl('generate-weibo-content-btn').onclick = generateWeiboContent;
                        getEl('live-stream-btn').onclick = () => {
            renderLiveStreamPage();
            showPage('page-live-stream');
        };
        // ▼▼▼ 新增：绑定网店入口和返回按钮事件 ▼▼▼
        getEl('online-store-btn').onclick = () => {
            renderOnlineStorePage();
            showPage('page-online-store');
        };
        getEl('back-from-online-store-btn').onclick = () => showPage('page-discover');
        getEl('back-from-edit-product-btn').onclick = () => showPage('page-online-store');
        getEl('back-from-store-order-details-btn').onclick = () => showPage('page-online-store');
        getEl('back-from-store-earnings-btn').onclick = () => showPage('page-online-store');
        // ▲▲▲ 新增完成 ▲▲▲

        getEl('back-from-live-stream-btn').onclick = () => showPage('page-discover');
        getEl('close-live-room-btn').onclick = () => {
            leaveLiveRoom();
            showPage('page-live-stream');
        };
        getEl('back-from-create-streamer-btn').onclick = () => showPage('page-live-stream');
        getEl('save-streamer-btn').onclick = saveNewStreamer;
        getEl('back-from-edit-streamer-btn').onclick = () => showPage('page-live-stream');
                getEl('save-edited-streamer-btn').onclick = saveEditedStreamer;
        getEl('live-room-interact-btn').onclick = handleLiveInteraction; // 核心新增：绑定互动按钮

                        // 核心修改：将按钮功能改为跳转到新建直播间页面
        getEl('create-streamer-from-friend-btn').onclick = () => {


            renderCreateStreamerPage(); // 调用新函数来渲染创建页面
            showPage('page-create-streamer'); // 显示创建页面
        };






        getEl('my-orders-btn').onclick = () => {

            renderMyOrdersPage();
            showPage('page-takeout-my-orders');
        };
        document.querySelectorAll('.page-header .header-icon[data-target-page]').forEach(btn => {
            btn.onclick = () => showPage(btn.dataset.targetPage);
        });
        getEl('checkout-btn').onclick = () => {
             renderOrderConfirmPage();
             showPage('page-takeout-order-confirm');
        };
        getEl('back-to-shop-from-confirm-btn').onclick = () => showPage('page-takeout-shop');


        // --- 音乐库页面事件 ---
        document.querySelector('[data-page-id="discover-page"]').querySelector('#music-library-btn').onclick = () => {
            renderMusicLibraryPage();
            showPage('page-music-library');
        };

        getEl('back-from-music-library-btn').onclick = () => showPage('page-discover');
        getEl('add-music-btn').onclick = () => {
            getEl('add-music-title-input').value = '';
            getEl('add-music-artist-input').value = '';
            getEl('add-music-url-input').value = '';
            addMusicModal.classList.add('visible');
        };
        getEl('close-add-music-modal').onclick = () => addMusicModal.classList.remove('visible');
                getEl('save-music-btn').onclick = () => {
            const title = getEl('add-music-title-input').value.trim();
            const artist = getEl('add-music-artist-input').value.trim();
            const url = getEl('add-music-url-input').value.trim();
        const neteaseId = getEl('add-music-netease-id-input').value.trim(); // 改动：获取网易云ID
        if(!title || !artist || !url) {
            showToast('请填写所有必填项'); return;
        }
        // 改动：在歌曲对象中加入neteaseId
        musicLibrary.push({ title, artist, url, neteaseId: neteaseId || null }); 

            saveMusicLibrary();
            renderMusicLibraryPage();
            addMusicModal.classList.remove('visible');
        };

        
        // --- 其他所有事件绑定 ---
        // --- 关键词库功能事件绑定 ---
        const discoverPageKeywordsBtn = getEl('page-discover').querySelector('#music-library-btn').cloneNode(true);
        discoverPageKeywordsBtn.id = 'keywords-library-btn';
        discoverPageKeywordsBtn.innerHTML = '<i class="fa-solid fa-key"></i><span>关键词库</span><i class="fa-solid fa-chevron-right"></i>';
        getEl('page-discover').querySelector('.settings-list').appendChild(discoverPageKeywordsBtn);
        discoverPageKeywordsBtn.onclick = () => {
            renderKeywordsPage();
            showPage('page-keywords');
        };

        getEl('back-from-keywords-btn').onclick = () => showPage('page-discover');
        getEl('add-keyword-btn').onclick = () => renderKeywordEditPage();
        getEl('back-from-keyword-edit-btn').onclick = () => showPage('page-keywords');
        getEl('save-keyword-btn').onclick = () => {
            const title = getEl('keyword-title-input').value.trim();
            const content = getEl('keyword-content-input').value.trim();
            if (!title) { showToast('标题不能为空'); return; }

            const editingId = getEl('save-keyword-btn').dataset.editingId;
            if (editingId) {
                const keyword = keywordLibrary.find(kw => kw.id === editingId);
                keyword.title = title;
                keyword.content = content;
            } else {
                keywordLibrary.push({ id: `kw_${Date.now()}`, title, content });
            }
            saveKeywordLibrary();
            renderKeywordsPage();
            showPage('page-keywords');
        };
        
        getEl('back-from-keyword-picker-btn').onclick = () => showPage('page-chat');
        getEl('save-keyword-selection-btn').onclick = () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            const friend = findContactById(conversation.contactId);
            const selectedIds = Array.from(getEl('keyword-picker-list-content').querySelectorAll('input:checked')).map(cb => cb.value);
            friend.keywordIds = selectedIds;
            saveContacts();
            showToast('好友关键词已更新');
            showPage('page-chat');
        };

        getEl('menu-set-keywords-from-chat').onclick = () => {
            chatOptionsModal.classList.remove('visible');
            setTimeout(renderKeywordPickerPage, 300);
        };

        const thoughtModal = getEl('thought-modal');
                const showThoughtBtn = getEl('show-thought-btn');
        const closeThoughtBtn = getEl('close-thought-modal-btn');
        const thoughtContentArea = getEl('thought-modal-content-area');
        const regenerateBtn = getEl('regenerate-thought-btn');

                                showThoughtBtn.addEventListener('click', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (conversation && conversation.aiState) {
                regenerateBtn.dataset.convId = conversation.id;
                
                let contentHtml = '';
                if (conversation.aiState.innerThought) {
                    contentHtml += `<div class="thought-section"><div class="thought-title">心里想法</div><div class="thought-content">${conversation.aiState.innerThought}</div></div>`;
                }
                if (conversation.aiState.jottings) {
                    contentHtml += `<div class="thought-section"><div class="thought-title">随笔</div><div class="thought-content">${conversation.aiState.jottings}</div></div>`;
                }

                if (!contentHtml) {
                    contentHtml = '<div class="empty-placeholder" style="display:block; padding: 30px 0;"><p>对方还没有留下任何想法或随笔哦~</p></div>';
                }

                thoughtContentArea.innerHTML = contentHtml;
                // ▼▼▼ 核心修改：更改弹窗标题 ▼▼▼
                thoughtModal.querySelector('.modal-header span').textContent = '对方的心声';
                // ▲▲▲ 修改完成 ▲▲▲
                thoughtModal.classList.add('visible');
            }
        // ▼▼▼ 核心新增：为新的日记本按钮绑定专属的点击事件 ▼▼▼
        getEl('show-diary-btn').addEventListener('click', () => {
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (!conversation || !conversation.diaryEntries || conversation.diaryEntries.length === 0) {
                showToast('TA还没有写过日记哦~');
                return;
            }

            // 复用同一个弹窗，但填充不同的内容
            const modal = getEl('thought-modal');
            const titleEl = modal.querySelector('.modal-header span');
            const contentArea = getEl('thought-modal-content-area');
            const regenerateBtn = getEl('regenerate-thought-btn');

            titleEl.textContent = '日记本'; // 设置弹窗标题为“日记本”
            regenerateBtn.style.display = 'none'; // 查看日记时，隐藏“润色”按钮

            let contentHtml = '';
            // 从最新的一篇开始，倒序显示所有日记
            [...conversation.diaryEntries].reverse().forEach(diary => {
                const diaryDate = new Date(diary.date).toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
                contentHtml += `
                    <div class="thought-section">
                        <div class="thought-title">${diaryDate}</div>
                        <div class="thought-content">${diary.content.replace(/\n/g, '<br>')}</div>
                    </div>
                `;
            });

            contentArea.innerHTML = contentHtml;
            modal.classList.add('visible');
        });
        // ▲▲▲ 新增完成 ▲▲▲

        });




        // ▼▼▼ 核心新增：为新按钮绑定新函数 ▼▼▼
        regenerateBtn.addEventListener('click', regenerateInnerThought);
        // ▲▲▲ 新增完成 ▲▲▲

        const closeThoughtModal = () => thoughtModal.classList.remove('visible');
        closeThoughtBtn.addEventListener('click', closeThoughtModal);
        thoughtModal.addEventListener('click', (e) => { if (e.target === thoughtModal) closeThoughtModal(); });
        const chatOptionsModal = getEl('chat-options-modal');
        getEl('chat-options-btn').addEventListener('click', (e) => { e.stopPropagation(); chatOptionsModal.classList.add('visible'); });
        chatOptionsModal.addEventListener('click', function(e) { if (e.target === this) this.classList.remove('visible'); });
        getEl('menu-edit-friend-from-chat').addEventListener('click', () => {
            chatOptionsModal.classList.remove('visible');
            const conversation = conversations.find(c => c.id === currentConversationId);
            if (conversation && conversation.type === 'friend') {
                setTimeout(() => renderEditFriendPage(conversation.contactId), 300);
            } else {
                showToast('只有好友才能修改信息哦');
            }
        });
        getEl('menu-view-details-from-chat').addEventListener('click', () => showToast('该功能暂未开放'));
        getEl('menu-bind-player-from-chat').addEventListener('click', () => showToast('该功能暂未开放'));
        
        getEl('menu-clear-chat-history').onclick = () => {
            chatOptionsModal.classList.remove('visible');
            setTimeout(() => {
                showConfirmModal('确认清空', '这将永久删除当前聊天记录和AI的相关记忆，确定要清空吗？', () => {
                    const conversation = conversations.find(c => c.id === currentConversationId);
                    if (conversation) {
                        conversation.history = [];
                        conversation.lastActivity = 0;
                        if (conversation.aiState) {
                            conversation.aiState.innerThought = '';
                            conversation.aiState.jottings = '';
                        }
                        saveConversations();
                        renderChatHistory(); // 立即刷新当前聊天界面
                        renderConversationList(); // 刷新会话列表
                        getEl('show-thought-btn').style.display = 'none'; // 隐藏心声按钮
                    }
                    getEl('confirm-modal').classList.remove('visible');
                    showToast('聊天记录已清空');
                });
            }, 300); // 延迟执行，等待菜单关闭动画
        };


        navItems.forEach(item => item.addEventListener('click', () => showPage(item.getAttribute('data-page'))));
        const discoverPage = getEl('page-discover');
        const momentsBtn = discoverPage.querySelector('.setting-item span').parentNode;
        momentsBtn.id = 'discover-moments-btn';
        momentsBtn.onclick = () => { renderMomentsPage(); showPage('page-moments'); };
        getEl('back-from-moments-btn').onclick = () => showPage('page-discover');
        getEl('generate-ai-moment-btn').onclick = generateAiMoment;
        getEl('post-my-moment-btn').onclick = renderPostMomentPage;
        getEl('trigger-ai-social-btn').onclick = triggerAiSocialInteraction;
        const editMomentModal = getEl('edit-moment-modal');
        getEl('cancel-edit-moment-btn').onclick = () => editMomentModal.classList.remove('visible');
        getEl('save-edited-moment-btn').onclick = () => {
            const momentId = getEl('save-edited-moment-btn').dataset.momentId;
            const newText = getEl('edit-moment-textarea').value;
            const moment = moments.find(m => m.id === momentId);
            if (moment) {
                moment.text = newText;
                saveMoments();
                renderMomentsPage();
                editMomentModal.classList.remove('visible');
                showToast('动态已更新');
            }
        };
        getEl('back-to-conversations-btn').addEventListener('click', () => showPage('page-conversations'));
        getEl('back-to-settings-btn').addEventListener('click', () => showPage('page-settings'));
        getEl('back-from-moments-api-settings-btn').addEventListener('click', () => showPage('page-settings'));
        getEl('back-from-wallet-btn').addEventListener('click', () => showPage('page-settings'));
        getEl('my-avatar').addEventListener('click', () => { renderMyInfoPage(); showPage('page-my-info'); });
        getEl('back-from-my-info-btn').addEventListener('click', () => showPage('page-conversations'));
        getEl('back-from-create-friend-btn').addEventListener('click', () => showPage('page-contacts'));
        getEl('back-from-edit-friend-btn').addEventListener('click', () => showPage('page-chat'));
        getEl('back-from-create-group-btn').addEventListener('click', () => showPage('page-contacts'));
        getEl('back-from-create-friend-group-btn').addEventListener('click', () => showPage('page-contacts'));
        getEl('save-settings-btn').addEventListener('click', saveSettings);
        getEl('save-moments-settings-btn').addEventListener('click', saveMomentsSettings);
        getEl('save-group-btn').addEventListener('click', saveNewGroup);
        getEl('save-friend-group-btn').addEventListener('click', saveNewFriendGroup);
        sendBtn.addEventListener('click', sendUserMessage);
        messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendUserMessage(); } });
        getEl('trigger-ai-btn').addEventListener('click', triggerAiResponse);
        const toggleInputModeBtn = getEl('toggle-input-mode-btn');
        const chatInputArea = getEl('chat-input-area');
        toggleInputModeBtn.addEventListener('click', () => {
            const isVoiceMode = chatInputArea.classList.toggle('voice-mode');
            toggleInputModeBtn.innerHTML = isVoiceMode ? '<i class="fa-solid fa-keyboard"></i>' : '<i class="fa-solid fa-microphone"></i>';
        });
        const voiceInputModal = getEl('voice-input-modal');
        getEl('hold-to-talk-btn').addEventListener('click', () => {
            voiceInputModal.classList.add('visible');
            getEl('voice-message-textarea').focus();
        });
        getEl('cancel-voice-btn').addEventListener('click', () => {
            voiceInputModal.classList.remove('visible');
            getEl('voice-message-textarea').value = '';
        });
        getEl('send-voice-btn').addEventListener('click', () => {
            const content = getEl('voice-message-textarea').value.trim();
            if (content) {
                addMessageToChat('user', content, true, { type: 'voice' });
                voiceInputModal.classList.remove('visible');
                getEl('voice-message-textarea').value = '';
            } else {
                showToast('语音内容不能为空');
            }
        });
        getEl('add-contact-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            addContactModal.classList.add('visible');
            setTimeout(() => { addContactModal.querySelector('.modal-content').style.transform = 'translateY(0)'; }, 10);
        });
        addContactModal.addEventListener('click', function(e) {
            if (e.target === this || e.target.closest('.fa-chevron-right')) {
                this.querySelector('.modal-content').style.transform = 'translateY(100%)';
                setTimeout(() => { this.classList.remove('visible'); }, 300);
            }
        });
        function handleMenuClick(pageRenderer, pageToShow) { addContactModal.classList.remove('visible'); setTimeout(() => { if (pageRenderer) pageRenderer(); if (pageToShow) showPage(pageToShow); }, 300); }
        getEl('menu-add-friend').addEventListener('click', () => handleMenuClick(renderCreateFriendPage, 'page-create-friend'));
        getEl('menu-add-group').addEventListener('click', () => handleMenuClick(renderCreateGroupPage));
        getEl('menu-add-friend-group').addEventListener('click', () => handleMenuClick(renderCreateFriendGroupPage));
        getEl('menu-add-preset-role').addEventListener('click', () => showToast('该功能暂未开放'));
        getEl('menu-import-role').addEventListener('click', () => showToast('该功能暂未开放'));
        getEl('toggle-delete-mode-btn').addEventListener('click', () => toggleEditMode('page-conversations', 'conversations-edit-bar'));
        getEl('contacts-delete-toggle-btn').addEventListener('click', () => toggleEditMode('page-contacts', 'contacts-edit-bar'));
                        setupDeleteLogic('page-conversations', 'conversations-edit-bar', 'conv-select-all-btn', 'conv-delete-selected-btn', (selectedItems) => {
            const idsToDelete = selectedItems.map(item => item.dataset.id);
            // 核心修复：恢复为物理删除逻辑
            conversations = conversations.filter(c => !idsToDelete.includes(c.id));
            saveConversations();
        });

        setupDeleteLogic('page-contacts', 'contacts-edit-bar', 'contact-select-all-btn', 'contact-delete-selected-btn', (selectedItems) => { 
            selectedItems.forEach(item => { 
                const { id, type } = item.dataset; 
                if (type === 'friend') { 
                    contacts.friends = contacts.friends.filter(f => f.id !== id); 
                    contacts.friendGroups.forEach(g => g.friendIds = g.friendIds.filter(fid => fid !== id)); 
                } else if (type === 'group') { 
                    contacts.groups = contacts.groups.filter(g => g.id !== id); 
                } else if (type === 'friend-group') { 
                    contacts.friendGroups = contacts.friendGroups.filter(g => g.id !== id); 
                } 
                conversations = conversations.filter(c => c.contactId !== id); 
            }); 
            saveContacts(); 
            saveConversations(); 
        });
        getEl('confirm-cancel-btn').addEventListener('click', () => getEl('confirm-modal').classList.remove('visible'));
        getEl('confirm-ok-btn').addEventListener('click', () => { if (confirmCallback) confirmCallback(); });
        const viewWithdrawnModal = getEl('view-withdrawn-modal');
        const closeWithdrawnBtn = getEl('close-withdrawn-modal-btn');
        const closeWithdrawnModal = () => viewWithdrawnModal.classList.remove('visible');
        closeWithdrawnBtn.addEventListener('click', closeWithdrawnModal);
        viewWithdrawnModal.addEventListener('click', (e) => { if (e.target === viewWithdrawnModal) closeWithdrawnModal(); });
    }


    // ==========================================================
    // ==========================================================
    //              外卖功能核心逻辑 (新增)
    // ==========================================================
    // ==========================================================

    // 模拟从API获取数据
        function loadTakeoutData() {
        takeoutData = {
            shops: [
                { id: 'shop001', name: '疯狂星期四', itemIcon: 'fa-burger', logo: '...', banner: '...', deliveryTime: 30, deliveryFee: 5, menu: [
                    { id: 'item101', name: '黄金鸡块 (5块)', price: 9.9, image: '...' }, { id: 'item102', name: '香辣鸡腿堡', price: 18.0, image: '...' }, { id: 'item103', name: '劲脆鸡米花 (大)', price: 15.5, image: '...' }, { id: 'item104', name: '可乐 (中)', price: 8.0, image: '...' }, { id: 'item105', name: '奥尔良烤翅 (2只)', price: 12.0, image: '...' }, { id: 'item106', name: '经典薯条 (中)', price: 9.0, image: '...' }, { id: 'item107', name: '葡式蛋挞', price: 7.5, image: '...' }, { id: 'item108', name: '全家桶', price: 89.0, image: '...' },
                    { id: 'item109', name: '香辣鸡翅 (2只)', price: 12.0, image: '...' }, { id: 'item110', name: '吮指原味鸡', price: 13.5, image: '...' }, { id: 'item111', name: '九珍果汁饮料', price: 9.5, image: '...' }, { id: 'item112', name: '醇香土豆泥', price: 6.5, image: '...' }, { id: 'item113', name: '老北京鸡肉卷', price: 17.0, image: '...' }, { id: 'item114', name: '早餐鸡肉扒汉堡', price: 15.0, image: '...' }, { id: 'item115', name: '皮蛋瘦肉粥', price: 9.0, image: '...' }, { id: 'item116', name: '圣代 (巧克力)', price: 8.5, image: '...' }, { id: 'item117', name: '套餐A：香辣鸡腿堡+可乐', price: 25.0, image: '...' }, { id: 'item118', name: '套餐B：原味鸡+土豆泥+果汁', price: 28.0, image: '...' }, { id: 'item119', name: '套餐C：鸡肉卷+鸡米花+可乐', price: 38.0, image: '...' }, { id: 'item120', name: '豪华双人餐', price: 79.0, image: '...' }
                ]},
                { id: 'shop002', name: '蜜雪冰城', itemIcon: 'fa-ice-cream', logo: '...', banner: '...', deliveryTime: 25, deliveryFee: 2, menu: [
                    { id: 'item201', name: '冰鲜柠檬水', price: 4.0, image: '...' }, { id: 'item202', name: '摩天脆脆冰淇淋', price: 3.0, image: '...' }, { id: 'item203', name: '满杯百香果', price: 7.0, image: '...' }, { id: 'item204', name: '珍珠奶茶', price: 6.0, image: '...' }, { id: 'item205', name: '芝士奶盖莓莓', price: 8.0, image: '...' }, { id: 'item206', name: '摇摇奶昔', price: 6.0, image: '...' }, { id: 'item207', name: '杨枝甘露', price: 9.0, image: '...' },
                    { id: 'item208', name: '桑葚莓莓', price: 8.0, image: '...' }, { id: 'item209', name: '奥利奥圣代', price: 6.0, image: '...' }, { id: 'item210', name: '美式咖啡', price: 5.0, image: '...' }, { id: 'item211', name: '芋圆葡萄', price: 8.0, image: '...' }, { id: 'item212', name: '雪王大圣代', price: 6.0, image: '...' }, { id: 'item213', name: '黄桃果霸', price: 7.0, image: '...' }, { id: 'item214', name: '草莓啵啵', price: 7.0, image: '...' }, { id: 'item215', name: '冰淇淋红茶', price: 5.0, image: '...' }, { id: 'item216', name: '套餐A：柠檬水+冰淇淋', price: 6.0, image: '...' }, { id: 'item217', name: '套餐B：珍珠奶茶x2', price: 10.0, image: '...' }, { id: 'item218', name: '套餐C：杨枝甘露+圣代', price: 14.0, image: '...' }, { id: 'item219', name: '全家桶冰淇淋', price: 10.0, image: '...' }, { id: 'item220', name: '椰果奶茶', price: 6.0, image: '...' }
                ]},
                { id: 'shop004', name: '星巴克', itemIcon: 'fa-mug-hot', logo: '...', banner: '...', deliveryTime: 20, deliveryFee: 9, menu: [
                    { id: 'item401', name: '拿铁', price: 32.0, image: '...' }, { id: 'item402', name: '美式咖啡', price: 29.0, image: '...' }, { id: 'item403', name: '可颂', price: 18.0, image: '...' }, { id: 'item404', name: '抹茶星冰乐', price: 36.0, image: '...' }, { id: 'item405', name: '蓝莓麦芬', price: 22.0, image: '...' }, { id: 'item406', name: '冷萃咖啡', price: 38.0, image: '...' }, { id: 'item407', name: '凯撒鸡肉卷', price: 35.0, image: '...' },
                    { id: 'item408', name: '摩卡', price: 35.0, image: '...' }, { id: 'item409', name: '焦糖玛奇朵', price: 36.0, image: '...' }, { id: 'item410', name: '红茶拿铁', price: 32.0, image: '...' }, { id: 'item411', name: '巧克力麦芬', price: 22.0, image: '...' }, { id: 'item412', name: '法式烤火腿三明治', price: 38.0, image: '...' }, { id: 'item413', name: '经典提拉米苏', price: 28.0, image: '...' }, { id: 'item414', name: '冰摇柠檬茶', price: 28.0, image: '...' }, { id: 'item415', name: '馥芮白', price: 35.0, image: '...' }, { id: 'item416', name: '套餐A：美式+可颂', price: 45.0, image: '...' }, { id: 'item417', name: '套餐B：拿铁+提拉米苏', price: 58.0, image: '...' }, { id: 'item418', name: '套餐C：星冰乐+鸡肉卷', price: 69.0, image: '...' }, { id: 'item419', name: '双人下午茶套餐', price: 98.0, image: '...' }, { id: 'item420', name: '气致冷萃', price: 42.0, image: '...' }
                ]},
                { id: 'shop005', name: '必胜客', itemIcon: 'fa-pizza-slice', logo: '...', banner: '...', deliveryTime: 35, deliveryFee: 8, menu: [
                    { id: 'item501', name: '超级至尊披萨 (9寸)', price: 78.0, image: '...' }, { id: 'item502', name: '意式肉酱面', price: 42.0, image: '...' }, { id: 'item503', name: '经典鸡翅 (4只)', price: 32.0, image: '...' }, { id: 'item504', name: '柠檬红茶', price: 15.0, image: '...' }, { id: 'item505', name: '海鲜至尊披萨 (9寸)', price: 88.0, image: '...' }, { id: 'item506', name: '酥炸鱿鱼须', price: 36.0, image: '...' },
                    { id: 'item507', name: '夏威夷风光披萨 (9寸)', price: 72.0, image: '...' }, { id: 'item508', name: '奶油蘑菇汤', price: 25.0, image: '...' }, { id: 'item509', name: '自助沙拉', price: 38.0, image: '...' }, { id: 'item510', name: '烤肠拼盘', price: 45.0, image: '...' }, { id: 'item511', name: '美式大薯格', price: 22.0, image: '...' }, { id: 'item512', name: '香草凤尾虾', price: 35.0, image: '...' }, { id: 'item513', name: '抹茶雪域蛋糕', price: 28.0, image: '...' }, { id: 'item514', name: '百事可乐 (大)', price: 12.0, image: '...' }, { id: 'item515', name: '套餐A：9寸披萨+鸡翅+2杯可乐', price: 108.0, image: '...' }, { id: 'item516', name: '套餐B：意面+蘑菇汤+沙拉', price: 98.0, image: '...' }, { id: 'item517', name: '套餐C：海鲜披萨+鱿鱼须+凤尾虾', price: 158.0, image: '...' }, { id: 'item518', name: '豪华四人餐', price: 288.0, image: '...' }, { id: 'item519', name: '榴莲多多披萨 (9寸)', price: 98.0, image: '...' }, { id: 'item520', name: '小食拼盘', price: 58.0, image: '...' }
                ]},
                { id: 'shop006', name: '淮岸居 (高端私房菜)', itemIcon: 'fa-utensils', logo: '...', banner: '...', deliveryTime: 45, deliveryFee: 12, menu: [
                    { id: 'item601', name: '腌笃鲜配春笋 (春季限定)', price: 128.0, image: '...' }, { id: 'item602', name: '淮水蟹蒸肉饼 (秋季限定)', price: 158.0, image: '...' }, { id: 'item603', name: '主厨私房狮子头', price: 98.0, image: '...' }, { id: 'item604', name: '松鼠鳜鱼', price: 188.0, image: '...' }, { id: 'item605', name: '五常大米饭', price: 8.0, image: '...' }, { id: 'item606', name: '金陵盐水鸭', price: 78.0, image: '...' }, { id: 'item607', name: '时令蔬菜', price: 42.0, image: '...' },
                    { id: 'item608', name: '清炒河虾仁', price: 138.0, image: '...' }, { id: 'item609', name: '响油鳝糊', price: 118.0, image: '...' }, { id: 'item610', name: '文思豆腐羹', price: 68.0, image: '...' }, { id: 'item611', name: '扬州炒饭', price: 58.0, image: '...' }, { id: 'item612', name: '冰镇话梅小番茄', price: 38.0, image: '...' }, { id: 'item613', name: '桂花糖藕', price: 48.0, image: '...' }, { id: 'item614', name: '陈年花雕醉鸡', price: 88.0, image: '...' }, { id: 'item615', name: '西湖龙井', price: 58.0, image: '...' }, { id: 'item616', name: '套餐A：狮子头+蔬菜+米饭', price: 148.0, image: '...' }, { id: 'item617', name: '套餐B：盐水鸭+豆腐羹+扬州炒饭', price: 188.0, image: '...' }, { id: 'item618', name: '套餐C：松鼠鳜鱼+醉鸡+时蔬', price: 328.0, image: '...' }, { id: 'item619', name: '商务宴请套餐 (4人)', price: 888.0, image: '...' }, { id: 'item620', name: '红烧肉', price: 108.0, image: '...' }
                ]},
                { id: 'shop008', name: '巷里烧烤铺', itemIcon: 'fa-fire-flame-curved', logo: '...', banner: '...', deliveryTime: 35, deliveryFee: 5, menu: [
                    { id: 'item801', name: '果木炭烤羊肉串 (5串)', price: 30.0, image: '...' }, { id: 'item802', name: '桂花蜜烤鸡翅 (2只)', price: 22.0, image: '...' }, { id: 'item803', name: '淮水藕夹串 (2串)', price: 18.0, image: '...' }, { id: 'item804', name: '蒜蓉烤茄子', price: 16.0, image: '...' }, { id: 'item805', name: '自酿杨梅酒 (一壶)', price: 38.0, image: '...' }, { id: 'item806', name: '烤五花肉 (3串)', price: 24.0, image: '...' }, { id: 'item807', name: '锡纸金针菇', price: 15.0, image: '...' },
                    { id: 'item808', name: '烤生蚝 (半打)', price: 48.0, image: '...' }, { id: 'item809', name: '烤扇贝 (半打)', price: 48.0, image: '...' }, { id: 'item810', name: '烤韭菜', price: 10.0, image: '...' }, { id: 'item811', name: '烤面包片 (2片)', price: 8.0, image: '...' }, { id: 'item812', name: '烤玉米', price: 10.0, image: '...' }, { id: 'item813', name: '烤羊肉串 (5串)', price: 15.0, image: '...' }, { id: 'item814', name: '烤土豆片', price: 10.0, image: '...' }, { id: 'item815', name: '酸梅汤', price: 8.0, image: '...' }, { id: 'item816', name: '套餐A：羊肉串+鸡翅+茄子', price: 65.0, image: '...' }, { id: 'item817', name: '套餐B：烤生蚝+烤扇贝', price: 90.0, image: '...' }, { id: 'item818', name: '套餐C：五花肉+藕夹+金针菇', price: 55.0, image: '...' }, { id: 'item819', name: '双人烧烤套餐', price: 128.0, image: '...' }, { id: 'item820', name: '烤大虾 (2串)', price: 28.0, image: '...' }
                ]},
                { id: 'shop009', name: '梧桐食集', itemIcon: 'fa-steam', logo: '...', banner: '...', deliveryTime: 20, deliveryFee: 3, menu: [
                    { id: 'item901', name: '蟹黄灌汤包 (一笼)', price: 28.0, image: '...' }, { id: 'item902', name: '鲜肉灌汤包 (一笼)', price: 18.0, image: '...' }, { id: 'item903', name: '现磨醇豆浆', price: 5.0, image: '...' }, { id: 'item904', name: '茶叶蛋', price: 3.0, image: '...' }, { id: 'item905', name: '鲜肉小馄饨', price: 12.0, image: '...' }, { id: 'item906', name: '南瓜粥', price: 8.0, image: '...' },
                    { id: 'item907', name: '三丁包 (2只)', price: 10.0, image: '...' }, { id: 'item908', name: '千层油糕', price: 8.0, image: '...' }, { id: 'item909', name: '烧卖 (3只)', price: 15.0, image: '...' }, { id: 'item910', name: '糯米鸡', price: 16.0, image: '...' }, { id: 'item911', name: '炸油条', price: 4.0, image: '...' }, { id: 'item912', name: '豆腐脑 (咸)', price: 6.0, image: '...' }, { id: 'item913', name: '小米粥', price: 5.0, image: '...' }, { id: 'item914', name: '牛肉锅贴 (一份)', price: 18.0, image: '...' }, { id: 'item915', name: '套餐A：鲜肉汤包+豆浆', price: 22.0, image: '...' }, { id: 'item916', name: '套餐B：小馄饨+油条', price: 15.0, image: '...' }, { id: 'item917', name: '套餐C：烧卖+南瓜粥', price: 22.0, image: '...' }, { id: 'item918', name: '全家福早餐套餐', price: 58.0, image: '...' }, { id: 'item919', name: '素菜包 (2只)', price: 8.0, image: '...' }, { id: 'item920', name: '赤豆元宵', price: 10.0, image: '...' }
                ]},
                { id: 'shop010', name: '韩食屋', itemIcon: 'fa-bowl-food', logo: '...', banner: '...', deliveryTime: 30, deliveryFee: 5, menu: [
                    { id: 'item1001', name: '石锅拌饭', price: 38.0, image: '...' }, { id: 'item1002', name: '部队火锅 (小份)', price: 88.0, image: '...' }, { id: 'item1003', name: '韩式炸鸡 (甜辣味)', price: 45.0, image: '...' }, { id: 'item1004', name: '大酱汤配米饭', price: 32.0, image: '...' }, { id: 'item1005', name: '泡菜饼', price: 28.0, image: '...' }, { id: 'item1006', name: '炒年糕', price: 30.0, image: '...' },
                    { id: 'item1007', name: '冷面', price: 28.0, image: '...' }, { id: 'item1008', name: '烤五花肉套餐', price: 78.0, image: '...' }, { id: 'item1009', name: '海鲜嫩豆腐汤', price: 35.0, image: '...' }, { id: 'item1010', name: '芝士排骨', price: 98.0, image: '...' }, { id: 'item1011', name: '韩式紫菜包饭', price: 25.0, image: '...' }, { id: 'item1012', name: '辛拉面', price: 20.0, image: '...' }, { id: 'item1013', name: '泡菜炒饭', price: 30.0, image: '...' }, { id: 'item1014', name: '香蕉牛奶', price: 12.0, image: '...' }, { id: 'item1015', name: '套餐A：石锅拌饭+大酱汤', price: 68.0, image: '...' }, { id: 'item1016', name: '套餐B：炸鸡+炒年糕', price: 72.0, image: '...' }, { id: 'item1017', name: '套餐C：部队火锅+紫菜包饭', price: 110.0, image: '...' }, { id: 'item1018', name: '韩式烤肉双人餐', price: 158.0, image: '...' }, { id: 'item1019', name: '人参鸡汤', price: 68.0, image: '...' }, { id: 'item1020', name: '韩式拌杂菜', price: 28.0, image: '...' }
                ]},
                { id: 'shop011', name: '粤韵轩', itemIcon: 'fa-fish-fins', logo: '...', banner: '...', deliveryTime: 40, deliveryFee: 8, menu: [
                    { id: 'item1101', name: '烧腊双拼', price: 68.0, image: '...' }, { id: 'item1102', name: '虾饺皇 (4只)', price: 32.0, image: '...' }, { id: 'item1103', name: '干炒牛河', price: 48.0, image: '...' }, { id: 'item1104', name: '艇仔粥', price: 28.0, image: '...' }, { id: 'item1105', name: '豉汁凤爪', price: 26.0, image: '...' }, { id: 'item1106', name: '流沙包 (3只)', price: 22.0, image: '...' },
                    { id: 'item1107', name: '叉烧包 (3只)', price: 20.0, image: '...' }, { id: 'item1108', name: '金钱肚', price: 28.0, image: '...' }, { id: 'item1109', name: '肠粉', price: 25.0, image: '...' }, { id: 'item1110', name: '云吞面', price: 35.0, image: '...' }, { id: 'item1111', name: '白灼菜心', price: 28.0, image: '...' }, { id: 'item1112', name: '杨枝甘露', price: 25.0, image: '...' }, { id: 'item1113', name: '冰镇奶茶', price: 18.0, image: '...' }, { id: 'item1114', name: '干煸四季豆', price: 32.0, image: '...' }, { id: 'item1115', name: '套餐A：干炒牛河+云吞面', price: 80.0, image: '...' }, { id: 'item1116', name: '套餐B：虾饺皇+凤爪+烧卖', price: 82.0, image: '...' }, { id: 'item1117', name: '套餐C：烧腊饭+奶茶', price: 82.0, image: '...' }, { id: 'item1118', name: '广式早茶双人套餐', price: 128.0, image: '...' }, { id: 'item1119', name: '菠萝包', price: 15.0, image: '...' }, { id: 'item1120', name: '腊味煲仔饭', price: 58.0, image: '...' }
                ]},
                { id: 'shop012', name: '海味舫', itemIcon: 'fa-shrimp', logo: '...', banner: '...', deliveryTime: 35, deliveryFee: 7, menu: [
                    { id: 'item1201', name: '香辣蟹', price: 158.0, image: '...' }, { id: 'item1202', name: '清蒸淮水白鱼', price: 98.0, image: '...' }, { id: 'item1203', name: '椒盐皮皮虾', price: 88.0, image: '...' }, { id: 'item1204', name: '海鲜疙瘩汤', price: 35.0, image: '...' }, { id: 'item1205', name: '蒜蓉粉丝蒸扇贝 (4只)', price: 58.0, image: '...' }, { id: 'item1206', name: '白灼基围虾', price: 78.0, image: '...' },
                    { id: 'item1207', name: '辣炒花甲', price: 48.0, image: '...' }, { id: 'item1208', name: '葱油海瓜子', price: 58.0, image: '...' }, { id: 'item1209', name: '海鲜炒饭', price: 45.0, image: '...' }, { id: 'item1210', name: '姜葱炒蟹', price: 128.0, image: '...' }, { id: 'item1211', name: '粉丝蒸娃娃菜', price: 28.0, image: '...' }, { id: 'item1212', name: '酸菜鱼', price: 68.0, image: '...' }, { id: 'item1213', name: '炸鲜奶', price: 25.0, image: '...' }, { id: 'item1214', name: '椰汁', price: 10.0, image: '...' }, { id: 'item1215', name: '套餐A：香辣蟹+花甲+蔬菜', price: 228.0, image: '...' }, { id: 'item1216', name: '套餐B：酸菜鱼+海鲜炒饭', price: 108.0, image: '...' }, { id: 'item1217', name: '套餐C：清蒸鱼+基围虾', price: 170.0, image: '...' }, { id: 'item1218', name: '豪华海鲜盛宴 (4人)', price: 488.0, image: '...' }, { id: 'item1219', name: '油焖大虾', price: 98.0, image: '...' }, { id: 'item1220', name: '海蛎煎', price: 38.0, image: '...' }
                ]}
            ],
            reviews: {
                'shop001': [ { authorId: 'friend_A', text: '蛋挞有点太甜了，但鸡块还是一如既往的好吃。' }, { authorId: 'friend_B', text: '配送员提前送到了，赞一个！' }, { authorId: 'friend_C', text: '老北京鸡肉卷还是那个味，经典！' }, { authorId: 'friend_D', text: '早餐粥很好喝，就是分量有点少。' }, { authorId: 'friend_E', text: '为什么套餐里的可乐不能换成零度？' }, { authorId: 'friend_F', text: '原味鸡yyds！' }, { authorId: 'friend_G', text: '希望多出点新品。' }, { authorId: 'friend_A', text: '双人餐很划算，两个人吃得饱饱的。' }, { authorId: 'friend_B', text: '薯条有点软了，可能是送的时间长了。' }, { authorId: 'friend_C', text: '疯狂星期四，V我50！' } ],
                'shop002': [ { authorId: 'friend_C', text: '摇摇奶昔感觉一般，没什么特别的。' }, { authorId: 'friend_B', text: '三块钱的冰淇淋还要什么自行车！' }, { authorId: 'friend_D', text: '珍珠奶茶的珍珠给的很多，好评！' }, { authorId: 'friend_E', text: '杨枝甘露的芒果味很浓，不错。' }, { authorId: 'friend_F', text: '排队人太多了，还是点外卖方便。' }, { authorId: 'friend_G', text: '希望出点热饮。' }, { authorId: 'friend_A', text: '性价比之王！' }, { authorId: 'friend_B', text: '新品桑葚莓莓好喝！推荐！' }, { authorId: 'friend_D', text: '外卖小哥辛苦了，这么热的天。' }, { authorId: 'friend_E', text: '雪王我爱你！' } ],
                'shop004': [ { authorId: 'friend_D', text: '咖啡味道很正宗，就是价格有点小贵。' }, { authorId: 'friend_E', text: '凯撒鸡肉卷的蔬菜很新鲜，适合减脂期。' }, { authorId: 'friend_A', text: '提拉米苏好吃，入口即化。' }, { authorId: 'friend_B', text: '早上来一杯美式，开启一天的工作。' }, { authorId: 'friend_C', text: '抹茶星冰乐永远的神！' }, { authorId: 'friend_F', text: '包装很用心，一点都没洒。' }, { authorId: 'friend_G', text: '要是多点优惠活动就好了。' }, { authorId: 'friend_A', text: '备注了少冰，店家很贴心。' }, { authorId: 'friend_D', text: '双人下午茶套餐很不错，适合和朋友聊天。' }, { authorId: 'friend_F', text: '感觉今天的拿铁奶泡有点少。' } ],
                'shop005': [ { authorId: 'friend_A', text: '等了快一个小时才送到，有点慢了，不过味道还行。' }, { authorId: 'friend_B', text: '披萨的芝士可以拉很长！爱了爱了。' }, { authorId: 'friend_C', text: '意面味道不错，就是分量不大。' }, { authorId: 'friend_D', text: '鸡翅烤的火候刚刚好，很香。' }, { authorId: 'friend_E', text: '榴莲披萨绝了，爱吃榴莲的别错过！' }, { authorId: 'friend_F', text: '小食拼盘种类很多，一次满足。' }, { authorId: 'friend_G', text: '沙拉很新鲜，酱汁也好吃。' }, { authorId: 'friend_A', text: '豪华四人餐我们五个人吃都没问题，量很大。' }, { authorId: 'friend_C', text: '希望能出单人套餐。' }, { authorId: 'friend_E', text: '还是堂食的氛围好一点。' } ],
                'shop006': [ { authorId: 'friend_B', text: '不愧是高端菜，松鼠鳜鱼做得太地道了，酸甜口一绝！' }, { authorId: 'friend_F', text: '价格太贵了，偶尔奢侈一下还可以，不能当食堂。' }, { authorId: 'friend_A', text: '狮子头肥而不腻，入口即化，汤汁鲜美。' }, { authorId: 'friend_C', text: '包装是用的保温盒，送到手还是热的，很专业。' }, { authorId: 'friend_D', text: '陈年花雕醉鸡的酒味刚刚好，鸡肉很嫩。' }, { authorId: 'friend_E', text: '文思豆腐羹太考验刀工了，佩服大厨。' }, { authorId: 'friend_G', text: '扬州炒饭粒粒分明，用料很足。' }, { authorId: 'friend_B', text: '商务宴请点的这个，客户很满意。' }, { authorId: 'friend_F', text: '桂花糖藕甜度适中，很糯。' }, { authorId: 'friend_A', text: '腌笃鲜的汤太好喝了，鲜掉眉毛。' } ],
                'shop008': [ { authorId: 'friend_C', text: '点的羊肉串有点肥，下次还是点鸡翅吧。' }, { authorId: 'friend_G', text: '桂花蜜烤鸡翅是神仙美味！果木炭的香味太棒了。' }, { authorId: 'friend_A', text: '烤茄子蒜蓉给的特别多，够味！' }, { authorId: 'friend_B', text: '烤生蚝很新鲜，一点腥味都没有。' }, { authorId: 'friend_D', text: '两个人点一个双人套餐就够了，很实惠。' }, { authorId: 'friend_E', text: '晚上跟朋友小聚，点个烧烤外卖太惬意了。' }, { authorId: 'friend_F', text: '烤面包片刷了蜂蜜，甜甜脆脆的很好吃。' }, { authorId: 'friend_C', text: '酸梅汤是自己熬的，比冲的好喝多了。' }, { authorId: 'friend_G', text: '希望下次辣一点，备注了加辣感觉还是不够。' }, { authorId: 'friend_B', text: '烤玉米很甜，是水果玉米。' } ],
                'shop009': [ { authorId: 'friend_D', text: '灌汤包的汤汁很足，但是要小心烫嘴！' }, { authorId: 'friend_G', text: '豆浆很醇厚，希望能出无糖版的。' }, { authorId: 'friend_A', text: '鲜肉小馄饨的皮很薄，汤很鲜。' }, { authorId: 'friend_B', text: '牛肉锅贴底很脆，肉馅多汁。' }, { authorId: 'friend_C', text: '早上不想做饭，点一份中式早餐很舒服。' }, { authorId: 'friend_E', text: '油条有点凉了，要是刚出锅的就好了。' }, { authorId: 'friend_F', text: '赤豆元宵的元宵很软糯，甜度刚好。' }, { authorId: 'friend_D', text: '全家福早餐套餐够三个人吃了，很丰盛。' }, { authorId: 'friend_G', text: '豆腐脑是咸口的，好评！' }, { authorId: 'friend_A', text: '希望增加一些辣的浇头。' } ],
                'shop010': [ { authorId: 'friend_E', text: '部队火锅的料很丰富，两个人吃小份都够了。' }, { authorId: 'friend_F', text: '石锅拌饭的锅巴YYDS！就是泡菜给的有点少。' }, { authorId: 'friend_A', text: '韩式炸鸡甜辣酱是灵魂！' }, { authorId: 'friend_B', text: '芝士排骨可以拉很长的丝，太满足了。' }, { authorId: 'friend_C', text: '泡菜饼外脆里嫩，蘸着酱汁很好吃。' }, { authorId: 'friend_D', text: '冷面很清爽，夏天吃很开胃。' }, { authorId: 'friend_G', text: '人参鸡汤的鸡肉炖的很烂，汤也好喝。' }, { authorId: 'friend_E', text: '紫菜包饭的米饭有点硬。' }, { authorId: 'friend_F', text: '送了很多小菜，店家很大方。' }, { authorId: 'friend_A', text: '想吃韩料的时候第一个就想到这家。' } ],
                'shop011': [ { authorId: 'friend_F', text: '烧腊拼盘YYDS，叉烧肥而不腻，烧鹅皮脆多汁。' }, { authorId: 'friend_A', text: '流沙包外卖送过来有点凉了，影响了口感。' }, { authorId: 'friend_B', text: '虾饺皇名不虚传，每个里面都有好几个大虾仁。' }, { authorId: 'friend_C', text: '干炒牛河很有锅气，牛肉也很嫩。' }, { authorId: 'friend_D', text: '豉汁凤爪入口即化，非常入味。' }, { authorId: 'friend_E', text: '云吞面的云吞个头很大，面条是正宗的竹升面。' }, { authorId: 'friend_G', text: '腊味煲仔饭的锅巴太香了！' }, { authorId: 'friend_F', text: '早茶套餐很划算，种类也多。' }, { authorId: 'friend_A', text: '杨枝甘露的西柚有点苦。' }, { authorId: 'friend_C', text: '冰镇奶茶的茶味很浓，是我喜欢的味道。' } ],
                'shop012': [ { authorId: 'friend_G', text: '送来的螃蟹还是活蹦乱跳的，非常新鲜！' }, { authorId: 'friend_A', text: '清蒸白鱼完美地体现了食材的鲜美，下次还会点。' }, { authorId: 'friend_B', text: '椒盐皮皮虾很香，就是剥起来有点费劲。' }, { authorId: 'friend_C', text: '蒜蓉粉丝蒸扇贝的蒜蓉酱调的很好。' }, { authorId: 'friend_D', text: '辣炒花甲很干净，没有沙子。' }, { authorId: 'friend_E', text: '酸菜鱼的鱼片很滑嫩，酸菜也够味。' }, { authorId: 'friend_F', text: '海鲜炒饭的料很足，虾仁很大颗。' }, { authorId: 'friend_G', text: '豪华海鲜盛宴太值了，请客很有面子。' }, { authorId: 'friend_B', text: '油焖大虾的汤汁拌饭绝了。' }, { authorId: 'friend_D', text: '海蛎煎的口感很好，外焦里嫩。' } ]
            }
        };

        // ▼▼▼ 核心新增：匿名化处理 ▼▼▼
        for (const shopId in takeoutData.reviews) {
            takeoutData.reviews[shopId].forEach(review => {
                if (review.authorId === 'user_profile') {
                    review.authorId = 'anonymous_user';
                }
            });
        }
    }








    function renderTakeoutMainPage() {
        const content = getEl('takeout-main-content');
        content.innerHTML = '';
        takeoutData.shops.forEach(shop => {
            const shopDiv = document.createElement('div');
            shopDiv.className = 'takeout-shop-item';
            shopDiv.innerHTML = `
                <div class="logo takeout-icon-placeholder"><i class="fa-solid fa-store"></i></div>
                <div class="details">
                    <div class="name">${shop.name}</div>
                    <div class="info">配送约 ${shop.deliveryTime} 分钟 | 配送费 ¥${shop.deliveryFee}</div>
                </div>
            `;
            shopDiv.onclick = () => {
                currentTakeoutShopId = shop.id;
                renderTakeoutShopPage(shop.id);
                showPage('page-takeout-shop');
            };
            content.appendChild(shopDiv);
        });
    }


            function renderTakeoutShopPage(shopId) {
        const shop = takeoutData.shops.find(s => s.id === shopId);
        if (!shop) return;
        
        getEl('takeout-shop-name').textContent = shop.name;
        const content = getEl('takeout-shop-content');
        
                let menuHtml = '';
        shop.menu.forEach(item => {
            // 【核心修改】在这里读取店铺的图标，如果没有指定就用默认的
            const iconClass = shop.itemIcon || 'fa-plate-wheat'; 
            menuHtml += `
                <div class="takeout-menu-item">
                    <div class="item-img takeout-icon-placeholder"><i class="fa-solid ${iconClass}"></i></div>
                    <div class="item-details">
                        <div class="name">${item.name}</div>
                        <div class="price-action">
                            <span class="price">¥${item.price.toFixed(2)}</span>
                            <button class="add-btn" data-item-id="${item.id}">+</button>
                        </div>
                    </div>
                </div>
            `;
        });


        let reviewsHtml = '';
        const reviews = takeoutData.reviews[shopId] || [];
        if (reviews.length > 0) {
            reviews.forEach(review => {
                const author = findContactById(review.authorId) || { name: '匿名用户', avatar: 'https://s2.loli.net/2023/05/23/gM3FPAfWk1vYc8z.png' };
                                // ▼▼▼ 核心修改在这里 ▼▼▼
                reviewsHtml += `
                    <div class="review-item">
                        <div class="avatar takeout-icon-placeholder"><i class="fa-solid fa-ghost"></i></div>
                        <div class="content">
                            <div class="author">${getDisplayName(author)}</div>
                            <div class="text">${review.text}</div>
                        </div>
                    </div>
                `;
                // ▲▲▲ 修改完成 ▲▲▲

            });
        } else {
            reviewsHtml = '<p style="font-size: 0.9rem; color: var(--text-color-light); text-align: center; padding: 20px 0;">暂无评价</p>';
        }

        content.innerHTML = `
            <div class="takeout-shop-header">
                <div class="shop-info-card">
                    <div class="logo takeout-icon-placeholder"><i class="fa-solid fa-store"></i></div>
                    <div style="flex-grow: 1;">
                        <h2 style="margin:0; font-size: 1.2rem;">${shop.name}</h2>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin: 5px 0 0 0;">配送费 ¥${shop.deliveryFee}</p>
                    </div>
                </div>
            </div>
            <div class="takeout-shop-menu">
                <h3>商品列表</h3>
                ${menuHtml}
                <div class="review-section">
                    <h3>用户评价</h3>
                    ${reviewsHtml}
                </div>
            </div>
        `;

        content.querySelectorAll('.add-btn').forEach(btn => {
            btn.onclick = () => {
                const itemId = btn.dataset.itemId;
                addToCart(shopId, itemId);
            };
        });
        updateCartView(shopId);
    }


    
    function addToCart(shopId, itemId) {
        if (!currentCart[shopId]) {
            currentCart[shopId] = {};
        }
        currentCart[shopId][itemId] = (currentCart[shopId][itemId] || 0) + 1;
        updateCartView(shopId);
    }

    function updateCartView(shopId) {
        const cartBar = getEl('floating-cart-bar');
        const shopCart = currentCart[shopId];

        // 核心修改：让购物车栏可以点击
        cartBar.onclick = () => {
            if (shopCart && Object.keys(shopCart).length > 0) {
                renderDetailedCartModal(shopId);
            }
        };

        if (!shopCart || Object.keys(shopCart).length === 0) {
            cartBar.classList.remove('visible');
            setTimeout(() => { cartBar.style.display = 'none'; }, 300);
            // 如果购物车空了，也关闭详情弹窗
            getEl('detailed-cart-modal').classList.remove('visible');
            return;
        }

        const shop = takeoutData.shops.find(s => s.id === shopId);
        let totalItems = 0;
        let totalPrice = 0;

        for (const itemId in shopCart) {
            const count = shopCart[itemId];
            const item = shop.menu.find(i => i.id === itemId);
            totalItems += count;
            totalPrice += item.price * count;
        }

        getEl('cart-item-count').textContent = totalItems;
        getEl('cart-total-price').textContent = totalPrice.toFixed(2);
        
        cartBar.style.display = 'flex';
        setTimeout(() => { cartBar.classList.add('visible'); }, 10);
    }

    // 新增：渲染详细购物车弹窗
    function renderDetailedCartModal(shopId) {
        const modal = getEl('detailed-cart-modal');
        const list = getEl('detailed-cart-list');
        const shop = takeoutData.shops.find(s => s.id === shopId);
        const shopCart = currentCart[shopId];
        list.innerHTML = '';

        if (!shopCart || Object.keys(shopCart).length === 0) {
            modal.classList.remove('visible');
            return;
        }

        for (const itemId in shopCart) {
            const count = shopCart[itemId];
            const item = shop.menu.find(i => i.id === itemId);
            const itemDiv = document.createElement('div');
            itemDiv.className = 'detailed-cart-item';
            itemDiv.innerHTML = `
                <span class="item-name">${item.name}</span>
                <span class="item-price">¥${(item.price * count).toFixed(2)}</span>
                <div class="quantity-control">
                    <button class="btn-minus" data-item-id="${itemId}">-</button>
                    <span class="item-count">${count}</span>
                    <button class="btn-plus" data-item-id="${itemId}">+</button>
                </div>
            `;
            list.appendChild(itemDiv);
        }

        list.querySelectorAll('.btn-plus').forEach(btn => {
            btn.onclick = () => increaseCartItem(shopId, btn.dataset.itemId);
        });
        list.querySelectorAll('.btn-minus').forEach(btn => {
            btn.onclick = () => decreaseCartItem(shopId, btn.dataset.itemId);
        });
        
        modal.classList.add('visible');
    }

    // 新增：增加商品数量
    function increaseCartItem(shopId, itemId) {
        currentCart[shopId][itemId]++;
        updateCartView(shopId);
        renderDetailedCartModal(shopId); // 刷新弹窗内容
    }

    // 新增：减少商品数量
    function decreaseCartItem(shopId, itemId) {
        currentCart[shopId][itemId]--;
        if (currentCart[shopId][itemId] <= 0) {
            delete currentCart[shopId][itemId];
        }
        updateCartView(shopId);
        renderDetailedCartModal(shopId); // 刷新弹窗内容
    }

    function renderOrderConfirmPage() {
        currentOrderRecipient = { id: 'user_profile', name: userProfile.name };

        const shopId = currentTakeoutShopId;
        const shop = takeoutData.shops.find(s => s.id === shopId);
        const cart = currentCart[shopId];
        const content = getEl('order-confirm-content');

        let itemsHtml = '';
        let subtotal = 0;
        for (const itemId in cart) {
            const count = cart[itemId];
            const item = shop.menu.find(i => i.id === itemId);
            const itemTotal = item.price * count;
            subtotal += itemTotal;
            itemsHtml += `
                <div class="order-item-row">
                    <span class="item-name">${item.name}</span>
                    <div><span class="item-count">x${count}</span><span class="item-price" style="margin-left: 20px;">¥${itemTotal.toFixed(2)}</span></div>
                </div>`;
        }
        const total = subtotal + shop.deliveryFee;
        
        if (!userProfile.savedAddresses) userProfile.savedAddresses = [];
        const defaultAddress = userProfile.savedAddresses.length > 0 ? userProfile.savedAddresses[0] : '请输入详细地址...';

        content.innerHTML = `
            <div class="order-confirm-section">
                <div class="section-title">收货信息</div>
                <div class="form-group selectable" id="recipient-selector" style="padding: 10px 0; background: transparent;">
                    <label style="margin-bottom:0;">收货人</label>
                    <div class="form-value">
                        <span id="recipient-name-text">${userProfile.name} (我)</span>
                        <i class="fa-solid fa-chevron-right"></i>
                    </div>
                </div>
                <div class="form-group selectable" id="address-selector" style="padding: 10px 0; background: transparent; align-items: flex-start;">
                    <label>收货地址</label>
                    <div class="form-value" style="flex-direction: column; align-items: flex-end; text-align: right;">
                        <span id="address-value-text" style="white-space: pre-wrap;">${defaultAddress}</span>
                        <i class="fa-solid fa-chevron-right" style="margin-top: 5px;"></i>
                    </div>
                </div>
            </div>

            <div class="order-confirm-section">
                <div class="section-title">${shop.name}</div>
                ${itemsHtml}
                <div class="order-item-row" style="padding-top:10px; border-top: 1px solid var(--border-color);"><span >配送费</span><span>¥${shop.deliveryFee.toFixed(2)}</span></div>
                <div class="order-total-row">总计: <span>¥${total.toFixed(2)}</span></div>
            </div>
            
            <div class="form-actions-bar" style="margin-top: 20px;">
                <button id="request-payment-btn" class="btn-secondary" style="border-color: var(--accent-color); color: var(--accent-color);">找人代付</button>
                <button id="pay-now-btn" class="btn-save">立即付款 ¥${total.toFixed(2)}</button>
            </div>
        `;
        
        // ▼▼▼ 核心修复：重新为“收货人”选择器绑定事件 ▼▼▼
        getEl('recipient-selector').onclick = () => {
            const options = [{ value: 'user_profile', text: `${userProfile.name} (我)` }];
            contacts.friends.forEach(f => {
                options.push({ value: f.id, text: getDisplayName(f) });
            });
            
            showSelectionModal('选择收货人', options, currentOrderRecipient.id, (selectedId) => {
                if (selectedId === 'user_profile') {
                    currentOrderRecipient = { id: 'user_profile', name: userProfile.name };
                    getEl('recipient-name-text').textContent = `${userProfile.name} (我)`;
                } else {
                    const selectedFriend = findContactById(selectedId);
                    if (selectedFriend) {
                        currentOrderRecipient = { id: selectedFriend.id, name: getDisplayName(selectedFriend) };
                        getEl('recipient-name-text').textContent = getDisplayName(selectedFriend);
                    }
                }
            });
        };
        // ▲▲▲ 修复完成 ▲▲▲
        
        getEl('address-selector').onclick = () => showAddressPickerModal();

        const payNowBtn = getEl('pay-now-btn');
        if (userProfile.walletBalance < total) {
            payNowBtn.disabled = true;
            payNowBtn.textContent = '余额不足';
        } else {
            payNowBtn.onclick = () => placeOrder();
        }
        
        getEl('request-payment-btn').onclick = () => handleRequestPayment();
    }


    // ▼▼▼ 新增：显示地址选择/管理弹窗的函数 ▼▼▼
    function showAddressPickerModal() {
        const currentAddress = getEl('address-value-text').textContent;
        let optionsHtml = '';

        userProfile.savedAddresses.forEach(address => {
            const isSelected = address === currentAddress;
            optionsHtml += `
                <div class="address-picker-item ${isSelected ? 'selected' : ''}" data-address="${address}">
                    <span class="address-text">${address}</span>
                    <i class="fa-solid ${isSelected ? 'fa-circle-dot' : 'fa-circle'}"></i>
                </div>
            `;
        });

        // 增加一个“使用新地址”的选项
        optionsHtml += `<div class="address-picker-item" data-address="new"><span class="address-text" style="color: var(--accent-color);">+ 使用新地址</span></div>`;

        // 复用通用选择器弹窗来显示
        const modal = getEl('selection-modal');
        getEl('selection-modal-title').textContent = '选择收货地址';
        getEl('selection-options-list').innerHTML = optionsHtml;
        getEl('selection-modal-actions').style.display = 'none'; // 不需要确认按钮

        // 为每个选项绑定点击事件
        modal.querySelectorAll('.address-picker-item').forEach(item => {
            item.onclick = () => {
                const selected = item.dataset.address;
                modal.classList.remove('visible'); // 先关闭选择弹窗

                if (selected === 'new') {
                    // 如果是“使用新地址”，则弹出输入框
                    setTimeout(() => {
                        showEditInfoModal({
                            title: '输入新地址',
                            initialValue: '',
                            onSave: (newAddress) => {
                                if (newAddress) {
                                    getEl('address-value-text').textContent = newAddress;
                                }
                            }
                        });
                    }, 300); // 延迟执行以获得更好的动画效果
                } else {
                    // 如果是选择已有地址，则直接更新
                    getEl('address-value-text').textContent = selected;
                }
            };
        });
        
        modal.classList.add('visible');
    }
    // ▲▲▲ 新增完成 ▲▲▲


    function placeOrder() {
        const shopId = currentTakeoutShopId;
        // ▼▼▼ 核心修改：从新的UI元素获取地址 ▼▼▼
        const address = getEl('address-value-text').textContent.trim();
        if (!address || address === '请输入详细地址...') {
            showToast('请填写或选择一个有效的收货地址');
            return;
        }
        // ▲▲▲ 修改完成 ▲▲▲

        // ▼▼▼ 核心新增：自动保存新地址 ▼▼▼
        if (!userProfile.savedAddresses.includes(address)) {
            userProfile.savedAddresses.unshift(address); // 将新地址加到最前面
            if (userProfile.savedAddresses.length > 5) { // 最多保存5个地址
                userProfile.savedAddresses.pop();
            }
        }
        // ▲▲▲ 新增完成 ▲▲▲

        const shop = takeoutData.shops.find(s => s.id === shopId);
        // ...后续代码保持不变...
        const cart = currentCart[shopId];
        let subtotal = 0;
        for (const itemId in cart) {
            const count = cart[itemId];
            const item = shop.menu.find(i => i.id === itemId);
            subtotal += item.price * count;
        }
        const totalAmount = subtotal + shop.deliveryFee;

        const newOrder = {
            id: `order_${Date.now()}`,
            shopId: shopId,
            shopName: shop.name,
            items: { ...currentCart[shopId] },
            total: totalAmount,
            date: new Date().toISOString(),
            status: '已送达',
            recipientId: currentOrderRecipient.id,
            recipientName: currentOrderRecipient.name,
            recipientAddress: address
        };


        userProfile.walletBalance -= totalAmount;
        userProfile.walletHistory.push({
            type: 'expense', amount: totalAmount, reason: `外卖消费 (${shop.name})`, date: new Date().toISOString()
        });
        
        userProfile.orders.unshift(newOrder);
        saveUserProfile();

        delete currentCart[shopId];
        
        showToast('下单成功！');
        renderMyOrdersPage();
        showPage('page-takeout-my-orders');
    }

    function handleRequestPayment() {
        const address = getEl('recipient-address-input').value.trim();
        if (!address) {
            showToast('请填写收货地址');
            return;
        }

        const options = [];
        contacts.friends.forEach(f => {
            options.push({ value: f.id, text: getDisplayName(f) });
        });

        if (options.length === 0) {
            showToast('通讯录中没有好友，无法找人代付');
            return;
        }

        showSelectionModal('选择代付好友', options, null, (friendId) => {
            const friend = findContactById(friendId);
            if (!friend) return;

            // 准备订单信息，但不创建正式订单
            const shopId = currentTakeoutShopId;
            const shop = takeoutData.shops.find(s => s.id === shopId);
            const cart = currentCart[shopId];
            let subtotal = 0;
            for (const itemId in cart) {
                const item = shop.menu.find(i => i.id === itemId);
                subtotal += item.price * cart[itemId];
            }
            const totalAmount = subtotal + shop.deliveryFee;

            const paymentRequestContent = {
                requesterId: 'user_profile',
                requesterName: userProfile.name,
                recipientId: currentOrderRecipient.id,
                recipientName: currentOrderRecipient.name,
                recipientAddress: address,
                shopId: shopId,
                shopName: shop.name,
                items: { ...cart },
                total: totalAmount,
            };
            
            // 查找或创建对话
            let conversation = conversations.find(c => c.contactId === friendId);
            if (!conversation) {
                conversation = { id: `conv_${Date.now()}`, contactId: friendId, type: 'friend', history: [], lastActivity: Date.now() };
                conversations.push(conversation);
            }
            
            // 发送代付请求消息
            currentConversationId = conversation.id;
            addMessageToChat('user', paymentRequestContent, true, { type: 'takeout_payment_request' });

            // 清空当前店铺的购物车
            delete currentCart[shopId];
            
            showToast(`已向 ${getDisplayName(friend)} 发送代付请求`);
            openConversation(conversation.id);
        });
    }
    function showPlayerPaymentConfirmModal(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const requestMsg = conversation?.history.find(m => m.id === messageId);
        if (!requestMsg) return;

        const orderData = requestMsg.content;
        const modal = getEl('player-pay-confirm-modal');
        const title = getEl('player-pay-confirm-title');
        const body = getEl('player-pay-confirm-body');
        const confirmBtn = getEl('player-pay-confirm-btn');
        const cancelBtn = getEl('player-pay-cancel-btn');

        title.textContent = `为 ${orderData.requesterName} 付款`;

        let itemsHtml = '';
        for (const itemId in orderData.items) {
            const count = orderData.items[itemId];
            const item = takeoutData.shops.find(s => s.id === orderData.shopId)?.menu.find(i => i.id === itemId);
            if(item) itemsHtml += `<p style="display:flex; justify-content: space-between; margin: 4px 0;"><span>${item.name} x${count}</span> <span>¥${(item.price * count).toFixed(2)}</span></p>`;
        }

        body.innerHTML = `
            <div style="padding: 0 15px;">
                <p style="font-weight: 600;">${orderData.shopName}</p>
                ${itemsHtml}
                <hr style="border: none; border-top: 1px solid var(--border-color); margin: 8px 0;">
                <p style="text-align: right; font-size: 1.2rem; font-weight: 600;">总计: <span style="color: var(--danger-color)">¥${orderData.total.toFixed(2)}</span></p>
            </div>
        `;
        
        if (userProfile.walletBalance < orderData.total) {
            confirmBtn.disabled = true;
            confirmBtn.textContent = '余额不足';
        } else {
            confirmBtn.disabled = false;
            confirmBtn.textContent = '豪爽买单';
        }

        confirmBtn.onclick = () => executePlayerPaymentForFriend(messageId);
        cancelBtn.onclick = () => modal.classList.remove('visible');
        
        modal.classList.add('visible');
    }

      function executePlayerPaymentForFriend(messageId) {
        const conversation = conversations.find(c => c.id === currentConversationId);
        const requestMsg = conversation?.history.find(m => m.id === messageId);
        if (!requestMsg) return;

        const orderData = requestMsg.content;
        
        // 1. 扣款并记录
        userProfile.walletBalance -= orderData.total;
        userProfile.walletHistory.push({
            type: 'expense', amount: orderData.total, reason: `为 ${orderData.requesterName} 的外卖付款`, date: new Date().toISOString()
        });

        // 2. 创建正式订单
        const newOrder = {
            id: `order_${Date.now()}`,
            ...orderData,
            date: new Date().toISOString(),
            status: '已送达',
            payerId: 'user_profile'
        };
        userProfile.orders.unshift(newOrder);
        saveUserProfile();

        // 3. 准备并发送已付款的分享卡片
        const shareContent = {
            orderId: newOrder.id, shopId: newOrder.shopId, shopName: newOrder.shopName, items: newOrder.items, total: newOrder.total
        };
        addMessageToChat('user', shareContent, true, { type: 'takeout_share' });

        // ▼▼▼ 核心修复：在这里补上关闭弹窗的指令 ▼▼▼
        getEl('player-pay-confirm-modal').classList.remove('visible');
        // ▲▲▲ 修复完成 ▲▲▲
        
        showToast('支付成功！');
        triggerAiResponse();
    }


    function renderMyOrdersPage() {
        const content = getEl('my-orders-content');
        if (!userProfile.orders || userProfile.orders.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>还没有订单记录哦~</p></div>';
            return;
        }

        let ordersHtml = '';
        userProfile.orders.forEach(order => {
            let actionsHtml = '';
            if (order.status === '已送达') {
                actionsHtml = `<button data-order-id="${order.id}" class="refund-btn">申请退款</button>`;
                if (order.recipientId && order.recipientId !== 'user_profile') {
                    actionsHtml += ` <button data-order-id="${order.id}" data-recipient-id="${order.recipientId}" class="share-btn btn-primary">分享给TA</button>`;
                } else {
                    actionsHtml += ` <button data-order-id="${order.id}" class="review-btn btn-primary">评价</button>`;
                    actionsHtml += ` <button data-order-id="${order.id}" class="share-btn btn-primary">分享</button>`;
                }
            } else if (order.status === '已退款') {
                 actionsHtml = `<span>已全额退款</span>`;
            } else if (order.status === '已评价') {
                 actionsHtml = `<span>已完成评价</span>`;
            }

            const isForSelf = !order.recipientId || order.recipientId === 'user_profile';
            const recipientInfo = isForSelf ? '' : `<div style="font-weight: 500; color: var(--accent-color);">为 ${order.recipientName} 点的餐</div>`;

            // 核心修改：为整个订单项增加 data-order-id 属性
            ordersHtml += `
                <div class="my-order-item" data-order-id="${order.id}">
                    <div class="order-header">
                        <span class="shop-name">${order.shopName}</span>
                        <span class="status">${order.status}</span>
                    </div>
                    <div class="order-body">
                        ${recipientInfo}
                        <div>下单时间: ${new Date(order.date).toLocaleString()}</div>
                        <div>收货地址: ${order.recipientAddress}</div>
                    </div>
                    <div class="order-footer">
                        <span class="total">¥${order.total.toFixed(2)}</span>
                        <div class="actions">${actionsHtml}</div>
                    </div>
                </div>
            `;
        });
        content.innerHTML = ordersHtml;

        // 核心新增：为整个订单项绑定点击事件，用于跳转详情页
        content.querySelectorAll('.my-order-item').forEach(item => {
            item.addEventListener('click', (e) => {
                // 如果点击的是按钮，则不触发跳转
                if (e.target.tagName === 'BUTTON') return;
                
                orderDetailReturnPath = 'page-takeout-my-orders'; // 设置“路标”
                renderTakeoutOrderDetailsPage(item.dataset.orderId);
                showPage('page-takeout-order-details');
            });
        });

        // 按钮的事件绑定保持不变
        content.querySelectorAll('.refund-btn').forEach(btn => btn.onclick = () => handleRefundOrder(btn.dataset.orderId));
        content.querySelectorAll('.review-btn').forEach(btn => btn.onclick = () => handleReviewOrder(btn.dataset.orderId));
        content.querySelectorAll('.share-btn').forEach(btn => btn.onclick = () => {
            const orderId = btn.dataset.orderId;
            const recipientId = btn.dataset.recipientId;
            if (recipientId) {
                handleShareOrder(orderId, recipientId);
            } else {
                showFriendPickerForSharing(orderId);
            }
        });
    }




    function handleRefundOrder(orderId) {
        const order = userProfile.orders.find(o => o.id === orderId);
        if (!order) return;

        showConfirmModal('确认退款', `确定要为这笔 ¥${order.total.toFixed(2)} 的订单申请退款吗？款项将原路退回钱包。`, () => {
            // 退款
            userProfile.walletBalance += order.total;
            userProfile.walletHistory.push({
                type: 'income',
                amount: order.total,
                reason: `外卖退款 (${order.shopName})`,
                date: new Date().toISOString()
            });

            // 更新订单状态
            order.status = '已退款';
            saveUserProfile();
            
            showToast('退款成功！');
            renderMyOrdersPage();
            getEl('confirm-modal').classList.remove('visible');
        });
    }

        function handleReviewOrder(orderId) {
        const order = userProfile.orders.find(o => o.id === orderId);
        if (!order) return;

        const modal = getEl('review-modal');
        const textarea = getEl('review-textarea');
        const checkbox = getEl('anonymous-review-checkbox');
        const cancelBtn = getEl('cancel-review-btn');
        const submitBtn = getEl('submit-review-btn');

        textarea.value = '';
        checkbox.checked = false; // 默认不匿名
        modal.classList.add('visible');

        const submitHandler = () => {
            const reviewText = textarea.value.trim();
            if (!reviewText) {
                showToast('评价内容不能为空');
                return;
            }

            if (!takeoutData.reviews[order.shopId]) {
                takeoutData.reviews[order.shopId] = [];
            }
            
            // 核心逻辑：根据复选框状态决定作者ID
            const authorId = checkbox.checked ? 'anonymous_user' : 'user_profile';

            takeoutData.reviews[order.shopId].push({
                authorId: authorId,
                text: reviewText
            });

            order.status = '已评价';
            saveUserProfile();

            showToast('感谢您的评价！');
            renderMyOrdersPage(); // 刷新当前订单页
            closeHandler();
        };

        const closeHandler = () => {
            modal.classList.remove('visible');
            submitBtn.removeEventListener('click', submitHandler);
            cancelBtn.removeEventListener('click', closeHandler);
        };

        submitBtn.addEventListener('click', submitHandler);
        cancelBtn.addEventListener('click', closeHandler);
    }

    // 新增：处理分享订单的函数
    function handleShareOrder(orderId, recipientId) {
        const order = userProfile.orders.find(o => o.id === orderId);
        const friend = contacts.friends.find(f => f.id === recipientId);
        if (!order || !friend) {
            showToast('无法分享，订单或好友信息丢失');
            return;
        }

        // 查找或创建与该好友的对话
        let conversation = conversations.find(c => c.contactId === recipientId && c.type === 'friend');
        if (!conversation) {
            conversation = { id: `conv_${Date.now()}`, contactId: recipientId, type: 'friend', history: [], lastActivity: Date.now() };
            conversations.push(conversation);
        }

        // 【关键修复】在添加消息前，先将会话ID设置为目标好友的会话
        currentConversationId = conversation.id;

                // 准备要分享的消息内容
        const messageContent = {
            orderId: order.id,
            shopId: order.shopId, // 【关键修复】把店铺ID也加进去
            shopName: order.shopName,
            items: order.items, // 将商品详情也一并传入
            total: order.total
        };


        // 发送特殊类型的消息（现在它知道要发给谁了）
        addMessageToChat('user', messageContent, true, { type: 'takeout_share' });
        
        showToast(`已将订单分享给 ${getDisplayName(friend)}`);
        
        // 最后再跳转到聊天页面
        openConversation(conversation.id);
    }
    // 新增：弹出好友选择列表用于分享
    function showFriendPickerForSharing(orderId) {
        const order = userProfile.orders.find(o => o.id === orderId);
        if (!order) return;

        const options = [];
        contacts.friends.forEach(f => {
            options.push({ value: f.id, text: getDisplayName(f) });
        });

        if (options.length === 0) {
            showToast('通讯录中还没有好友，无法分享');
            return;
        }

        // 复用通用的选择器弹窗
        showSelectionModal('选择要分享的好友', options, null, (friendId) => {
            handleShareOrder(orderId, friendId);
        });
    }


    
    // 新增：渲染订单详情页的函数
    function renderTakeoutOrderDetailsPage(orderId) {
        const order = userProfile.orders.find(o => o.id === orderId);
        if (!order) {
            getEl('takeout-order-details-content').innerHTML = '<p>订单信息未找到</p>';
            return;
        }

        const shop = takeoutData.shops.find(s => s.id === order.shopId);
        const content = getEl('takeout-order-details-content');
        
        let itemsHtml = '';
        let subtotal = 0;
        for (const itemId in order.items) {
            const count = order.items[itemId];
            const item = shop.menu.find(i => i.id === itemId);
            if (item) { // 安全检查
                const itemTotal = item.price * count;
                subtotal += itemTotal;
                itemsHtml += `<div class="order-item-row"><span>${item.name}</span><span>x${count}</span></div>`;
            }
        }

        // ▼▼▼ 核心修改：在这里加入评价按钮的生成逻辑 ▼▼▼
        let actionButtonHtml = '';
        // 只有是自己点的餐、且状态是“已送达”时，才显示评价按钮
        if (order.status === '已送达' && (!order.recipientId || order.recipientId === 'user_profile')) {
            actionButtonHtml = `<button id="review-order-btn" class="btn-primary" style="width: 100%; padding: 14px; border-radius: 25px; border: none; font-size: 1rem; font-weight: 600; cursor: pointer; margin-top: 20px;">去评价</button>`;
        }
        // ▲▲▲ 修改完成 ▲▲▲

        content.innerHTML = `
            <div class="order-confirm-section">
                <div class="section-title">配送信息</div>
                <div class="order-item-row"><span>收货人</span><span>${order.recipientName}</span></div>
                <div class="order-item-row" style="align-items: flex-start;"><span>地址</span><span style="text-align: right; max-width: 70%;">${order.recipientAddress}</span></div>
            </div>
            <div class="order-confirm-section">
                <div class="section-title">${order.shopName}</div>
                ${itemsHtml}
                <div class="order-item-row" style="padding-top:10px; border-top: 1px solid var(--border-color);"><span>配送费</span><span>¥${(order.total - subtotal).toFixed(2)}</span></div>
                <div class="order-total-row">实付: <span>¥${order.total.toFixed(2)}</span></div>
            </div>
            ${actionButtonHtml}
        `;
        
        // 如果评价按钮存在，就为它绑定事件
        const reviewBtn = getEl('review-order-btn');
        if (reviewBtn) {
            reviewBtn.onclick = () => handleReviewOrder(orderId);
        }
    }



    // ==========================================================
    // ==========================================================
    //              直播功能核心逻辑 (V2.0 重构)
    // ==========================================================
    // ==========================================================

            function loadLiveStreamData() {
        let loadedData = [];
        try {
            const rawData = localStorage.getItem('aiLiveStreamData');
            if (rawData) {
                loadedData = JSON.parse(rawData);
            }
        } catch (e) {
            console.error("解析主播数据失败:", e);
            loadedData = [];
        }

        if (!Array.isArray(loadedData) || loadedData.length === 0) {
            loadedData = [
                { id: 'streamer001', name: '桃桃酱', avatar: 'https://s2.loli.net/2023/05/23/9N25XbYVdDgrzQj.png', title: '今天来唱几首歌～', isLive: true, followers: '1.2w', viewers: 1234 },
                { id: 'streamer002', name: '晚风', avatar: 'https://s2.loli.net/2023/05/23/gM3FPAfWk1vYc8z.png', title: '深夜闲聊时刻', isLive: true, followers: '8.8k', viewers: 890 },
                { id: 'streamer003', name: '小鹿', avatar: 'https://s2.loli.net/2024/03/10/2qj8fO14QxYgVlS.png', title: '游戏时间！冲！', isLive: false, followers: '2.5w', viewers: 0 },
                { id: 'streamer004', name: '晴天', avatar: 'https://s2.loli.net/2023/05/23/9N25XbYVdDgrzQj.png', title: '新来的，有人吗？', isLive: true, followers: '102', viewers: 15 },
            ];
        }

        // ▼▼▼ 核心升级：为没有房管的主播分配一个 ▼▼▼
              const availableManagers = [...ROOM_MANAGER_NAMES].sort(() => 0.5 - Math.random());
        loadedData.forEach(streamer => {
            // 分配房管
            if (!streamer.roomManager && availableManagers.length > 0) {
                streamer.roomManager = availableManagers.pop();
            }
            // ▼▼▼ 核心新增：初始化打赏榜“账本” ▼▼▼
            if (!streamer.giftLeaderboard) {
                streamer.giftLeaderboard = {}; // 如果没有，就创建一个空对象
            }
            // ▲▲▲ 新增完成 ▲▲▲
        });


        liveStreamData = loadedData;
        saveLiveStreamData(); // 保存可能已更新的数据
    }



        function saveLiveStreamData() {
        localStorage.setItem('aiLiveStreamData', JSON.stringify(liveStreamData));
    }

    // ▼▼▼ 核心新增 1/4：“弹幕大脑”数据池 ▼▼▼
        const VIEWER_NAMES = [
        '夏天的一阵风', '猫咪不吃鱼', '熬夜选手', '可乐加冰', '芝士就是力量', '甜筒掉在地上', '一只小懒猪', '今天没吃饭', '想吃火锅了', '数字漫游者', '星辰下的旅人', '月亮打烊了', '云朵有点甜', '爱喝奶茶的熊', '打代码的小明', '隔壁班的同学', '只想搞钱', '踩着星星奔向你', '人间观察员', '快乐小狗', '碳水脑袋', '摸鱼艺术家', '互联网嘴替', '吃瓜第一线', '熬夜冠军', '快乐星球居民', '逃跑的泡芙', '迷路的麋鹿', '一颗西柚', '半杯布丁', '晚风轻踩着云', '月亮供电不足', '星星泡饭', '银河小铁骑', '官方认证小可爱', '人间凑数选手', '不想上班的打工人', '平平无奇小天才', '宇宙一级潜在鸽王', '干饭公司董事长'
    ];

    // ▼▼▼ 新增：房管名单和台词库 ▼▼▼
    const ROOM_MANAGER_NAMES = [
        '守护最好的TA', '直播间纠察队', '首席执行官', '气氛组组长', '榜一的守护', '头号粉丝', '御用管理员', '禁言小能手'
    ];

    const MANAGER_COMMENT_TEMPLATES = [
        '欢迎新来的宝宝们，点点关注不迷路哦~',
        '大家弹幕刷起来，让我看到你们的热情！',
        '喜欢主播的可以送点小礼物支持一下呀！',
        '请大家文明发言，不要吵架哦。',
        '主播太棒了！这波操作666！',
        '还没点关注的家人左上角点一下关注哦！',
        '今天人气好高呀，大家多互动！'
    ];

    // ▼▼▼ 新增：豪华礼物喝彩台词库 ▼▼▼
    const LUXURY_GIFT_REACTIONS = [
        "哇！感谢 [SENDER] 送的 [GIFT]！老板大气！",
        "我看到了什么！是野生的 [GIFT] 吗？",
        "[SENDER] 太强了，一上来就送 [GIFT]！",
        "捕捉野生大佬 [SENDER]！",
        "这个 [GIFT] 特效也太酷了吧！",
        "主播牌面拉满了！感谢 [SENDER]！",
        "66666，[SENDER] 牛！",
        "前排围观神豪 [SENDER]！",
        "吸一口大佬 [SENDER] 的欧气！"
    ];

    // ▼▼▼ 新增：商品批发市场数据源 ▼▼▼
    const WHOLESALE_MARKET = {
        "🌸 美妆个护": [
            { id: 'w_mkp_01', name: '樱花限定口红', description: '春日烂漫，一抹倾心。', cost: 28.5 },
            { id: 'w_mkp_02', name: '白桃气泡护手霜', description: '清爽不油腻，双手水润Q弹。', cost: 12.0 },
            { id: 'w_mkp_03', name: '玫瑰纯露爽肤水', description: '补水保湿，提亮肤色，晨间唤醒肌肤。', cost: 35.0 },
            { id: 'w_mkp_04', name: '氨基酸洗面奶', description: '温和洁净，泡沫绵密，敏感肌适用。', cost: 25.8 },
            { id: 'w_mkp_05', name: '山茶花卸妆油', description: '以油溶妆，乳化迅速，轻松卸除浓妆。', cost: 42.0 },
            { id: 'w_mkp_06', name: '胶原蛋白眼膜', description: '淡化细纹，改善黑眼圈，焕发眼周活力。', cost: 18.9 },
            { id: 'w_mkp_07', name: '草莓味身体磨砂膏', description: '去除角质，肌肤丝滑如新生。', cost: 29.9 },
            { id: 'w_mkp_08', name: '便携美妆蛋套装', description: '干湿两用，上妆服帖不卡粉。', cost: 9.9 },
            { id: 'w_mkp_09', name: '防晒喷雾SPF50+', description: '清爽肤感，长效防护，户外必备。', cost: 38.0 },
            { id: 'w_mkp_10', name: '晚安冻膜', description: '夜间修护，锁住水分，懒人护肤神器。', cost: 33.5 }
        ],
        "🍬 零食甜点": [
            { id: 'w_fod_01', name: '手工草莓牛轧糖', description: '奶香浓郁，果粒饱满，甜而不腻。', cost: 15.8 },
            { id: 'w_fod_02', name: '抹茶味曲奇饼干', description: '茶香酥脆，回味悠长，下午茶绝配。', cost: 19.9 },
            { id: 'w_fod_03', name: '海盐荔枝味薯片', description: '咸甜交织，果香清新，好吃到停不下来。', cost: 5.5 },
            { id: 'w_fod_04', name: '网红脏脏包', description: '可可粉与浓郁巧克力的双重暴击。', cost: 8.0 },
            { id: 'w_fod_05', name: '冻干水果酸奶块', description: '多种水果，营养美味，健康小零食。', cost: 22.5 },
            { id: 'w_fod_06', name: '小熊软糖', description: 'Q弹可爱，多种水果口味。', cost: 6.8 },
            { id: 'w_fod_07', name: '辣味魔芋爽', description: '低卡解馋，香辣过瘾。', cost: 7.5 },
            { id: 'w_fod_08', name: '炭烧猪肉脯', description: '肉质紧实，咸香微甜。', cost: 25.0 },
            { id: 'w_fod_09', name: '夏威夷果仁', description: '颗颗饱满，奶香酥脆。', cost: 30.0 },
            { id: 'w_fod_10', name: '半熟芝士蛋糕', description: '入口即化，轻盈绵密。', cost: 12.0 }
        ],
        "🎀 可爱杂货": [
            { id: 'w_gro_01', name: '毛绒兔子挂件', description: '手感柔软，可挂在包包或钥匙上。', cost: 11.0 },
            { id: 'w_gro_02', name: '奶油胶手机壳DIY材料包', description: '亲手制作独一无二的手机壳。', cost: 25.5 },
            { id: 'w_gro_03', name: 'ins风手账贴纸套装', description: '多种图案，装点你的手账生活。', cost: 7.9 },
            { id: 'w_gro_04', name: '玻璃吸管杯', description: '带刻度，高颜值，环保又健康。', cost: 18.0 },
            { id: 'w_gro_05', name: '云朵形状小夜灯', description: '光线柔和，伴你入眠。', cost: 22.0 },
            { id: 'w_gro_06', name: '猫爪便签本', description: '可爱造型，让学习办公更有趣。', cost: 5.0 },
            { id: 'w_gro_07', name: '香薰蜡烛', description: '多种香型可选，舒缓压力，营造氛围。', cost: 35.0 },
            { id: 'w_gro_08', name: '桌面收纳盒', description: '告别杂乱，让桌面整洁有序。', cost: 15.0 },
            { id: 'w_gro_09', name: '长柄透明雨伞', description: '雨天也能拥有好心情。', cost: 28.0 },
            { id: 'w_gro_10', name: '动漫角色吧唧', description: '随机款式，体验开盲盒的乐趣。', cost: 9.0 }
        ],
        // ▼▼▼ 新增分类：解压萌物 ▼▼▼
        "✨ 解压萌物": [
            { id: 'w_toy_01', name: '草莓大福捏捏', description: '软糯Q弹，无限回弹，解压神器。', cost: 16.8 },
            { id: 'w_toy_02', name: '尖叫鸡', description: '魔性叫声，释放所有不开心。', cost: 9.9 },
            { id: 'w_toy_03', name: '磁力巴克球', description: '百变造型，锻炼专注力与创造力。', cost: 32.0 },
            { id: 'w_toy_04', name: '泡泡机', description: '一键出泡，营造梦幻氛围。', cost: 19.9 },
            { id: 'w_toy_05', name: '指尖陀螺', description: '金属质感，持久旋转。', cost: 15.0 },
            { id: 'w_toy_06', name: '无限方块', description: '无限翻转，缓解焦虑。', cost: 12.5 },
            { id: 'w_toy_07', name: '猫咪肉球捏捏乐', description: '仿真肉球，手感超治愈。', cost: 8.8 },
            { id: 'w_toy_08', name: '起泡胶/史莱姆', description: '拉伸揉捏，声音解压。', cost: 14.0 },
            { id: 'w_toy_09', name: '桌面拳击球', description: '压力大的时候来一拳。', cost: 25.0 },
            { id: 'w_toy_10', name: '迷你麻将', description: '小巧便携，随时随地搓一把。', cost: 38.0 }
        ],
        // ▼▼▼ 新增分类：电子潮玩 ▼▼▼
        "🎧 电子潮玩": [
            { id: 'w_ele_01', name: '猫耳头戴式蓝牙耳机', description: '会发光的猫耳，萌力十足。', cost: 88.0 },
            { id: 'w_ele_02', name: '复古像素风小音箱', description: '既是音箱，也是桌面像素画板。', cost: 128.0 },
            { id: 'w_ele_03', name: '便携照片打印机', description: '随时随地打印手机里的照片。', cost: 299.0 },
            { id: 'w_ele_04', name: '桌面暖风机', description: '冬日里的温暖小太阳。', cost: 69.0 },
            { id: 'w_ele_05', name: 'USB加湿器', description: '缓解空调房干燥，静音运行。', cost: 45.0 },
            { id: 'w_ele_06', name: '手持小风扇', description: '夏日出行必备，多档风力可调。', cost: 29.9 },
            { id: 'w_ele_07', name: '智能感应垃圾桶', description: '挥手即开，无需接触，干净卫生。', cost: 79.0 },
            { id: 'w_ele_08', name: '电动牙刷', description: '声波震动，清洁更彻底。', cost: 99.0 },
            { id: 'w_ele_09', name: '手机散热背夹', description: '游戏玩家福音，告别手机发烫。', cost: 58.0 },
            { id: 'w_ele_10', name: '桌面无线充电座', description: '随放随充，告别线材束缚。', cost: 75.0 }
        ]
    };

    // ▲▲▲ 新增完成 ▲▲▲


        const COMMENT_TEMPLATES = {
        '通用': {
            '通用': ['来了来了', '前排围观', '主播好呀', '今天播什么呀？', '这是什么神仙主播', '关注了关注了', '哈哈哈', '666', '学到了', '太强了', '人气好高呀', '新来的，请多关照', '晚上好~'],
            '男': ['主播帅啊', '哥，抽个粉丝送礼物呗'],
            '女': ['姐姐好漂亮！', '小姐姐声音真好听']
        },
        '游戏': {
            '通用': ['这波操作秀啊', '上装备！', '打他打他！', '这都能反杀？', '求同款键盘', '主播技术真好', '这游戏叫什么名字？', '带我一个！', '这皮肤好看'],
            '男': ['哥，你这意识绝了', '带妹吗主播？'],
            '女': ['小姐姐玩游戏也这么厉害吗', '仙女玩游戏都这么猛的吗']
        },
        '美妆': {
            '通用': ['求口红色号！', '这个眼影盘是什么牌子的？', '学到了学到了', '手残党表示看会了，手没会', '这个妆好日常', '刷子有链接吗？', '底妆好干净啊', '皮肤也太好了吧'],
            '男': ['男生也可以学吗？', '给我女朋友买一套'],
            '女': ['姐姐开个课吧！', '这个颜色好显白', '马上就去下单！']
        },
        '唱歌': {
            '通用': ['开口跪！', '耳朵怀孕了', '这首歌叫什么？', '求歌单', '已加入收藏', '主播是专业歌手吗？', '再来一首！', '安可！安可！', '这是原唱吧？'],
            '男': ['小哥哥声音好苏', '爱了爱了'],
            '女': ['仙女唱歌就是不一样', '人美歌甜']
        },
        '跳舞': {
            '通用': ['这腰也太细了', '好会扭', '卡点好准', '动作好丝滑', '我也想学！', '太顶了', '这体力也太好了', '表情管理满分'],
            '男': ['哥，腹肌秀一下？', '这力度，绝了'],
            '女': ['姐姐身材好好', '好有力量感的美']
        },
        '聊天': {
            '通用': ['主播三观好正', '确实是这样', '有道理', '学到了', '主播好温柔', '今天也好治愈', '听主播聊天好舒服', '可以讲讲xxx吗？'],
            '男': ['哥，你太懂了', '格局打开了'],
            '女': ['姐姐好会说', '狠狠共情了']
        },
        '美食': {
            '通用': ['看饿了...', '深夜放毒！', '这也太会吃了吧', '求店名地址', '看着好好吃啊', '口水流下来了', '咕噜咕噜', '明天就去吃！'],
            '男': ['哥，给兄弟也整一个', '会吃'],
            '女': ['姐姐怎么吃都不胖吗', '太有食欲了']
        },
        // ▼▼▼ 新增内容从这里开始 ▼▼▼
        '画画': {
            '通用': ['大佬的画好有感觉', '这是什么板子呀？', '笔刷可以分享一下吗', '这光影绝了', '构图好棒', '太太好会画', '神仙画画', '眼睛：我会了。手：不，你不会。', '这张画要画多久啊？'],
            '男': ['大佬收徒吗？', '哥，画得好帅'],
            '女': ['太太画风好戳我', '姐姐的手是天使的手吧']
        },
        '哄睡': {
            '通用': ['来了来了，准备睡觉', '声音好助眠', '晚安', '听着好安心', '已经开始困了', '这个故事好棒', '明天也要加油呀', '谢谢主播', '（弹幕自动静音）'],
            '男': ['哥哥晚安', '这声音，睡了睡了'],
            '女': ['姐姐晚安~', '小姐姐声音好温柔']
        },
        '钢琴': {
            '通用': ['好好听！', '是肖邦的夜曲吗？', '太治愈了', '大佬的手指好灵活', '这首曲子叫什么名字？', '现场版就是不一样', '可以点一首《卡农》吗？', '听得我鸡皮疙瘩都起来了', '优雅，实在是太优雅了'],
            '男': ['弹钢琴的男人好有魅力', '哥，太帅了'],
            '女': ['姐姐好有气质', '是仙女在弹琴吧']
        }
        // ▲▲▲ 新增内容到这里结束 ▲▲▲
    };


    // ▼▼▼ 核心升级：礼物图标精装修完成版 ▼▼▼
    const GIFT_DATABASE = [
        // --- 常规礼物 (共8种) ---
        { name: '小心心', price: 0.1, icon: 'fa-regular fa-heart' },
        { name: '荧光棒', price: 0.3, icon: 'fa-solid fa-lightbulb' },
        { name: '棒棒糖', price: 0.5, icon: 'fa-solid fa-candy-cane' },
        { name: '小话筒', price: 0.8, icon: 'fa-solid fa-microphone' },
        { name: '小星星', price: 1.0, icon: 'fa-solid fa-star' },
        { name: '曲奇饼', price: 1.2, icon: 'fa-solid fa-cookie-bite' },
        { name: '甜甜圈', price: 1.5, icon: 'fa-solid fa-stroopwafel' },
        { name: '冰淇淋', price: 1.8, icon: 'fa-solid fa-ice-cream' },

        // --- 甜心礼物 (共12种) ---
        { name: '纸飞机', price: 2.5, icon: 'fa-solid fa-paper-plane' },
        { name: '四叶草', price: 3.3, icon: 'fa-solid fa-clover' },
        { name: '蝴蝶结', price: 4.5, icon: 'fa-solid fa-ribbon' },
        { name: '情书', price: 5.2, icon: 'fa-solid fa-envelope-open-text' },
        { name: '草莓蛋糕', price: 6.6, icon: 'fa-solid fa-cake-candles' },
        { name: '魔法棒', price: 7.7, icon: 'fa-solid fa-wand-magic' },
        { name: '告白气球', price: 8.8, icon: 'fa-solid fa-heart-circle-bolt' },
        { name: '月亮船', price: 9.9, icon: 'fa-solid fa-sailboat' },
        { name: '钻石', price: 10.0, icon: 'fa-solid fa-gem' },
        { name: '一生一世', price: 13.14, icon: 'fa-solid fa-infinity' },
        { name: '水晶鞋', price: 16.6, icon: 'fa-solid fa-shoe-prints' }, 
        { name: '旋转木马', price: 18.8, icon: 'fa-solid fa-horse-head' },

        // --- 豪华礼物 (共11种) ---
        { name: '为你加冕', price: 66.6, icon: 'fa-solid fa-crown' },
        { name: '豪华跑车', price: 88.8, icon: 'fa-solid fa-car-side' },
        { name: '爱的火山', price: 168.8, icon: 'fa-solid fa-volcano' },
        { name: '梦幻城堡', price: 188.8, icon: 'fa-solid fa-chess-rook' },
        { name: '天使之翼', price: 288.8, icon: 'fa-solid fa-dove' },
        { name: '恶魔之翼', price: 333.3, icon: 'fa-solid fa-crow' },
        { name: '星际火箭', price: 388.8, icon: 'fa-solid fa-rocket' },
        { name: '我爱你', price: 520.0, icon: 'fa-solid fa-heart-pulse' },
        { name: '豪华游轮', price: 666.6, icon: 'fa-solid fa-ship' },
        { name: '至尊权杖', price: 999.9, icon: 'fa-solid fa-wand-sparkles' },
        { name: '行星环绕', price: 1314.0, icon: 'fa-solid fa-atom' }
    ];

    // ▲▲▲ 升级完成 ▲▲▲




    function renderLiveStreamPage(defaultTab = 'recommended') {
        const tabs = document.querySelectorAll('#live-stream-tabs .contact-tab');
        const headerActions = getEl('live-stream-header-actions');
        
        const switchTab = (tabName) => {
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelector(`#live-stream-tabs .contact-tab[data-tab="${tabName}"]`).classList.add('active');
            
            document.querySelectorAll('.live-tab-content').forEach(c => c.classList.remove('active'));
            getEl(`live-${tabName}-content`).classList.add('active');

            // 核心修复：控制右上角按钮的显示/隐藏
            headerActions.style.display = (tabName === 'recommended') ? 'block' : 'none';

            if (tabName === 'recommended') {
                renderLiveRecommendedTab();
            } else if (tabName === 'following') {
                renderFollowingStreamTab(); // 新增：渲染关注页
            } else if (tabName === 'my') {
                renderMyStreamTab();
            }
        };

        tabs.forEach(tab => {
            tab.onclick = () => switchTab(tab.dataset.tab);
        });

        switchTab(defaultTab);
    }
    // 新增：粉丝数转换函数，用于排序
    function parseFollowers(followerStr) {
        if (typeof followerStr !== 'string') return 0;
        const lowerCaseStr = followerStr.toLowerCase().trim();
        let num = parseFloat(lowerCaseStr);
        if (isNaN(num)) return 0;

        if (lowerCaseStr.includes('w')) {
            num *= 10000;
        } else if (lowerCaseStr.includes('k')) {
            num *= 1000;
        }
        return num;
    }


       // 新增：显示主播卡片操作菜单的函数
    function showStreamerContextMenu(streamerId, event) {
        const menu = getEl('streamer-context-menu');
        menu.style.display = 'block';

        const btnRect = event.target.getBoundingClientRect();
        const appRect = appContainer.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();

        // 计算菜单位置，让它出现在按钮旁边
        let top = btnRect.top - appRect.top - menuRect.height - 4;
        let left = btnRect.right - appRect.left - menuRect.width;
        if (top < 10) { // 如果上方空间不够，就显示在下方
            top = btnRect.bottom - appRect.top + 4;
        }

        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;

        // 动态为菜单项绑定功能
        getEl('menu-item-streamer-edit').onclick = () => {
            menu.style.display = 'none';
            renderEditStreamerPage(streamerId);
            showPage('page-edit-streamer');
        };

        getEl('menu-item-streamer-delete').onclick = () => {
            menu.style.display = 'none';
            showConfirmModal('确认删除', '确定要删除这个直播间吗？此操作无法撤销。', () => {
                liveStreamData = liveStreamData.filter(s => s.id !== streamerId);
                saveLiveStreamData();
                renderLiveRecommendedTab();
                getEl('confirm-modal').classList.remove('visible');
                showToast('直播间已删除');
            });
        };

        // 点击页面其他地方，菜单自动消失
        const hideMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.style.display = 'none';
                document.removeEventListener('click', hideMenu, true);
            }
        };
        setTimeout(() => document.addEventListener('click', hideMenu, true), 0);
    }

    function renderLiveRecommendedTab() {
        const content = getEl('live-recommended-content');
        
        const allStreamers = liveStreamData
            .filter(s => s.id !== 'user_profile')
            .sort((a, b) => {
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                return parseFollowers(b.followers) - parseFollowers(a.followers);
            });

        if (allStreamers.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>还没有任何主播哦，快去创建一个吧~</p></div>';
            return;
        }

        let gridHtml = '<div class="streamer-card-grid">';
        allStreamers.forEach(streamer => {
            const statusClass = streamer.isLive ? 'live' : 'offline';
            const statusText = streamer.isLive ? 'LIVE' : 'OFF';
            gridHtml += `
                <div class="streamer-card" data-streamer-id="${streamer.id}">
                    <div class="streamer-card-icon-bg"><i class="fa-solid fa-satellite-dish"></i></div>
                    <span class="live-status-btn ${statusClass}" data-streamer-id="${streamer.id}">${statusText}</span>
                    <div class="streamer-card-info">
                        <div class="title">${streamer.title}</div>
                        <div class="name">${streamer.name}</div>
                    </div>
                    <!-- 解释1：这里换成了新的三点按钮 -->
                    <i class="fa-solid fa-ellipsis-vertical streamer-options-btn-corner" data-streamer-id="${streamer.id}"></i>

                </div>
            `;
        });
        gridHtml += '</div>';
        content.innerHTML = gridHtml;

        content.querySelectorAll('.streamer-card').forEach(card => {
            const streamerId = card.dataset.streamerId;
            const streamer = liveStreamData.find(s => s.id === streamerId);
            if (streamer && streamer.isLive) {
                card.style.cursor = 'pointer';
                card.onclick = () => { renderLiveRoom(streamerId); showPage('page-live-room'); };
            } else {
                card.style.cursor = 'default';
                card.onclick = () => { showToast('该主播未开播哦~'); };
            }
        });

        // 解释2：这是最核心的修改！实现了LIVE/OFF双向切换
        content.querySelectorAll('.live-status-btn').forEach(btn => {
            btn.onclick = (e) => { 
                e.stopPropagation();
                
                const streamerId = btn.dataset.streamerId;
                const streamer = liveStreamData.find(s => s.id === streamerId);
                if (!streamer) return;

                // 核心：切换直播状态
                streamer.isLive = !streamer.isLive;
                saveLiveStreamData(); 
                
                // 【原地更新UI】
                const card = btn.closest('.streamer-card');
                if (streamer.isLive) {
                    // 如果是开播
                    btn.textContent = 'LIVE';
                    btn.classList.remove('offline');
                    btn.classList.add('live');
                    if (card) {
                        card.style.cursor = 'pointer';
                        card.onclick = () => { renderLiveRoom(streamerId); showPage('page-live-room'); };
                    }
                } else {
                    // 如果是下播
                    btn.textContent = 'OFF';
                    btn.classList.remove('live');
                    btn.classList.add('offline');
                    if (card) {
                        card.style.cursor = 'default';
                        card.onclick = () => { showToast('该主播未开播哦~'); };
                    }
                }
            };
        });

        // 解释3：为新的三点按钮绑定弹出菜单的功能
        content.querySelectorAll('.streamer-options-btn-corner').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                showStreamerContextMenu(btn.dataset.streamerId, e);
            };
        });
    }






        // 渲染关注页的函数 (逻辑强化版)
    function renderFollowingStreamTab() {
        const content = getEl('live-following-content');
        
        // 1. 检查关注列表是否为空
        if (!userProfile.followingStreamerIds || userProfile.followingStreamerIds.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>还没有关注的主播哦~</p></div>';
            return;
        }
        
        // 2. 核心逻辑：只根据ID筛选出所有已关注的主播，完全不考虑 isLive 状态
        const followedStreamers = liveStreamData.filter(streamer => 
            userProfile.followingStreamerIds.includes(streamer.id)
        );

        // 3. 如果筛选后发现主播列表里找不到这些ID（可能数据不同步），也显示提示
        if (followedStreamers.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>你关注的主播信息丢失了，请尝试重新添加。</p></div>';
            return;
        }

        // 4. 生成HTML，isLive 状态只用来决定是否显示"LIVE"角标
        let gridHtml = '<div class="streamer-card-grid">';
        followedStreamers.forEach(streamer => {
            gridHtml += `
                <div class="streamer-card" data-streamer-id="${streamer.id}">
                    <div class="streamer-card-icon-bg"><i class="fa-solid fa-satellite-dish"></i></div>
                    ${streamer.isLive ? '<span class="streamer-card-live-badge">LIVE</span>' : ''}
                    <div class="streamer-card-info">
                        <div class="title">${streamer.title}</div>
                        <div class="name">${streamer.name}</div>
                    </div>
                </div>
            `;
        });
        gridHtml += '</div>';
        content.innerHTML = gridHtml;

        // 5. 绑定点击事件
        content.querySelectorAll('.streamer-card').forEach(card => {
            card.onclick = () => {
                renderLiveRoom(card.dataset.streamerId);
                showPage('page-live-room');
            };
        });
    }


        function renderMyStreamTab() {
        const content = getEl('live-my-content');
        
        const myStreamerProfile = liveStreamData.find(s => s.id === 'user_profile');

        if (!myStreamerProfile) {
            content.innerHTML = `<div class="empty-placeholder" style="display:block; padding-top: 60px;">
                <p>你还没有自己的直播间</p>
                <button id="create-my-stream-btn" class="btn-primary modal-btn" style="margin-top: 20px; max-width: 150px;">开启我的直播</button>
            </div>`;
            getEl('create-my-stream-btn').onclick = () => {
                const userStreamer = { 
                    id: 'user_profile', name: userProfile.name, avatar: userProfile.avatar, 
                    title: `${userProfile.name}的直播间`, isLive: false, followers: '0', viewers: 0,
                    gender: userProfile.gender, category: '聊天', liveRevenue: 0,
                    // ▼▼▼ 核心新增：为自己的直播档案添加历史记录字段 ▼▼▼
                    liveHistory: [] 
                };
                liveStreamData.push(userStreamer);
                saveLiveStreamData();
                renderMyStreamTab();
            };
            return;
        }

        // 确保历史记录字段存在
        if (!myStreamerProfile.liveHistory) {
            myStreamerProfile.liveHistory = [];
        }

        // 构造数据面板的HTML
          const dashboardHtml = `
            <div class="my-streamer-dashboard">
                <div class="dashboard-item" id="my-stream-history-btn">
                    <div class="value"><i class="fa-solid fa-clock-rotate-left"></i></div>
                    <div class="label">历史直播</div>
                </div>
                <!-- ▼▼▼ 核心修改：为粉丝数量面板添加ID ▼▼▼ -->
                <div class="dashboard-item" id="my-stream-followers-btn">
                    <div class="value">${myStreamerProfile.followers}</div>
                    <div class="label">粉丝数量</div>
                </div>
                <!-- ▲▲▲ 修改完成 ▲▲▲ -->
                <div class="dashboard-item" onclick="showToast('橱窗功能开发中')">
                    <div class="value"><i class="fa-solid fa-store"></i></div>
                    <div class="label">带货橱窗</div>
                </div>
                <div class="dashboard-item" id="my-stream-earnings-btn">
                    <div class="value">¥${(myStreamerProfile.liveRevenue || 0).toFixed(2)}</div>
                    <div class="label">直播收益</div>
                </div>
            </div>
        `;



        const statusClass = myStreamerProfile.isLive ? 'live' : 'offline';
        const statusText = myStreamerProfile.isLive ? 'LIVE' : 'OFF';

        const cardHtml = `
            <div class="streamer-card-grid">
                <div class="streamer-card">
                    <div class="streamer-card-icon-bg"><i class="fa-solid fa-satellite-dish"></i></div>
                    <span class="live-status-btn ${statusClass}" data-streamer-id="${myStreamerProfile.id}">${statusText}</span>
                    <div class="streamer-card-info">
                        <div class="title">${myStreamerProfile.title}</div>
                        <div class="name">${myStreamerProfile.name}</div>
                    </div>
                    <i class="fa-solid fa-pen-to-square streamer-options-btn-corner" data-streamer-id="${myStreamerProfile.id}"></i>
                </div>
            </div>
        `;

        content.innerHTML = dashboardHtml + cardHtml;
        
        // ▼▼▼ 核心升级：为“历史直播”按钮绑定功能（使用专用显示弹窗）▼▼▼
        getEl('my-stream-history-btn').onclick = () => {
            let historyHtml = '';
            if (!myStreamerProfile.liveHistory || myStreamerProfile.liveHistory.length === 0) {
                historyHtml = '<p style="padding: 20px 0; text-align: center;">暂无直播记录</p>';
            } else {
                // 从新到旧排序显示
                [...myStreamerProfile.liveHistory].reverse().forEach(record => {
                    const duration = Math.round((record.endTime - record.startTime) / 60000); // 分钟
                    const startTimeStr = new Date(record.startTime).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit' });
                    
                    historyHtml += `<div class="transaction-item" style="display: block; padding: 12px 15px;">
                        <div class="transaction-details" style="margin-bottom: 8px;">
                            <b style="font-size: 1rem;">${record.title}</b>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-color-medium);">
                            <span>${startTimeStr}</span> | <span>时长: ${duration}分钟</span>
                        </div>
                    </div>`;
                });
            }
            
            // 复用“心声”弹窗来显示内容
            const modal = getEl('thought-modal');
            const title = modal.querySelector('.modal-header');
            const contentArea = getEl('thought-modal-content-area');
            title.textContent = '历史直播记录';
            contentArea.innerHTML = `<div class="transaction-list" style="max-height: 60vh; overflow-y: auto; margin:0; border-radius: 0; box-shadow: none; background: transparent;">${historyHtml}</div>`;
            modal.classList.add('visible');
        };


        // ▼▼▼ 核心新增：为“我的”页面的粉丝数量绑定点击事件 ▼▼▼
        getEl('my-stream-followers-btn').onclick = () => {
            // 直接复用直播间的弹窗渲染逻辑，数据源完全一致！
            const fullFollowerList = generateAndGetFollowerList('user_profile');
            const playerName = getPlayerDisplayName();
            let followersHtml = '';
            if (fullFollowerList.length > 0) {
                fullFollowerList.forEach(name => {
                    const isPlayer = name === playerName;
                    followersHtml += `
                        <div class="transaction-item" style="background-color: ${isPlayer ? 'var(--player-bubble-bg-light)' : 'transparent'}; border-radius: 8px;">
                            <div class="transaction-details">
                                <div class="reason" style="font-weight: ${isPlayer ? '600' : 'normal'};">${name} ${isPlayer ? '(你)' : ''}</div>
                            </div>
                        </div>
                    `;
                });
            } else {
                followersHtml = '<p style="text-align: center; padding: 20px 0;">还没有人关注哦~</p>';
            }
            const modal = getEl('leaderboard-modal');
            modal.querySelector('.modal-header').textContent = '粉丝列表';
            modal.querySelector('#leaderboard-content-area').innerHTML = `<div class="transaction-list" style="margin:0; border-radius: 0; box-shadow: none; background: transparent;">${followersHtml}</div>`;
            modal.classList.add('visible');
        };
        // ▲▲▲ 新增完成 ▲▲▲

        getEl('my-stream-earnings-btn').onclick = () => {
            renderLiveEarningsPage('user_profile');
            showPage('page-live-earnings');
        };



const cardElement = content.querySelector('.streamer-card');
        cardElement.onclick = (e) => {
            if (myStreamerProfile.isLive) {
                if (e.target.closest('.live-status-btn') || e.target.closest('.streamer-options-btn-corner')) {
                    return;
                }
                renderLiveRoom(myStreamerProfile.id);
                showPage('page-live-room');
            } else {
                showToast('您还未开播，请点击"OFF"按钮开启直播');
            }
        };
        
        content.querySelector('.live-status-btn').onclick = (e) => { 
            e.stopPropagation();
            toggleLiveStatus(myStreamerProfile.id, 'my');
        };


        content.querySelector('.streamer-options-btn-corner').onclick = (e) => {
            e.stopPropagation();
            showStreamerContextMenu(myStreamerProfile.id, e);
        };
    }

    // ▼▼▼ 核心新增：渲染直播收益页面和处理提现的完整函数 ▼▼▼
    function renderLiveEarningsPage(streamerId) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return;

        const content = getEl('live-earnings-content');
        const totalRevenue = streamer.liveRevenue || 0;
        
        // 1. 生成收益明细列表的HTML
        let historyHtml = '';
        if (streamer.earningsHistory && streamer.earningsHistory.length > 0) {
            // 从新到旧显示
            [...streamer.earningsHistory].reverse().forEach(item => {
                const date = new Date(item.date).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit' });
                historyHtml += `
                    <div class="transaction-item">
                        <div class="transaction-details">
                            <div class="reason">${item.reason}</div>
                            <div class="date">${date}</div>
                        </div>
                        <div class="transaction-amount income">+${item.amount.toFixed(2)}</div>
                    </div>
                `;
            });
        } else {
            historyHtml = '<div class="empty-placeholder" style="display:block; padding: 40px 0;">暂无收益明细</div>';
        }

        // 2. 拼接完整的页面HTML
        content.innerHTML = `
            <div class="wallet-balance-card">
                <div class="balance-label">当前可提取收益 (元)</div>
                <div class="balance-amount">
                    <span>${totalRevenue.toFixed(2)}</span>
                </div>
            </div>
            
            <div style="padding: 0 15px; margin-top: 20px;">
                 <button id="withdraw-earnings-btn" class="btn-primary modal-btn" style="width: 100%;">提取到钱包</button>
            </div>

            <div class="transaction-list-header">收益明细</div>
            <div class="transaction-list">${historyHtml}</div>
        `;

        // 3. 为提取按钮绑定功能
        const withdrawBtn = getEl('withdraw-earnings-btn');
        if (totalRevenue <= 0) {
            withdrawBtn.disabled = true; // 如果没钱，按钮不可用
            withdrawBtn.textContent = '暂无可提取收益';
        } else {
            withdrawBtn.onclick = () => {
                // 确认弹窗
                showConfirmModal('确认提取', `确定要将 ¥${totalRevenue.toFixed(2)} 的直播收益提取到钱包吗？`, () => {
                    // a. 增加钱包余额
                    userProfile.walletBalance += totalRevenue;
                    // b. 在钱包历史中记录一笔收入
                    userProfile.walletHistory.push({
                        type: 'income',
                        amount: totalRevenue,
                        reason: '直播收益提取',
                        date: new Date().toISOString()
                    });
                    
                    // c. 清空主播的收益数据
                    streamer.liveRevenue = 0;
                    streamer.earningsHistory = [];
                    
                    // d. 保存所有数据
                    saveUserProfile();
                    saveLiveStreamData();
                    
                    // e. 给出反馈并返回
                    showToast('提取成功！');
                    getEl('confirm-modal').classList.remove('visible');
                    renderMyStreamTab(); // 刷新“我的”直播页面，显示收益已清零
                    renderSettingsPage(); // 刷新设置页，显示钱包余额已更新
                    showPage('page-live-stream'); // 返回到直播中心
                });
            };
        }
    }

    getEl('back-from-live-earnings-btn').onclick = () => showPage('page-live-stream');
    // ▲▲▲ 新增完成 ▲▲▲


    
    function toggleLiveStatus(streamerId, activeTab) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return;

        // 核心修改 1：将开播/下播的复杂逻辑，只限定于用户自己的主播
        if (streamer.id === 'user_profile') {
            if (!streamer.isLive) {
                // 开播逻辑
                const modal = getEl('user-stream-setup-modal');
                const input = getEl('user-stream-title-input');
                input.value = streamer.title;
                modal.classList.add('visible');
                getEl('start-user-stream-btn').textContent = '开始直播';
                getEl('start-user-stream-btn').onclick = () => {
                    const newTitle = input.value.trim();
                    if (newTitle) {
                        streamer.title = newTitle;
                        streamer.isLive = true;
                        if (!streamer.liveHistory) streamer.liveHistory = [];
                        streamer.currentLiveSession = { title: newTitle, startTime: Date.now() };
                        saveLiveStreamData();
                        renderMyStreamTab(); // 开播后只刷新“我的”页面
                        modal.classList.remove('visible');
                    } else {
                        showToast('标题不能为空');
                    }
                };
                getEl('cancel-user-stream-btn').onclick = () => modal.classList.remove('visible');
            } else {
                // 下播逻辑
                streamer.isLive = false;
                if (streamer.currentLiveSession) {
                    const session = streamer.currentLiveSession;
                    session.endTime = Date.now();
                    if (session.endTime - session.startTime > 60000) {
                        streamer.liveHistory.push(session);
                    }
                    delete streamer.currentLiveSession;
                }
                saveLiveStreamData();
                renderMyStreamTab(); // 下播后只刷新“我的”页面
            }
        } else {
            // 对于所有其他主播，只进行简单的状态切换
            streamer.isLive = !streamer.isLive;
            saveLiveStreamData();
            
            // 核心修改 2：根据传入的 activeTab 参数，决定刷新哪个页面
            switch (activeTab) {
                case 'recommended':
                    renderLiveRecommendedTab();
                    break;
                case 'following':
                    renderFollowingStreamTab();
                    break;
                case 'my':
                    renderMyStreamTab();
                    break;
            }
        }
    }


    function showFriendPickerForStreamerCreation() {
        const existingStreamerIds = liveStreamData.map(s => s.id);
        const eligibleFriends = contacts.friends.filter(f => !existingStreamerIds.includes(f.id));

        if (eligibleFriends.length === 0) {
            showToast('所有好友都已经是主播啦！');
            return;
        }

        const options = eligibleFriends.map(f => ({ value: f.id, text: getDisplayName(f) }));

        showSelectionModal('选择好友创建直播间', options, null, (friendId) => {
            // ▼▼▼ 核心修复：将所有业务逻辑包裹在 setTimeout 中 ▼▼▼

            // 1. 手动先关闭弹窗 (这行代码在 setTimeout 外面，会最先执行)
            // getEl('selection-modal').classList.remove('visible'); // 注意：这一步由弹窗函数自己完成了，我们只需要延迟后续操作即可

            // 2. 将耗时操作放入延迟执行，给关闭动画留出时间
            setTimeout(() => {
                if (!friendId) return;
                const friend = findContactById(friendId);
                if (friend) {
                    const newStreamer = {
                        id: friend.id,
                        name: getDisplayName(friend),
                        avatar: friend.avatar,
                        title: `${getDisplayName(friend)}的直播间`,
                        isLive: true,
                        followers: `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 9)}k`,
                        viewers: Math.floor(Math.random() * 1000) + 50
                    };
                    liveStreamData.push(newStreamer);

                    if (!userProfile.followingStreamerIds) userProfile.followingStreamerIds = [];
                    if (!userProfile.followingStreamerIds.includes(friend.id)) {
                        userProfile.followingStreamerIds.push(friend.id);
                    }
                    saveUserProfile();
                    saveLiveStreamData();

                    showToast(`已为 ${getDisplayName(friend)} 开启直播并自动关注！`);
                    
                    renderLiveStreamPage('following');
                }
            }, 50); // 延迟50毫秒，足够让UI响应

        }, { needsConfirmation: true });
    }


    // 新增：粉丝数转换函数，用于排序
    function parseFollowers(followerStr) {
        if (typeof followerStr !== 'string') return 0;
        const lowerCaseStr = followerStr.toLowerCase().trim();
        let num = parseFloat(lowerCaseStr);
        if (isNaN(num)) return 0;

        if (lowerCaseStr.includes('w')) {
            num *= 10000;
        } else if (lowerCaseStr.includes('k')) {
            num *= 1000;
        }
        return num;
    }

    function renderLiveRecommendedTab() {
        const content = getEl('live-recommended-content');
        
        const allStreamers = liveStreamData
            .filter(s => s.id !== 'user_profile')
            .sort((a, b) => {
                if (a.isLive && !b.isLive) return -1;
                if (!a.isLive && b.isLive) return 1;
                return parseFollowers(b.followers) - parseFollowers(a.followers);
            });

        if (allStreamers.length === 0) {
            content.innerHTML = '<div class="empty-placeholder" style="display:block;"><p>还没有任何主播哦，快去创建一个吧~</p></div>';
            return;
        }

        let gridHtml = '<div class="streamer-card-grid">';
        allStreamers.forEach(streamer => {
            const statusClass = streamer.isLive ? 'live' : 'offline';
            const statusText = streamer.isLive ? 'LIVE' : 'OFF';
            gridHtml += `
                <div class="streamer-card" data-streamer-id="${streamer.id}">
                    <div class="streamer-card-icon-bg"><i class="fa-solid fa-satellite-dish"></i></div>
                    <span class="live-status-btn ${statusClass}" data-streamer-id="${streamer.id}">${statusText}</span>
                    <div class="streamer-card-info">
                        <div class="title">${streamer.title}</div>
                        <div class="name">${streamer.name}</div>
                    </div>
                    <!-- 解释：这里是正确的三点按钮代码 -->
                    <i class="fa-solid fa-ellipsis-vertical streamer-options-btn-corner" data-streamer-id="${streamer.id}"></i>

                </div>
            `;
        });
        gridHtml += '</div>';
        content.innerHTML = gridHtml;

        content.querySelectorAll('.streamer-card').forEach(card => {
            const streamerId = card.dataset.streamerId;
            const streamer = liveStreamData.find(s => s.id === streamerId);
            // 修复点1：点击卡片进入直播间的逻辑只对开播的主播生效
            if (streamer && streamer.isLive) {
                card.style.cursor = 'pointer';
                card.onclick = (e) => {
                    // 如果点击的是按钮，就不进入直播间
                    if (e.target.closest('.live-status-btn') || e.target.closest('.streamer-options-btn-corner')) {
                        return;
                    }
                    renderLiveRoom(streamerId); 
                    showPage('page-live-room');
                };
            } else {
                card.style.cursor = 'default';
                card.onclick = (e) => {
                    if (e.target.closest('.live-status-btn') || e.target.closest('.streamer-options-btn-corner')) {
                        return;
                    }
                    showToast('该主播未开播哦~');
                };
            }
        });

        // 修复点2：LIVE/OFF 状态切换按钮的逻辑
               // 核心修改：为所有状态按钮统一调用新的“万能遥控器”
        content.querySelectorAll('.live-status-btn').forEach(btn => {
            btn.onclick = (e) => { 
                e.stopPropagation();
                // 调用新函数，并告诉它当前在 'recommended' 页面
                toggleLiveStatus(btn.dataset.streamerId, 'recommended');
            };
        });


        // 修复点3：为三点按钮绑定弹出菜单的功能
        content.querySelectorAll('.streamer-options-btn-corner').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                showStreamerContextMenu(btn.dataset.streamerId, e);
            };
        });
    }





    function renderLiveRoom(streamerId) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return;

        leaveLiveRoom();
        activeLiveStreamerId = streamerId;

        const avatarEl = getEl('live-room-streamer-avatar');
        const nameEl = getEl('live-room-streamer-name');
        const followBtn = getEl('live-room-follow-btn');
        const chatFeed = getEl('live-room-chat-feed');
        const followersEl = getEl('live-room-streamer-followers'); // 获取粉丝元素

        avatarEl.src = streamer.avatar;
        nameEl.textContent = streamer.name;
        followersEl.textContent = `${streamer.followers} 粉丝`;
        chatFeed.innerHTML = '';

        // ▼▼▼ 核心升级：让粉丝数量区域可点击，并调用统一的粉丝生成器 ▼▼▼
        followersEl.style.cursor = 'pointer';
        followersEl.onclick = () => {
            // 1. 直接调用新的中央函数来获取完整的粉丝列表
            const fullFollowerList = generateAndGetFollowerList(streamerId);
            const playerName = getPlayerDisplayName();

            // 2. 准备弹窗内容
            let followersHtml = '';
            if (fullFollowerList.length > 0) {
                fullFollowerList.forEach(name => {
                    const isPlayer = name === playerName;
                    followersHtml += `
                        <div class="transaction-item" style="background-color: ${isPlayer ? 'var(--player-bubble-bg-light)' : 'transparent'}; border-radius: 8px;">
                            <div class="transaction-details">
                                <div class="reason" style="font-weight: ${isPlayer ? '600' : 'normal'};">${name} ${isPlayer ? '(你)' : ''}</div>
                            </div>
                        </div>
                    `;
                });
            } else {
                followersHtml = '<p style="text-align: center; padding: 20px 0;">还没有人关注哦~</p>';
            }

            // 3. 复用排行榜弹窗来显示
            const modal = getEl('leaderboard-modal');
            modal.querySelector('.modal-header').textContent = '粉丝列表';
            modal.querySelector('#leaderboard-content-area').innerHTML = `<div class="transaction-list" style="margin:0; border-radius: 0; box-shadow: none; background: transparent;">${followersHtml}</div>`;
            modal.classList.add('visible');
        };
        // ▲▲▲ 升级完成 ▲▲▲

        const isFollowing = userProfile.followingStreamerIds?.includes(streamerId);
        followBtn.textContent = isFollowing ? '已关注' : '关注';


        followBtn.style.background = isFollowing ? 'var(--player-bubble-bg-light)' : 'var(--accent-gradient)';
        followBtn.style.color = isFollowing ? 'var(--accent-color-deep)' : 'white';
        followBtn.style.border = isFollowing ? '1px solid var(--accent-color)' : 'none';
        
        avatarEl.onclick = () => getEl('streamer-avatar-input').click();
        
        nameEl.style.cursor = 'pointer';
        nameEl.onclick = () => {
            showEditInfoModal({
                title: '修改主播昵称',
                initialValue: streamer.name,
                onSave: (newName) => { if (newName) { streamer.name = newName; nameEl.textContent = newName; saveLiveStreamData(); renderMyStreamTab(); showToast('昵称已更新'); } }
            });
        };
        
        followBtn.onclick = () => handleFollowToggle(streamerId);
                // ▼▼▼ 核心修复：只绑定打开事件，关闭事件已移至全局 ▼▼▼
        getEl('show-leaderboard-btn').onclick = () => renderLeaderboardModal(streamerId);
        // ▲▲▲ 修复完成 ▲▲▲


        const avatarInput = getEl('streamer-avatar-input');
        const newAvatarInput = avatarInput.cloneNode(true);
        avatarInput.parentNode.replaceChild(newAvatarInput, avatarInput);
        newAvatarInput.onchange = (e) => handleStreamerAvatarChange(e, streamerId);

        const commentInput = getEl('live-room-comment-input');
        
        const sendLiveRoomComment = () => {
            const text = commentInput.value.trim();
            if (!text) return;
            const commentEl = document.createElement('div');
            commentEl.className = 'chat-comment';
            commentEl.innerHTML = `<span class="username" style="color: #5c5456;">${getPlayerDisplayName()} (你):</span><span>${text}</span>`;
            chatFeed.appendChild(commentEl);
            chatFeed.scrollTop = chatFeed.scrollHeight;
            commentInput.value = '';
        };

        const handleSendGift = () => {
            const giftModal = getEl('gift-modal');
            const giftPanel = getEl('gift-panel-content');
            const balanceDisplay = getEl('gift-modal-balance');
            const confirmBtn = getEl('send-gift-confirm-btn');
            let selectedGift = null;

            balanceDisplay.textContent = `¥${userProfile.walletBalance.toFixed(2)}`;
            giftPanel.innerHTML = ''; 

            GIFT_DATABASE.forEach(gift => {
                const item = document.createElement('div');
                item.className = 'gift-item';
                item.innerHTML = `
                    <div class="gift-icon"><i class="${gift.icon}"></i></div>
                    <div class="gift-name">${gift.name}</div>
                    <div class="gift-price">¥${gift.price.toFixed(2)}</div>
                `;
                item.onclick = () => {
                    giftPanel.querySelectorAll('.gift-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedGift = gift;
                    confirmBtn.disabled = userProfile.walletBalance < selectedGift.price;
                };
                giftPanel.appendChild(item);
            });

            const closeGiftModal = () => {
                giftModal.classList.remove('visible');
                confirmBtn.onclick = null;
            };
            
            confirmBtn.onclick = () => {
                if (!selectedGift) {
                    showToast('请先选择一个礼物');
                    return;
                }
                if (userProfile.walletBalance < selectedGift.price) {
                    showToast('钱包余额不足');
                    return;
                }

                userProfile.walletBalance -= selectedGift.price;
                userProfile.walletHistory.push({
                    type: 'expense',
                    amount: selectedGift.price,
                    reason: `直播打赏 (${selectedGift.name})`,
                    date: new Date().toISOString()
                });
                saveUserProfile();

                updateLeaderboard(streamer.id, getPlayerDisplayName(), selectedGift.price);

                const commentEl = document.createElement('div');
                commentEl.className = 'chat-comment system-event';
                commentEl.innerHTML = `<span class="username">${getPlayerDisplayName()} (你)</span> 送出了 ${selectedGift.name} <i class="${selectedGift.icon} gift-icon"></i>`;
                chatFeed.appendChild(commentEl);
                
                if (selectedGift.price >= 66.6) { 
                    const luxuryBanner = document.createElement('div');
                    luxuryBanner.className = 'chat-comment system-event-luxury';
                    luxuryBanner.innerHTML = `✨ 壕气冲天！<span style="color: #fff;">${getPlayerDisplayName()}</span> 送出 ${selectedGift.name}，点亮了整个直播间！✨`;
                    chatFeed.appendChild(luxuryBanner);
                    
                    const thankYouPrompt = `[紧急任务] 观众“${getPlayerDisplayName()}”送出了一个贵重的礼物：“${selectedGift.name}”。请你作为主播，用一句简洁、日常的口语感谢TA。例如：“哇，谢谢${getPlayerDisplayName()}送的${selectedGift.name}！”或者“感谢老板的${selectedGift.name}，太破费了！”`;
                    
                    activeLiveRoomEvent = {
                        type: 'luxury_gift',
                        giftName: selectedGift.name,
                        senderName: getPlayerDisplayName()
                    };
                    setTimeout(() => { activeLiveRoomEvent = null; }, 8000);

                    setTimeout(() => {
                        handleLiveInteraction(thankYouPrompt);
                    }, 1000); 
                }

                chatFeed.scrollTop = chatFeed.scrollHeight;

                // ▼▼▼ 核心修复：确保为所有类型的主播都增加收益（除了玩家自己）▼▼▼
                if (streamer.id !== 'user_profile') {
                    if (!streamer.liveRevenue) streamer.liveRevenue = 0;
                    streamer.liveRevenue += selectedGift.price;
                    // 注意：这里我们不再需要为独立主播记账，因为模拟观众送礼时已经记了
                    // 玩家送礼的收益，会在玩家自己的直播间收益明细里体现
                }
                // ▲▲▲ 修复完成 ▲▲▲
                saveLiveStreamData(); // 统一在这里保存一次数据

                closeGiftModal();
                showToast(`成功送出 ${selectedGift.name}！`);
            };
            
            giftModal.onclick = (e) => {
                if (e.target === giftModal) closeGiftModal();
            };

            giftModal.classList.add('visible');
        };

        getEl('live-room-send-comment-btn').onclick = sendLiveRoomComment;
        commentInput.onkeydown = (e) => { if (e.key === 'Enter') sendLiveRoomComment(); };
        getEl('live-room-send-gift-btn').onclick = handleSendGift;
        
        // ▼▼▼ 核心修复：将 usedViewerNames 提到 setInterval 外面，防止名字重复 ▼▼▼
        let usedViewerNames = new Set();
        activeLiveRoomIntervals.chat = setInterval(() => {
            const commentEl = document.createElement('div');
            commentEl.className = 'chat-comment';

            if (activeLiveRoomEvent && activeLiveRoomEvent.type === 'luxury_gift') {
                let randomUser = VIEWER_NAMES[Math.floor(Math.random() * VIEWER_NAMES.length)];
                let reactionTemplate = LUXURY_GIFT_REACTIONS[Math.floor(Math.random() * LUXURY_GIFT_REACTIONS.length)];
                let reactionText = reactionTemplate
                    .replace('[SENDER]', activeLiveRoomEvent.senderName)
                    .replace('[GIFT]', activeLiveRoomEvent.giftName);
                
                commentEl.innerHTML = `<span class="username">${randomUser}:</span><span>${reactionText}</span>`;

            } else {
                const eventRoll = Math.random();
                if (streamer.roomManager && eventRoll > 0.88) { 
                    const managerComment = MANAGER_COMMENT_TEMPLATES[Math.floor(Math.random() * MANAGER_COMMENT_TEMPLATES.length)];
                    commentEl.innerHTML = `<span class="username"><span class="manager-badge">房管</span>${streamer.roomManager}:</span><span>${managerComment}</span>`;
                
                } else { 
                    if (usedViewerNames.size >= VIEWER_NAMES.length) {
                        usedViewerNames.clear(); 
                    }
                    let randomUser;
                    do {
                        randomUser = VIEWER_NAMES[Math.floor(Math.random() * VIEWER_NAMES.length)];
                    } while (usedViewerNames.has(randomUser));
                    usedViewerNames.add(randomUser);

                    const subEventRoll = Math.random();
                    let eventType = 'comment'; 
                    
                    if (subEventRoll > 0.94) { 
                        eventType = 'follow';
                    } else if (subEventRoll > 0.82) { 
                        eventType = 'gift';
                    }

                    switch (eventType) {
                        case 'follow':
                            commentEl.classList.add('system-event'); 
                            commentEl.innerHTML = `<span class="username">${randomUser}</span> 关注了主播`;
                            if (streamer.id === 'user_profile') {
                                let currentFollowers = parseFollowers(streamer.followers);
                                streamer.followers = (currentFollowers + 1).toString(); 
                                saveLiveStreamData();
                            }
                            break;
                        
                        case 'gift':
                            const randomGift = GIFT_DATABASE[Math.floor(Math.random() * GIFT_DATABASE.length)];
                            
                            // ▼▼▼ 核心修复：确保为所有类型的主播都记账 ▼▼▼
                            updateLeaderboard(streamer.id, randomUser, randomGift.price);

                            commentEl.classList.add('system-event');
                            commentEl.innerHTML = `<span class="username">${randomUser}</span> 送出了 ${randomGift.name} <i class="${randomGift.icon} gift-icon"></i>`;
                            
                            // 玩家自己的直播间才记录收益
                            if (streamer.id === 'user_profile') {
                                if (!streamer.liveRevenue) streamer.liveRevenue = 0;
                                if (!streamer.earningsHistory) streamer.earningsHistory = [];
                                streamer.liveRevenue += randomGift.price;
                                streamer.earningsHistory.push({
                                    reason: `收到礼物: ${randomGift.name}`,
                                    amount: randomGift.price,
                                    date: new Date().toISOString()
                                });
                                saveLiveStreamData();
                            }
                            break;

                        case 'comment':
                        default:
                            const streamerCategory = streamer.category || '通用';
                            const streamerGender = streamer.gender || '通用';
                            const categoryTemplates = COMMENT_TEMPLATES[streamerCategory] || COMMENT_TEMPLATES['通用'];
                            const finalTemplates = categoryTemplates[streamerGender] || categoryTemplates['通用'];
                            const randomComment = finalTemplates[Math.floor(Math.random() * finalTemplates.length)];
                            commentEl.innerHTML = `<span class="username">${randomUser}:</span><span>${randomComment}</span>`;
                            break;
                    }
                }
            }

            chatFeed.appendChild(commentEl);
            chatFeed.scrollTop = chatFeed.scrollHeight;

        }, 2000 + Math.random() * 2000);

        activeLiveRoomIntervals.likes = setInterval(() => {
            const icons = ['fa-solid fa-heart', 'fa-solid fa-star', 'fa-solid fa-gem'];
            const colors = ['#FFC3A0', '#FFAFBD', '#FFD700', '#FFFFFF'];
            const likeEl = document.createElement('i');
            const randomIcon = icons[Math.floor(Math.random() * icons.length)];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            likeEl.className = `${randomIcon} floating-like`;
            likeEl.style.color = randomColor;
            likeEl.style.left = `${Math.random() * 80}%`;
            likeEl.style.fontSize = `${1 + Math.random() * 0.8}rem`;
            likeEl.style.animationDuration = `${2 + Math.random() * 2}s`;
            getEl('floating-likes-container').appendChild(likeEl);
            setTimeout(() => likeEl.remove(), 4000); 
        }, 200);
    }







    function leaveLiveRoom() {
        clearInterval(activeLiveRoomIntervals.chat);
        clearInterval(activeLiveRoomIntervals.likes);
    }
     function handleFollowToggle(streamerId) {
        if (!userProfile.followingStreamerIds) {
            userProfile.followingStreamerIds = [];
        }
        
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return;

        // ▼▼▼ 核心新增：初始化主播的粉丝列表 ▼▼▼
        if (!streamer.followerList) {
            streamer.followerList = [];
        }
        // ▲▲▲ 新增完成 ▲▲▲

        const followBtn = getEl('live-room-follow-btn');
        const index = userProfile.followingStreamerIds.indexOf(streamerId);
        const playerName = getPlayerDisplayName();
        
        if (index > -1) {
            // 已关注 -> 取关
            userProfile.followingStreamerIds.splice(index, 1);
            // 从主播的粉丝名册中移除玩家
            streamer.followerList = streamer.followerList.filter(name => name !== playerName);
            
            followBtn.textContent = '关注';
            followBtn.style.background = 'var(--accent-gradient)';
            followBtn.style.color = 'white';
            followBtn.style.border = 'none';
        } else {
            // 未关注 -> 关注
            userProfile.followingStreamerIds.push(streamerId);
            // 将玩家的名字添加到主播的粉丝名册中
            if (!streamer.followerList.includes(playerName)) {
                streamer.followerList.push(playerName);
            }

            followBtn.textContent = '已关注';
            followBtn.style.background = 'var(--player-bubble-bg-light)';
            followBtn.style.color = 'var(--accent-color-deep)';
            followBtn.style.border = '1px solid var(--accent-color)';
        }
        
                saveUserProfile();
        saveLiveStreamData(); // 核心新增：保存主播数据的变动
    }

    // ▼▼▼ 核心新增：统一的粉丝列表生成与管理函数 ▼▼▼
    function generateAndGetFollowerList(streamerId) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return [];

        // 1. 初始化或获取已有的粉丝列表
        if (!streamer.followerList) {
            streamer.followerList = [];
        }

        // 2. 确保玩家（如果已关注）总是在列表的最前面
        const playerName = getPlayerDisplayName();
        const isFollowing = userProfile.followingStreamerIds?.includes(streamerId);
        if (isFollowing && !streamer.followerList.includes(playerName)) {
            streamer.followerList.unshift(playerName);
        } else if (!isFollowing && streamer.followerList.includes(playerName)) {
            // 如果没关注但列表里有，就移除
            streamer.followerList = streamer.followerList.filter(name => name !== playerName);
        }

        // 3. 根据总粉丝数，决定需要生成多少“系统粉丝”
        const totalFollowers = parseFollowers(streamer.followers);
        const realFansCount = streamer.followerList.length;
        const fansToGenerate = totalFollowers - realFansCount;

        // 4. 如果需要，就生成系统粉丝并添加到列表末尾
        if (fansToGenerate > 0) {
            // 从总观众池中，排除掉已经是粉丝的人，避免重复
            const potentialNewFans = VIEWER_NAMES.filter(name => !streamer.followerList.includes(name));
            // 打乱候选人顺序
            potentialNewFans.sort(() => 0.5 - Math.random());
            
            const newFans = potentialNewFans.slice(0, fansToGenerate);
            streamer.followerList.push(...newFans);
            
            // 生成后保存一次，让粉丝列表固定下来
            saveLiveStreamData();
        }

        return streamer.followerList;
    }
    // ▲▲▲ 新增完成 ▲▲▲

    // ▼▼▼ 新增：处理直播间AI互动的核心函数 ▼▼▼
    async function handleLiveInteraction(forcedPrompt = null) {
        if (!activeLiveStreamerId) return;

        const interactBtn = getEl('live-room-interact-btn');
        interactBtn.disabled = true;
        interactBtn.innerHTML = '<div class="spinner" style="width:18px; height:18px; border-width: 2px;"></div>';

        try {
            let settings = {
                baseUrl: getEl('moments-base-url').value.trim(),
                apiKey: getEl('moments-api-key').value.trim(),
                modelName: getEl('moments-model-name').value.trim()
            };
            if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
                settings = {
                    baseUrl: getEl('base-url').value.trim(),
                    apiKey: getEl('api-key').value.trim(),
                    modelName: getEl('model-name').value.trim()
                };
            }
            if (settings.baseUrl && !settings.baseUrl.startsWith('http')) {
                settings.baseUrl = 'https://' + settings.baseUrl;
            }
            if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
                throw new Error('请先配置API信息');
            }

            const streamer = liveStreamData.find(s => s.id === activeLiveStreamerId);
            if (!streamer) throw new Error('找不到当前主播信息');

            // ▼▼▼ 核心升级：构建超详细的AI“角色设定卡” ▼▼▼

            // 1. 尝试获取绑定的好友完整信息
            const linkedFriend = contacts.friends.find(f => f.id === streamer.linkedContactId);
            
            // 2. 构建详细的人设文本
            let personaDetails;
            if (linkedFriend) {
                // 如果绑定了好友，就使用好友的详细资料
                personaDetails = `
- **核心人设/背景故事**: "${linkedFriend.background || '一个性格鲜明、有趣的主播'}"
- **习惯**: "${linkedFriend.habits || '无特别习惯'}"
- **厌恶的事物**: "${linkedFriend.dislikes || '无特别厌恶的事物'}"`;
            } else {
                // 如果是独立主播，就使用主播自己的`persona`
                personaDetails = `- **核心人设/背景故事**: "${streamer.persona || '一个性格鲜明、有趣的主播'}"`;
            }

            // 3. 构建包含全新“表演指导”的剧本大纲
            const systemPromptCore = `你正在深度扮演一名叫做 "${streamer.name}" 的主播。
            
# 你的核心身份
- **主播名字**: ${streamer.name}
- **直播间标题**: "${streamer.title}"
${personaDetails}

# 你的行为准则 (必须严格遵守)
- **人设至上**: 你的一切发言都必须符合你的核心人设。例如，如果你的背景故事是一个内向的画家，你的回复应该简洁、文艺，而不是热情奔放。
- **保持生活化与真实感**: 你的回复必须像一个真实的、正在直播的人。使用自然的口语、语气词（嗯、啊、哦...），避免使用书面化、AI味十足的语言。**绝对不要说出过于夸张、戏剧化或不切实际的话。**
- **积极互动**: 尽量称呼观众的名字，或者用“这位宝宝”、“这位朋友”来拉近距离。让他们感觉你在和他们一对一聊天。
- **杜绝重复**: 不要总是说“谢谢”、“是的”，尝试用不同的方式表达同一个意思。`;

            // 4. 根据情况决定AI本次的具体任务
            let taskPrompt;
            if (forcedPrompt) {
                taskPrompt = `[紧急任务]\n${forcedPrompt}`;
            } else {
                const recentComments = Array.from(document.querySelectorAll('.live-room-chat-feed .chat-comment'))
                    .slice(-5)
                    .map(comment => comment.textContent)
                    .join('\n');
                taskPrompt = `[常规任务]
根据下面最近的几条观众弹幕，作为主播 "${streamer.name}"，自然地回复其中一条或几条弹幕。

[最近的弹幕]
${recentComments || "(暂无弹幕)"}`;
            }

            // 5. 组合成最终的指令
            const userPrompt = `${systemPromptCore}

${taskPrompt}

[最终要求]
直接输出你作为主播要说的话，不要包含任何前缀、引号或标签。`;
            // ▲▲▲ 升级完成 ▲▲▲

            const messagesForApi = [
                { role: 'system', content: 'You are an AI actor role-playing as a live streamer.' },
                { role: 'user', content: userPrompt }
            ];

            const cleanedBaseUrl = settings.baseUrl.endsWith('/') ? settings.baseUrl.slice(0, -1) : settings.baseUrl;
            const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;
            
            const response = await fetch(finalUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.apiKey}` },
                body: JSON.stringify({
                    model: settings.modelName,
                    messages: messagesForApi,
                    temperature: 0.8,
                    max_tokens: 100
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error.message || `API请求失败: ${response.status}`);
            }
            const data = await response.json();
            if (!data || !data.choices || data.choices.length === 0) {
                throw new Error("API返回了无效的数据格式");
            }
            const replyText = data.choices[0].message.content.trim();

            if (replyText) {
                const commentEl = document.createElement('div');
                commentEl.className = 'chat-comment';
                commentEl.innerHTML = `<span class="username" style="color: #E68FA0;">${streamer.name} (主播):</span><span>${replyText}</span>`;
                const chatFeed = getEl('live-room-chat-feed');
                chatFeed.appendChild(commentEl);
                chatFeed.scrollTop = chatFeed.scrollHeight;
            }

        } catch (error) {
            showToast(`互动失败: ${error.message}`);
            console.error("直播互动API调用失败:", error);
               } finally {
            interactBtn.disabled = false;
            interactBtn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i>';
        }
    }

    // ▼▼▼ 新增：网店经营核心功能函数 ▼▼▼
    // ▼▼▼ 核心新增：订单状态自动更新的“状态机”函数 ▼▼▼
    function checkAndUpdateStoreOrders() {
        if (!userProfile.onlineStore || !userProfile.onlineStore.orders) return;

        const now = Date.now();
        let updated = false;

        userProfile.onlineStore.orders.forEach(order => {
            // 检查“已发货”的订单是否应该变为“已完成”
            // (发货后超过1分钟，就模拟物流送达)
            if (order.status === 'shipped' && order.shippedTimestamp && (now - order.shippedTimestamp > 60000)) {
                order.status = 'completed';
                order.completedTimestamp = now;
                
                // 将订单金额从“待提取”转入“已完成可提取”
                userProfile.onlineStore.earnings += order.total;

                updated = true;
                showToast(`订单 [${order.productName}] 已完成！`);
            }
        });

        if (updated) {
            saveUserProfile();
        }
    }
    // ▲▲▲ 新增完成 ▲▲▲

    function renderOnlineStorePage(defaultTab = 'products') {
        // ▼▼▼ 核心新增：每次进入网店页面，都先检查一遍订单状态 ▼▼▼
        checkAndUpdateStoreOrders();
        // ▲▲▲ 新增完成 ▲▲▲

        const tabs = document.querySelectorAll('.store-tab-btn');
        const pageTitle = getEl('online-store-page-title');

        const switchTab = (tabName) => {
            tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
            document.querySelectorAll('#page-online-store .live-tab-content').forEach(c => c.classList.remove('active'));
            getEl(`store-${tabName}-content`).classList.add('active');

            if (tabName === 'products') {
                pageTitle.textContent = '商品管理';
                renderStoreProductsPage();
            } else if (tabName === 'my-store') {
                pageTitle.textContent = '我的小店';
                renderStoreMyPage();
            }
        };

        tabs.forEach(tab => {
            tab.onclick = () => switchTab(tab.dataset.tab);
        });

        switchTab(defaultTab);
    }

    function renderStoreProductsPage() {
        const content = getEl('store-products-content');
        const products = userProfile.onlineStore.products || [];
        
        let productsHtml = '';
        if (products.length > 0) {
            products.forEach(p => {
                const shippingFeeText = p.shippingType === 'free' ? '包邮' : `运费 ¥${p.shippingFee.toFixed(2)}`;
                const shippingMethodText = p.shippingMethod || '快递发货';
                const shippingInfoText = `${shippingMethodText} | ${shippingFeeText}`;
                
                // ▼▼▼ 核心修改：在商品卡片上显示库存 ▼▼▼
                const stockText = (p.stock > 0) ? `库存: ${p.stock}` : '<span style="color: var(--danger-color);">已售罄</span>';

                productsHtml += `
                    <div class="product-card">
                        <div class="product-card-header">
                            <span class="name">${p.name}</span>
                            <span class="price">¥${p.price.toFixed(2)}</span>
                        </div>
                        <div class="product-card-body">
                            <p class="description">${p.description}</p>
                            <div class="description" style="font-size: 0.8rem; margin-top: 5px; display: flex; justify-content: space-between;">
                                <span>${shippingInfoText}</span>
                                <span>${stockText}</span>
                            </div>
                        </div>
                        <div class="product-card-footer">
                            <button class="share-product-btn" data-id="${p.id}">分享</button>
                            <button class="edit-product-btn" data-id="${p.id}">编辑</button>
                            <button class="delete-product-btn btn-primary" data-id="${p.id}" style="background: var(--danger-color);">删除</button>
                        </div>
                    </div>
                `;
            });
        } else {
            productsHtml = '<div class="empty-placeholder" style="display:block;"><p>还没有商品，快去进货上架第一个吧！</p></div>';
        }

        // ▼▼▼ 核心修改：用一个按钮组代替原来的单个按钮 ▼▼▼
        content.innerHTML = `
            <div class="form-actions-bar" style="margin-bottom: 15px;">
                <button id="go-to-warehouse-btn" style="border-color: var(--accent-color); color: var(--accent-color);"><i class="fa-solid fa-warehouse"></i> 我的仓库</button>
                <button id="go-to-market-btn" class="btn-primary"><i class="fa-solid fa-store"></i> 前往进货</button>
            </div>
            ${productsHtml}
        `;

        // ▼▼▼ 核心修改：为新按钮绑定事件 ▼▼▼
        getEl('go-to-warehouse-btn').onclick = () => {
            renderStoreWarehousePage();
            showPage('page-store-warehouse');
        };
        getEl('go-to-market-btn').onclick = () => {
            renderWholesaleMarketPage();
            showPage('page-wholesale-market');
        };
        
        content.querySelectorAll('.edit-product-btn').forEach(btn => btn.onclick = () => renderEditProductPage(btn.dataset.id));
        content.querySelectorAll('.delete-product-btn').forEach(btn => btn.onclick = () => {
            showConfirmModal('确认删除', '确定要下架这个商品吗？库存等信息将一并清除。', () => {
                userProfile.onlineStore.products = userProfile.onlineStore.products.filter(p => p.id !== btn.dataset.id);
                saveUserProfile();
                renderStoreProductsPage();
                getEl('confirm-modal').classList.remove('visible');
            });
        });
        content.querySelectorAll('.share-product-btn').forEach(btn => btn.onclick = () => {
            const product = userProfile.onlineStore.products.find(p => p.id === btn.dataset.id);
            if (!product) return;
            if (product.stock <= 0) {
                showToast('商品已售罄，无法分享哦~');
                return;
            }
            const options = contacts.friends.map(f => ({ value: f.id, text: getDisplayName(f) }));
            if (options.length === 0) { showToast('还没有好友可以分享'); return; }
            showSelectionModal('分享给...', options, null, (friendId) => {
                let conversation = conversations.find(c => c.contactId === friendId);
                if (!conversation) {
                    conversation = { id: `conv_${Date.now()}`, contactId: friendId, type: 'friend', history: [], lastActivity: Date.now() };
                    conversations.push(conversation);
                }
                currentConversationId = conversation.id;
                addMessageToChat('user', product, true, { type: 'product_share' });
                openConversation(conversation.id);
            });
        });
    }


    function renderEditProductPage(productId = null) {
        // ▼▼▼ 核心修改1：为新商品对象添加默认的发货方式和库存 ▼▼▼
        let product = { name: '', description: '', price: '', shippingType: 'free', shippingFee: 0, shippingMethod: '快递发货', stock: 0 };

        if (productId) {
            const foundProduct = userProfile.onlineStore.products.find(p => p.id === productId);
            if (foundProduct) {
                // 确保旧数据也能兼容新字段
                product = { ...product, ...foundProduct };
            }
        }

        const formContent = getEl('edit-product-form-content');
        formContent.innerHTML = `
            <div class="form-group">
                <label>商品名称</label>
                <input type="text" id="product-name" value="${product.name}">
            </div>
            <div class="form-group">
                <label>商品简介</label>
                <textarea id="product-description">${product.description}</textarea>
            </div>
            <div class="form-group">
                <label>价格 (元)</label>
                <input type="number" id="product-price" value="${product.price}">
            </div>
            <div class="form-group selectable" id="shipping-type-selector">
                <label>运费设置</label>
                <div class="form-value">
                    <span id="shipping-type-text">${product.shippingType === 'free' ? '包邮' : '固定运费'}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
            </div>
            <div class="form-group" id="shipping-fee-group" style="display: ${product.shippingType === 'fixed' ? 'block' : 'none'};">
                <label>固定运费 (元)</label>
                <input type="number" id="product-shipping-fee" value="${product.shippingFee}">
            </div>
            <div class="form-group">
                <label>发货方式</label>
                <input type="text" id="product-shipping-method" value="${product.shippingMethod || '快递发货'}">
            </div>
        `;

        getEl('shipping-type-selector').onclick = () => {
            const options = [{ value: 'free', text: '包邮' }, { value: 'fixed', text: '固定运费' }];
            showSelectionModal('运费设置', options, null, (value) => {
                getEl('shipping-type-text').textContent = value === 'free' ? '包邮' : '固定运费';
                getEl('shipping-fee-group').style.display = value === 'fixed' ? 'block' : 'none';
            });
        };

        getEl('save-product-btn').onclick = () => saveProduct(productId);
        getEl('edit-product-page-title').textContent = productId ? '编辑商品' : '添加商品';
        
        // ▼▼▼ 核心修复：在这里补上“上菜”的指令！ ▼▼▼
        showPage('page-edit-product');
    }



        function saveProduct(productId) {
        const name = getEl('product-name').value.trim();
        const price = parseFloat(getEl('product-price').value);
        if (!name || isNaN(price) || price <= 0) {
            showToast('请填写有效的商品名称和价格');
            return;
        }
        
        // ▼▼▼ 核心修复：在创建新对象前，先“抢救”旧的库存数据 ▼▼▼
        let currentStock = 0; // 默认为0，适用于新商品
        if (productId) {
            const originalProduct = userProfile.onlineStore.products.find(p => p.id === productId);
            if (originalProduct) {
                currentStock = originalProduct.stock; // 如果是编辑，就读取旧的库存
            }
        }
        // ▲▲▲ 修复完成 ▲▲▲

        const newProduct = {
            id: productId || `prod_${Date.now()}`,
            name,
            description: getEl('product-description').value.trim(),
            price,
            shippingType: getEl('shipping-type-text').textContent === '包邮' ? 'free' : 'fixed',
            shippingFee: parseFloat(getEl('product-shipping-fee').value) || 0,
            shippingMethod: getEl('product-shipping-method').value.trim() || '快递发货',
            stock: currentStock // ▼▼▼ 核心修复：将保存的库存数据写入新对象 ▼▼▼
        };

        if (productId) {
            const index = userProfile.onlineStore.products.findIndex(p => p.id === productId);
            if (index !== -1) {
                 userProfile.onlineStore.products[index] = newProduct;
            }
        } else {
            userProfile.onlineStore.products.push(newProduct);
        }
        
        saveUserProfile();
        showToast('商品已保存');
        renderOnlineStorePage('products');
        showPage('page-online-store');
    }



    function renderStoreMyPage() {
        const content = getEl('store-my-store-content');
        const orders = userProfile.onlineStore.orders || [];
        const earnings = userProfile.onlineStore.earnings || 0;
        
        const pendingOrders = orders.filter(o => o.status === 'pending');
        const shippedOrders = orders.filter(o => o.status === 'shipped');
        const completedOrders = orders.filter(o => o.status === 'completed');

        let pendingHtml = '';
        if (pendingOrders.length > 0) {
            pendingOrders.forEach(o => {
                pendingHtml += `
                    <div class="store-order-item" data-id="${o.id}">
                        <div class="order-header" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${o.productName}</span><span class="status">待发货</span>
                        </div>
                        <div class="order-body" style="font-size: 0.9rem; color: var(--text-color-medium); margin: 8px 0;">
                            由 ${o.buyerName} 购买
                        </div>
                        <button class="ship-order-btn btn-primary" data-id="${o.id}" style="width: 100%; padding: 8px; border: none; border-radius: 8px; margin-top: 5px;">立即发货</button>
                    </div>`;
            });
        } else {
            pendingHtml = '<p style="text-align:center; color: #ccc; font-size: 0.9rem; padding: 10px 0;">暂无待处理订单</p>';
        }

        let shippedHtml = '';
        if (shippedOrders.length > 0) {
             shippedOrders.forEach(o => {
                shippedHtml += `
                    <div class="store-order-item" data-id="${o.id}">
                        <div class="order-header" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${o.productName}</span>
                            <span class="status" style="color: #3498db;">物流运输中...</span>
                        </div>
                    </div>`;
            });
        } else {
            shippedHtml = '<p style="text-align:center; color: #ccc; font-size: 0.9rem; padding: 10px 0;">暂无在途订单</p>';
        }

        content.innerHTML = `
            <div class="my-streamer-dashboard">
                <div class="dashboard-item">
                    <div class="value">${pendingOrders.length}</div>
                    <div class="label">待发货订单</div>
                </div>
                <div class="dashboard-item" id="store-earnings-dashboard-btn">
                    <div class="value">¥${earnings.toFixed(2)}</div>
                    <div classlabel">可提取收入</div>
                </div>
            </div>
            <button id="generate-system-order-btn" class="btn-primary modal-btn" style="width: 100%; margin: 15px 0 5px 0;">
                <i class="fa-solid fa-wand-magic-sparkles"></i> 推广店铺/获取新订单
            </button>
            <h3 style="margin: 15px 0 10px 5px; font-size: 1rem;">待处理订单</h3>
            ${pendingHtml}
            <h3 style="margin: 20px 0 10px 5px; font-size: 1rem;">在途订单</h3>
            ${shippedHtml}
            <h3 style="margin: 20px 0 10px 5px; font-size: 1rem;">历史订单</h3>
            <div id="completed-orders-list"></div>
        `;

        const completedList = getEl('completed-orders-list');
        if (completedOrders.length > 0) {
            completedOrders.sort((a, b) => b.completedTimestamp - a.completedTimestamp).forEach(o => {
                const item = document.createElement('div');
                item.className = 'store-order-item';
                item.dataset.id = o.id;
                item.innerHTML = `
                    <div class="order-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>${o.productName}</span>
                        <span class="status completed">已完成</span>
                    </div>
                `;
                completedList.appendChild(item);
            });
        } else {
            completedList.innerHTML = '<p style="text-align:center; color: #ccc; font-size: 0.9rem; padding: 10px 0;">暂无历史订单</p>';
        }

        getEl('store-earnings-dashboard-btn').onclick = () => {
            renderStoreEarningsPage();
            showPage('page-store-earnings');
        };

        // ▼▼▼ 核心修复：这里是经过严格修正的发货逻辑 ▼▼▼
        content.querySelectorAll('.ship-order-btn').forEach(btn => btn.onclick = (e) => {
            e.stopPropagation();
            const orderId = btn.dataset.id;
            
            // 1. 根据ID精准找到订单
            const order = userProfile.onlineStore.orders.find(o => o.id === orderId);
            if (!order) {
                showToast('错误：找不到订单信息。');
                return;
            }

            // 2. 根据订单中的productId，精准找到对应的商品
            const product = userProfile.onlineStore.products.find(p => p.id === order.productId);

            // 3. 严格检查商品是否存在且库存充足
            if (!product) {
                showToast(`错误：找不到订单对应的商品 [${order.productName}]，无法发货。`);
                // 为防止死单，将此订单状态设为错误
                order.status = 'error';
                saveUserProfile();
                renderStoreMyPage();
                return;
            }
            if (product.stock <= 0) {
                showToast(`[${product.name}] 库存不足，无法发货！请先去进货。`);
                return;
            }
            
            // 4. 只对找到的这一个商品进行库存扣减
            product.stock -= 1; 

            // 5. 更新订单状态和发货时间
            order.status = 'shipped';
            order.shippedTimestamp = Date.now();
            
            // 6. 保存并刷新
            saveUserProfile();
            renderStoreMyPage();
            showToast('发货成功！库存已扣减。');
        });
        // ▲▲▲ 修复完成 ▲▲▲

        content.querySelectorAll('.store-order-item').forEach(item => item.onclick = () => {
            renderStoreOrderDetailsPage(item.dataset.id);
            showPage('page-store-order-details');
        });

        getEl('generate-system-order-btn').onclick = () => {
            const products = userProfile.onlineStore.products;
            if (!products || products.length === 0) {
                showToast('你的店铺还没有上架任何商品，无法获取订单哦！');
                return;
            }

            const numberOfOrders = Math.floor(Math.random() * 3) + 1;
            let newOrderCount = 0;

            for (let i = 0; i < numberOfOrders; i++) {
                const randomProduct = products[Math.floor(Math.random() * products.length)];
                const randomBuyerName = VIEWER_NAMES[Math.floor(Math.random() * VIEWER_NAMES.length)];

                const newOrder = {
                    id: `order_store_${Date.now()}_${i}`, 
                    productId: randomProduct.id,
                    productName: randomProduct.name,
                    buyerId: 'system_customer',
                    buyerName: randomBuyerName,
                    price: randomProduct.price,
                    shippingFee: randomProduct.shippingType === 'free' ? 0 : randomProduct.shippingFee,
                    total: randomProduct.price + (randomProduct.shippingType === 'free' ? 0 : randomProduct.shippingFee),
                    status: 'pending',
                    timestamp: new Date().toISOString(),
                    shippedTimestamp: null,
                    completedTimestamp: null
                };

                userProfile.onlineStore.orders.unshift(newOrder);
                newOrderCount++;
            }
            
            saveUserProfile();
            showToast(`叮咚！你收到了 ${newOrderCount} 笔新订单！`);
            renderStoreMyPage();
        };
    }


    function renderStoreOrderDetailsPage(orderId) {
        const content = getEl('store-order-details-content');
        const order = userProfile.onlineStore.orders.find(o => o.id === orderId);
        if(!order) { content.innerHTML = '订单未找到'; return; }
        content.innerHTML = `
            <div class="order-confirm-section">
                <div class="section-title">订单信息</div>
                <div class="order-item-row"><span>订单号</span><span>${order.id}</span></div>
                <div class="order-item-row"><span>购买人</span><span>${order.buyerName}</span></div>
                <div class="order-item-row"><span>下单时间</span><span>${new Date(order.timestamp).toLocaleString()}</span></div>
                <div class="order-item-row"><span>订单状态</span><span>${order.status}</span></div>
            </div>
            <div class="order-confirm-section">
                <div class="section-title">商品与金额</div>
                <div class="order-item-row"><span>${order.productName}</span><span>¥${order.price.toFixed(2)}</span></div>
                <div class="order-item-row"><span>运费</span><span>¥${order.shippingFee.toFixed(2)}</span></div>
                <div class="order-total-row">实付: <span>¥${order.total.toFixed(2)}</span></div>
            </div>
        `;
    }

    function renderStoreEarningsPage() {
        const content = getEl('store-earnings-content');
        const earnings = userProfile.onlineStore.earnings || 0;
        const orders = userProfile.onlineStore.orders || [];

        // ▼▼▼ 核心升级 1/2：筛选并生成收入明细HTML ▼▼▼
        
        // 1. 从所有订单中，只筛选出状态为“已完成”的订单作为收入来源
        const completedOrders = orders.filter(o => o.status === 'completed');
        
        // 2. 按完成时间倒序排列，最新的在最上面
        completedOrders.sort((a, b) => b.completedTimestamp - a.completedTimestamp);

        let historyHtml = '';
        if (completedOrders.length > 0) {
            completedOrders.forEach(order => {
                const date = new Date(order.completedTimestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute:'2-digit' });
                historyHtml += `
                    <div class="transaction-item">
                        <div class="transaction-details">
                            <div class="reason">售出: ${order.productName}</div>
                            <div class="date">买家: ${order.buyerName} | ${date}</div>
                        </div>
                        <div class="transaction-amount income">+${order.total.toFixed(2)}</div>
                    </div>
                `;
            });
        } else {
            historyHtml = '<div class="empty-placeholder" style="display:block; padding: 40px 0;">暂无收入明细</div>';
        }
        // ▲▲▲ 升级完成 ▲▲▲

        // ▼▼▼ 核心升级 2/2：重构页面整体HTML，加入明细列表 ▼▼▼
        content.innerHTML = `
            <div class="wallet-balance-card">
                <div class="balance-label">当前可提取收入 (元)</div>
                <div class="balance-amount"><span>${earnings.toFixed(2)}</span></div>
            </div>
            <div style="padding: 0 15px; margin-top: 20px;">
                 <button id="withdraw-store-earnings-btn" class="btn-primary modal-btn" style="width: 100%;">全部提取到钱包</button>
            </div>
            <div class="transaction-list-header">收入明细 (仅展示已完成的订单)</div>
            <div class="transaction-list">${historyHtml}</div>
        `;
        // ▲▲▲ 升级完成 ▲▲▲

        const btn = getEl('withdraw-store-earnings-btn');
        if (earnings <= 0) {
            btn.disabled = true;
            btn.textContent = '暂无可提取收入';
        } else {
            btn.onclick = () => {
                showConfirmModal('确认提取', `确定要将 ¥${earnings.toFixed(2)} 的小店收入提取到钱包吗？`, () => {
                    userProfile.walletBalance += earnings;
                    userProfile.walletHistory.push({ type: 'income', amount: earnings, reason: '网店收入提取', date: new Date().toISOString() });
                    userProfile.onlineStore.earnings = 0;
                    saveUserProfile();
                    showToast('提取成功！');
                    getEl('confirm-modal').classList.remove('visible');
                    renderOnlineStorePage('my-store');
                    showPage('page-online-store');
                });
            };
        }
    }

    // ▼▼▼ 新增：渲染仓库和进货市场的所有函数 ▼▼▼
    function renderStoreWarehousePage() {
        const content = getEl('store-warehouse-content');
        const products = userProfile.onlineStore.products || [];
        let html = '';
        if (products.length > 0) {
            products.forEach(p => {
                html += `
                    <div class="warehouse-item">
                        <div class="music-info">
                            <div class="music-title">${p.name}</div>
                        </div>
                        <div class="stock-count">${p.stock}</div>
                    </div>
                `;
            });
        } else {
            html = '<div class="empty-placeholder" style="display:block;"><p>仓库是空的，快去进货吧！</p></div>';
        }
        content.innerHTML = html;
    }

    function renderWholesaleMarketPage() {
        const content = getEl('wholesale-market-content');
        let html = '';
        for (const category in WHOLESALE_MARKET) {
            html += `<div class="wholesale-category"><div class="wholesale-category-title">${category}</div>`;
            WHOLESALE_MARKET[category].forEach(item => {
                html += `
                    <div class="wholesale-item" data-item-id="${item.id}">
                        <div class="music-info">
                            <div class="music-title">${item.name}</div>
                            <div class="cost">成本: ¥${item.cost.toFixed(2)}</div>
                        </div>
                        <i class="fa-solid fa-cart-plus" style="color: var(--accent-color);"></i>
                    </div>
                `;
            });
            html += `</div>`;
        }
        content.innerHTML = html;

        content.querySelectorAll('.wholesale-item').forEach(el => {
            el.onclick = () => showRestockModal(el.dataset.itemId);
        });
    }

    function showRestockModal(itemId) {
        const allItems = Object.values(WHOLESALE_MARKET).flat();
        const itemToRestock = allItems.find(item => item.id === itemId);
        if (!itemToRestock) return;

        const modal = getEl('restock-modal');
        const quantityInput = getEl('restock-quantity-input');
        const totalCostEl = getEl('restock-total-cost');
        const confirmBtn = getEl('confirm-restock-btn');

        getEl('restock-modal-title').textContent = `为“${itemToRestock.name}”进货`;
        getEl('restock-modal-info').textContent = itemToRestock.description;
        quantityInput.value = '';
        totalCostEl.textContent = '总成本: ¥0.00';
        confirmBtn.disabled = true;

        const updateTotalCost = () => {
            const quantity = parseInt(quantityInput.value) || 0;
            const totalCost = quantity * itemToRestock.cost;
            totalCostEl.textContent = `总成本: ¥${totalCost.toFixed(2)}`;
            confirmBtn.disabled = !(quantity > 0 && userProfile.walletBalance >= totalCost);
        };

        quantityInput.oninput = updateTotalCost;

        getEl('cancel-restock-btn').onclick = () => modal.classList.remove('visible');
        confirmBtn.onclick = () => {
            const quantity = parseInt(quantityInput.value);
            const totalCost = quantity * itemToRestock.cost;
            if (userProfile.walletBalance < totalCost) {
                showToast('钱包余额不足，无法进货！');
                return;
            }

            // 扣款
            userProfile.walletBalance -= totalCost;
            userProfile.walletHistory.push({ type: 'expense', amount: totalCost, reason: `进货: ${itemToRestock.name} x${quantity}`, date: new Date().toISOString() });
            
            // 查找仓库中是否已有该商品
            let productInStore = userProfile.onlineStore.products.find(p => p.wholesaleId === itemToRestock.id);
            if (productInStore) {
                // 如果有，只增加库存
                productInStore.stock += quantity;
            } else {
                // 如果没有，则创建一个新商品并上架
                productInStore = {
                    id: `prod_${Date.now()}`,
                    wholesaleId: itemToRestock.id, // 关联批发市场ID
                    name: itemToRestock.name,
                    description: itemToRestock.description,
                    price: parseFloat((itemToRestock.cost * 1.5).toFixed(2)), // 默认加价50%作为售价
                    shippingType: 'free',
                    shippingFee: 0,
                    shippingMethod: '快递发货',
                    stock: quantity
                };
                userProfile.onlineStore.products.push(productInStore);
            }

            saveUserProfile();
            showToast(`成功进货 ${itemToRestock.name} x${quantity}！`);
            modal.classList.remove('visible');
        };

        modal.classList.add('visible');
    }
    // ▲▲▲ 新增完成 ▲▲▲


    // ▲▲▲ 新增完成 ▲▲▲

    // ▼▼▼ 新增[1/2]：更新排行榜数据的核心“记账”函数 ▼▼▼
    function updateLeaderboard(streamerId, senderName, amount) {

        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) return;

        // 如果账本不存在，先创建一个
        if (!streamer.giftLeaderboard) {
            streamer.giftLeaderboard = {};
        }

        // 累加该用户的打赏金额
        streamer.giftLeaderboard[senderName] = (streamer.giftLeaderboard[senderName] || 0) + amount;

        saveLiveStreamData(); // 保存更新
    }
    
    // ▼▼▼ 新增[2/2]：渲染排行榜弹窗的函数 ▼▼▼
    function renderLeaderboardModal(streamerId) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer || !streamer.giftLeaderboard) return;

        const modal = getEl('leaderboard-modal');
        const contentArea = getEl('leaderboard-content-area');
        
        const leaderboardData = Object.entries(streamer.giftLeaderboard)
            .map(([name, total]) => ({ name, total }))
            .sort((a, b) => b.total - a.total); // 按总金额从高到低排序

        let contentHtml = '';
        if (leaderboardData.length === 0) {
            contentHtml = '<p style="text-align: center; padding: 20px 0;">还没有人送礼物哦，快来抢占榜一吧！</p>';
        } else {
            leaderboardData.forEach((entry, index) => {
                let rankIcon = '';
                if (index === 0) rankIcon = '<i class="fa-solid fa-trophy" style="color: #FFD700; width: 24px; text-align: center;"></i>';
                else if (index === 1) rankIcon = '<i class="fa-solid fa-trophy" style="color: #C0C0C0; width: 24px; text-align: center;"></i>';
                else if (index === 2) rankIcon = '<i class="fa-solid fa-trophy" style="color: #CD7F32; width: 24px; text-align: center;"></i>';
                else rankIcon = `<span style="display: inline-block; width: 24px; text-align: center; color: var(--text-color-medium);">${index + 1}</span>`;

                // 判断是否是玩家自己
                const isPlayer = entry.name === getPlayerDisplayName();
                
                contentHtml += `
                    <div class="transaction-item" style="gap: 15px; background-color: ${isPlayer ? 'var(--player-bubble-bg-light)' : 'transparent'}; border-radius: 8px;">
                        ${rankIcon}
                        <div class="transaction-details" style="flex-grow: 1;">
                            <div class="reason" style="font-weight: 600;">${entry.name}</div>
                        </div>
                        <div class="transaction-amount income" style="font-size: 0.9rem;">贡献值 ${entry.total.toFixed(2)}</div>
                    </div>
                `;
            });
        }
        
                contentArea.innerHTML = `<div class="transaction-list" style="margin:0; border-radius: 0; box-shadow: none; background: transparent;">${contentHtml}</div>`;
        modal.classList.add('visible');
    }

    // ▼▼▼ 新增：“心声重写引擎”函数 ▼▼▼
    async function regenerateInnerThought() {
        const regenerateBtn = getEl('regenerate-thought-btn');
        const convId = regenerateBtn.dataset.convId;
        if (!convId) return;

        const conversation = conversations.find(c => c.id === convId);
        const character = findContactById(conversation.contactId);
        if (!conversation || !character) return;

        regenerateBtn.classList.add('spinner'); // 显示加载动画

        try {
            let baseUrl = getEl('base-url').value.trim();
            if (baseUrl && !baseUrl.startsWith('http')) baseUrl = 'https://' + baseUrl;
            const settings = { baseUrl, apiKey: getEl('api-key').value.trim(), modelName: getEl('model-name').value.trim() };

            if (!settings.baseUrl || !settings.apiKey || !settings.modelName) {
                throw new Error('API未配置');
            }

            // 1. 构建与 triggerAiResponse 中完全一致的、最新的“表演指导”
            const systemPromptCore = `
# OVERRIDING DIRECTIVE: CORE IDENTITY & RULES
You are an AI actor in a deep role-play. Your primary function is to embody the character of ${character.name}.
# RULE 1: YOUR CHARACTER PERSONA (ABSOLUTE & UNBREAKABLE)
- Your Name: ${character.name}
- Your Core Persona & Background: ${character.background || '一个有个性的朋友'}
- Your Habits: ${character.habits || '无'}
- Your Dislikes: ${character.dislikes || '无'}
# RULE 2: YOUR KNOWLEDGE OF THE USER (ABSOLUTE & UNBREAKABLE)
- User's Name: ${userProfile.name}
- User's Gender: ${userProfile.gender}
# RULE 3: OUTPUT FORMAT (STRICTLY ENFORCED)
## A. Inner Thought (心声) - MANDATORY
### Acting Style Guide for Inner Thought:
- This is NOT a summary. This is your character's raw, unfiltered, emotional inner monologue. It should be full of feelings, not facts.
- Be Emotional & Subjective: Express happiness, confusion, shyness, annoyance, excitement, etc. Use emotional language.
- Connect to Persona: Let the conversation trigger thoughts related to your background, habits, and dislikes.
- Use Natural, Fragmented Language: Real thoughts are often short, jumpy, and full of questions or self-talk. Use oral language.
- FORBIDDEN: Do NOT write objective summaries. Do NOT sound like an AI analyzing data. Be a living character.
### Examples of Good Inner Thoughts:
- (Happy/Shy): "天呐，[他/她]居然还记得我上次说过的话...心里有点甜是怎么回事... >///<"
- (Confused/Anxious): "嗯？[他/她]为什么突然问这个...是不是我哪里说错话了？应该没有吧...有点慌。"
- (Connecting to Persona): "聊到旅行...又想起了以前在海边画画的日子。不知道下次什么时候才能再去。唉，还是专心回[他/她]消息吧。"
`;
            
            // 2. 设定一个只要求“重新思考”的任务
            const taskPrompt = `# TASK: REGENERATE INNER THOUGHT
Based on the provided chat history, regenerate a more natural and emotional inner thought for your last response.
You MUST ONLY output the [THOUGHT]...[/THOUGHT] block. Do NOT output any dialogue or actions.`;

            const finalSystemPrompt = `${systemPromptCore}\n${taskPrompt}`;

            // 3. 准备API消息（只包含“剧本”和历史记录）
            const messagesForApi = [
                { role: 'system', content: finalSystemPrompt },
                ...conversation.history
            ];

            const cleanedBaseUrl = settings.baseUrl.endsWith('/') ? settings.baseUrl.slice(0, -1) : settings.baseUrl;
            const finalUrl = `${cleanedBaseUrl}/v1/chat/completions`;

            const response = await fetch(finalUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.apiKey}` },
                body: JSON.stringify({ model: settings.modelName, messages: messagesForApi, stream: false })
            });

            if (!response.ok) throw new Error('API请求失败');
            const data = await response.json();
            const replyContent = data.choices[0].message.content;
            
            const thoughtMatch = replyContent.match(/\[THOUGHT\]([\s\S]*?)\[\/THOUGHT\]/i);
            if (thoughtMatch) {
                const newThought = thoughtMatch[1].trim();
                // 4. 更新并保存
                conversation.aiState.innerThought = newThought;
                saveConversations();
                // 5. 实时刷新弹窗内容
                getEl('thought-modal-content-area').querySelector('.thought-content').textContent = newThought;
                showToast('心声已润色！');
            } else {
                throw new Error('AI未能生成有效的心声');
            }

        } catch (error) {
            showToast(`润色失败: ${error.message}`);
        } finally {
            regenerateBtn.classList.remove('spinner'); // 移除加载动画
        }
    }
    // ▲▲▲ 新增完成 ▲▲▲








    // ▲▲▲ 新增完成 ▲▲▲


    // 新增：处理主播头像更换的函数
    function handleStreamerAvatarChange(event, streamerId) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                const streamer = liveStreamData.find(s => s.id === streamerId);
                if (streamer) {
                    streamer.avatar = dataUrl; // 更新数据
                    getEl('live-room-streamer-avatar').src = dataUrl; // 立即更新界面
                    saveLiveStreamData(); // 保存到localStorage
                    showToast('主播头像已更新');
                }
            };
            reader.readAsDataURL(file);
        }
    }

    // 新增：渲染创建直播间页面的函数
    function renderCreateStreamerPage() {
        tempAvatarDataUrl = 'https://s2.loli.net/2023/05/23/gM3FPAfWk1vYc8z.png'; 
        const formContent = getEl('create-streamer-form-content');

        formContent.innerHTML = `
            <div class="avatar-upload-area">
                <img id="streamer-avatar-preview" class="avatar-preview" src="${tempAvatarDataUrl}">
                <span style="font-size: 0.8rem; color: var(--text-color-medium);">点击头像更换</span>
                <input type="file" id="new-streamer-avatar-input" class="avatar-file-input" accept="image/*">
            </div>
            <div class="form-group">
                <label>主播名字 (必填)</label>
                <input type="text" id="new-streamer-name" placeholder="为你的主播起个名字">
            </div>
            <div class="form-group">
                <label>直播间标题 (必填)</label>
                <input type="text" id="new-streamer-title" placeholder="一个吸引人的直播标题">
            </div>
            <div class="form-group">
                <label>初始粉丝数 (选填)</label>
                <input type="text" id="new-streamer-followers" placeholder="例如: 1.5w">
            </div>

            <!-- 新增：性别选择器 -->
            <div class="form-group selectable" id="streamer-gender-selector">
                <label>性别</label>
                <div class="form-value">
                    <span id="streamer-gender-text">不设置</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="new-streamer-gender" value="不设置">
            </div>

            <!-- 直播类型选择器 -->
            <div class="form-group selectable" id="streamer-category-selector">
                <label>直播类型</label>
                <div class="form-value">
                    <span id="streamer-category-text">游戏</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="new-streamer-category" value="游戏">
            </div>

            <!-- 绑定好友选择器 -->
            <div class="form-group selectable" id="streamer-link-contact-selector">
                <label>绑定好友人设 (可选)</label>
                <div class="form-value">
                    <span id="streamer-link-contact-text">不绑定</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="linked-contact-id" value="none">
            </div>
        `;

        getEl('streamer-avatar-preview').onclick = () => getEl('new-streamer-avatar-input').click();
        getEl('new-streamer-avatar-input').onchange = (e) => handleAvatarChange(e, 'streamer-avatar-preview');

        // 新增：为性别选择器绑定事件
        getEl('streamer-gender-selector').onclick = () => {
            const options = [
                { value: '男', text: '男' },
                { value: '女', text: '女' },
                { value: '不设置', text: '不设置' }
            ];
            showSelectionModal('选择性别', options, getEl('new-streamer-gender').value, (selectedValue) => {
                getEl('new-streamer-gender').value = selectedValue;
                getEl('streamer-gender-text').textContent = selectedValue;
            });
        };

                getEl('streamer-category-selector').onclick = () => {
            const options = [ 
                { value: '游戏', text: '游戏' }, 
                { value: '美妆', text: '美妆' }, 
                { value: '唱歌', text: '唱歌' }, 
                { value: '跳舞', text: '跳舞' }, 
                { value: '聊天', text: '聊天' }, 
                { value: '美食', text: '美食' },
                // ▼▼▼ 新增的选项 ▼▼▼
                { value: '画画', text: '画画' },
                { value: '哄睡', text: '哄睡' },
                { value: '钢琴', text: '钢琴' }
                // ▲▲▲ 新增完成 ▲▲▲
            ];
            showSelectionModal('选择直播类型', options, getEl('new-streamer-category').value, (selectedValue) => {
                getEl('new-streamer-category').value = selectedValue;
                getEl('streamer-category-text').textContent = selectedValue;
            });
        };


        getEl('streamer-link-contact-selector').onclick = () => {
            const options = [{ value: 'none', text: '不绑定' }];
            contacts.friends.forEach(f => {
                options.push({ value: f.id, text: getDisplayName(f) });
            });
            showSelectionModal('选择要绑定的好友', options, getEl('linked-contact-id').value, (selectedValue) => {
                getEl('linked-contact-id').value = selectedValue;
                const selectedFriend = contacts.friends.find(f => f.id === selectedValue);
                getEl('streamer-link-contact-text').textContent = selectedFriend ? getDisplayName(selectedFriend) : '不绑定';
            });
        };
    }


    // 新增：保存新建直播间的函数
    function saveNewStreamer() {
        const name = getEl('new-streamer-name').value.trim();
        const title = getEl('new-streamer-title').value.trim();
        if (!name || !title) {
            showToast('主播名字和直播间标题不能为空');
            return;
        }

        const linkedContactId = getEl('linked-contact-id').value;
        let persona = ''; // 默认为空人设
        if (linkedContactId && linkedContactId !== 'none') {
            const linkedFriend = contacts.friends.find(f => f.id === linkedContactId);
            if (linkedFriend) {
                persona = linkedFriend.background || ''; // 获取好友的背景资料作为人设
            }
        }

        const newStreamer = {
            id: `streamer_${Date.now()}`,
            name: name,
            avatar: tempAvatarDataUrl,
            title: title,
            followers: getEl('new-streamer-followers').value.trim() || '0',
            gender: getEl('new-streamer-gender').value, // 新增
            category: getEl('new-streamer-category').value,
            isLive: true,
            viewers: 0,
            persona: persona, // 保存人设信息
            linkedContactId: linkedContactId, // 保存绑定的好友ID
        };

        liveStreamData.push(newStreamer);
        saveLiveStreamData();
        showToast(`直播间 [${name}] 创建成功！`);
        
        renderLiveStreamPage('recommended'); // 核心修改：刷新直播中心并跳转到“推荐”标签页
        showPage('page-live-stream');
    }

      // 新增：渲染修改主播信息页面的函数
    function renderEditStreamerPage(streamerId) {
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) {
            showToast('找不到该主播的信息');
            showPage('page-live-stream');
            return;
        }

        tempAvatarDataUrl = streamer.avatar;
        const formContent = getEl('edit-streamer-form-content');

        formContent.innerHTML = `
            <div class="avatar-upload-area">
                <img id="edit-streamer-avatar-preview" class="avatar-preview" src="${streamer.avatar}">
                <span style="font-size: 0.8rem; color: var(--text-color-medium);">点击头像更换</span>
                <input type="file" id="edit-streamer-avatar-input" class="avatar-file-input" accept="image/*">
            </div>
            <div class="form-group">
                <label>主播名字</label>
                <input type="text" id="edit-streamer-name" value="${streamer.name}">
            </div>
            <div class="form-group">
                <label>直播间标题</label>
                <input type="text" id="edit-streamer-title" value="${streamer.title}">
            </div>
            <div class="form-group">
                <label>粉丝数</label>
                <input type="text" id="edit-streamer-followers" value="${streamer.followers}">
            </div>

            <!-- 新增：性别选择器 -->
            <div class="form-group selectable" id="edit-streamer-gender-selector">
                <label>性别</label>
                <div class="form-value">
                    <span id="edit-streamer-gender-text">${streamer.gender || '不设置'}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-streamer-gender" value="${streamer.gender || '不设置'}">
            </div>

            <div class="form-group selectable" id="edit-streamer-category-selector">
                <label>直播类型</label>
                <div class="form-value">
                    <span id="edit-streamer-category-text">${streamer.category || '游戏'}</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-streamer-category" value="${streamer.category || '游戏'}">
            </div>

            <div class="form-group selectable" id="edit-streamer-link-contact-selector">
                <label>绑定好友人设</label>
                <div class="form-value">
                    <span id="edit-streamer-link-contact-text">不绑定</span>
                    <i class="fa-solid fa-chevron-right"></i>
                </div>
                <input type="hidden" id="edit-linked-contact-id" value="${streamer.linkedContactId || 'none'}">
            </div>
        `;
        
        const linkedFriend = contacts.friends.find(f => f.id === streamer.linkedContactId);
        getEl('edit-streamer-link-contact-text').textContent = linkedFriend ? getDisplayName(linkedFriend) : '不绑定';

        getEl('edit-streamer-avatar-preview').onclick = () => getEl('edit-streamer-avatar-input').click();
        getEl('edit-streamer-avatar-input').onchange = (e) => handleAvatarChange(e, 'edit-streamer-avatar-preview');

        // ▼▼▼ BUG修复：补全下面这3个缺失的事件绑定 ▼▼▼

        // 1. 为性别选择器绑定事件
        getEl('edit-streamer-gender-selector').onclick = () => {
            const options = [ { value: '男', text: '男' }, { value: '女', text: '女' }, { value: '不设置', text: '不设置' } ];
            showSelectionModal('选择性别', options, getEl('edit-streamer-gender').value, (selectedValue) => {
                getEl('edit-streamer-gender').value = selectedValue;
                getEl('edit-streamer-gender-text').textContent = selectedValue;
            });
        };

        // 2. 为直播类型选择器绑定事件
        getEl('edit-streamer-category-selector').onclick = () => {
             const options = [
                { value: '游戏', text: '游戏' }, 
                { value: '美妆', text: '美妆' }, 
                { value: '唱歌', text: '唱歌' }, 
                { value: '跳舞', text: '跳舞' }, 
                { value: '聊天', text: '聊天' }, 
                { value: '美食', text: '美食' },
                { value: '画画', text: '画画' },
                { value: '哄睡', text: '哄睡' },
                { value: '钢琴', text: '钢琴' }
            ];
            showSelectionModal('选择直播类型', options, getEl('edit-streamer-category').value, (selectedValue) => {
                getEl('edit-streamer-category').value = selectedValue;
                getEl('edit-streamer-category-text').textContent = selectedValue;
            });
        };

        // 3. 为绑定好友选择器绑定事件
        getEl('edit-streamer-link-contact-selector').onclick = () => {
            const options = [{ value: 'none', text: '不绑定' }];
            contacts.friends.forEach(f => {
                options.push({ value: f.id, text: getDisplayName(f) });
            });
            showSelectionModal('选择要绑定的好友', options, getEl('edit-linked-contact-id').value, (selectedValue) => {
                getEl('edit-linked-contact-id').value = selectedValue;
                const selectedFriend = contacts.friends.find(f => f.id === selectedValue);
                getEl('edit-streamer-link-contact-text').textContent = selectedFriend ? getDisplayName(selectedFriend) : '不绑定';
            });
        };
        
        // ▲▲▲ BUG修复完成 ▲▲▲
        
        getEl('save-edited-streamer-btn').dataset.streamerId = streamerId;
        
        // 关键修复：补上这句“显示页面”的指令
        showPage('page-edit-streamer');
    }




    // 新增：保存修改后主播信息的函数
    function saveEditedStreamer() {
        const streamerId = getEl('save-edited-streamer-btn').dataset.streamerId;
        const streamer = liveStreamData.find(s => s.id === streamerId);
        if (!streamer) {
            showToast('保存失败，找不到主播');
            return;
        }

        const name = getEl('edit-streamer-name').value.trim();
        const title = getEl('edit-streamer-title').value.trim();
        if (!name || !title) {
            showToast('主播名字和直播间标题不能为空');
            return;
        }

        const linkedContactId = getEl('edit-linked-contact-id').value;
        let persona = '';
        if (linkedContactId && linkedContactId !== 'none') {
            const linkedFriend = contacts.friends.find(f => f.id === linkedContactId);
            if (linkedFriend) persona = linkedFriend.background || '';
        }

        // 更新主播对象的所有属性
        streamer.avatar = tempAvatarDataUrl;
        streamer.name = name;
        streamer.title = title;
streamer.followers = getEl('edit-streamer-followers').value.trim();
        streamer.gender = getEl('edit-streamer-gender').value; // 新增
        streamer.category = getEl('edit-streamer-category').value;
        streamer.persona = persona;
        streamer.linkedContactId = linkedContactId;

        saveLiveStreamData();
        showToast('主播信息已更新！');
        renderLiveStreamPage('my'); // 刷新并回到“我的”标签页
        showPage('page-live-stream');
    }




    // --- 9. 初始化 ---
    loadAllData();
    loadTakeoutData();
    loadLiveStreamData(); // 新增：加载虚拟主播数据

    renderAll();
    bindEvents();


});
</script>
    <!-- ▼▼▼ 修改：消息长按操作菜单 (V3.0) ▼▼▼ -->
    <div id="message-context-menu" class="context-menu">
        <div class="context-menu-item" id="menu-item-recall">撤回</div>
        <div class="context-menu-item" id="menu-item-delete">删除</div>
        <div class="context-menu-item" id="menu-item-quote">引用</div>
        <div class="context-menu-item" id="menu-item-edit">编辑</div>
    </div>
    <!-- ▲▲▲ 修改完成 ▲▲▲ -->


    <!-- ▼▼▼ 新增：用于查看已撤回消息的弹窗 ▼▼▼ -->
    <div id="view-withdrawn-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">被撤回的消息</h3>
            <p id="withdrawn-message-content" style="text-align: center; padding: 10px 0; word-break: break-word;"></p>
            <div class="modal-actions">
                <button class="modal-btn btn-primary" id="close-withdrawn-modal-btn" style="flex: 1;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：发送语音弹窗 ▼▼▼ -->
    <div id="voice-input-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">发送语音</h3>
            <div class="form-group" style="padding: 0; background: transparent;">
                <label style="padding-left: 5px;">语音内容 (文本)</label>
                <textarea id="voice-message-textarea" placeholder="输入语音消息内容..."></textarea>
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="cancel-voice-btn">取消</button>
                <button class="modal-btn btn-primary" id="send-voice-btn">发送</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：编辑朋友圈动态弹窗 ▼▼▼ -->
    <div id="edit-moment-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">编辑动态</h3>
            <div class="form-group" style="padding: 0; background: transparent;">
                <textarea id="edit-moment-textarea" style="min-height: 120px;"></textarea>
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="cancel-edit-moment-btn">取消</button>
                <button class="modal-btn btn-primary" id="save-edited-moment-btn">保存</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：朋友圈动态操作菜单 ▼▼▼ -->
    <div id="moment-context-menu" class="context-menu">
        <div class="context-menu-item" id="menu-item-moment-edit">编辑</div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：主播卡片操作菜单 ▼▼▼ -->
    <div id="streamer-context-menu" class="context-menu" style="flex-direction: column; align-items: stretch; padding: 5px;">
        <div class="context-menu-item" id="menu-item-streamer-edit" style="border:none; border-radius: 8px;">
            <i class="fa-solid fa-pen-to-square" style="width: 20px; text-align: center; margin-right: 8px;"></i>
            <span>编辑信息</span>
        </div>
        <div class="context-menu-item" id="menu-item-streamer-delete" style="border:none; border-radius: 8px; color: var(--danger-color);">
            <i class="fa-solid fa-trash-can" style="width: 20px; text-align: center; margin-right: 8px;"></i>
            <span>删除直播间</span>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：会话列表长按菜单 ▼▼▼ -->
    <div id="conversation-context-menu" class="context-menu" style="flex-direction: column; align-items: stretch; padding: 5px;">
        <div class="context-menu-item" id="menu-item-pin" style="border:none; border-radius: 8px;">置顶</div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <div id="moment-context-menu" class="context-menu">
        <div class="context-menu-item" id="menu-item-moment-edit">编辑</div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：转账弹窗 ▼▼▼ -->
    <div id="transfer-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="transfer-modal-header" id="transfer-modal-header">
                转账给 某某
            </div>
            <div class="transfer-modal-body">
                <label>转账金额</label>
                <div class="transfer-amount-input-wrapper">
                    <span>¥</span>
                    <input type="number" id="transfer-amount-input" placeholder="0.00">
                </div>
                <!-- ▼▼▼ 新增的备注输入框 ▼▼▼ -->
                <input type="text" id="transfer-memo-input" placeholder="添加转账说明(选填)" style="width: 100%; border: none; outline: none; background: transparent; padding: 15px 0; font-size: 0.9rem; border-bottom: 1px solid var(--border-color);">
            </div>

            <div class="transfer-modal-footer">
                <button class="transfer-confirm-btn" id="confirm-transfer-btn" disabled>转账</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：转账操作弹窗 ▼▼▼ -->
    <div id="transfer-action-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">确认收款</h3>
            <p id="transfer-action-info" style="text-align: center; color: var(--text-color-medium); font-size: 0.9rem; margin-bottom: 20px;"></p>
            <div class="modal-actions" style="flex-direction: column;">
                <button class="modal-btn btn-primary" id="receive-transfer-btn">确认收款</button>
                <button class="modal-btn btn-secondary" id="return-transfer-btn">立即退还</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

       <!-- ▼▼▼ 升级：悬浮音乐播放器与弹窗 ▼▼▼ -->
    <audio id="global-audio-player"></audio>

    <div id="music-player-card">
        <div class="player-header" id="player-header">
            <i class="fas fa-chevron-down player-collapse-btn" id="player-collapse-btn"></i>
            <span class="player-header-title" id="player-header-title-text">一起听歌中</span>

            <div class="header-collapsed-content">
                <div class="header-avatar-stack">
                    <img id="header-user-avatar" class="header-avatar">
                    <img id="header-contact-avatar" class="header-avatar">
                </div>
                <span id="header-lyric" class="header-lyric">...</span>
            </div>
            <i class="fas fa-times player-close-btn" id="player-close-btn"></i>
        </div>
        <div class="player-main-content">
            <div class="player-avatar-stack" id="player-avatar-stack">
                <img id="player-user-avatar" class="player-avatar">
                <img id="player-contact-avatar" class="player-avatar">
            </div>
            <div class="player-song-info">
                <div id="player-title" class="player-title">歌曲名</div>
                <div id="player-artist" class="player-artist">歌手</div>
            </div>
            <div class="lyrics-container" id="lyrics-container">
                <div class="lyrics-wrapper" id="lyrics-wrapper"></div>
            </div>
            <div class="player-controls-wrapper">
                <div class="player-progress-bar-wrapper">
                    <span id="player-current-time">00:00</span>
                    <div class="player-progress-bar" id="player-progress-bar">
                        <div class="player-progress" id="player-progress"></div>
                    </div>
                    <span id="player-duration">00:00</span>
                </div>
                <div class="player-controls">
                    <i class="fas fa-random player-control-btn" id="player-mode-btn" title="列表循环"></i>
                    <i class="fas fa-backward-step player-control-btn" id="player-prev-btn"></i>
                    <i class="fas fa-play-circle player-control-btn player-play-btn" id="player-play-btn"></i>
                    <i class="fas fa-forward-step player-control-btn" id="player-next-btn"></i>
                    <i class="fas fa-list-ul player-control-btn" id="player-playlist-btn" title="播放列表"></i>
                </div>
            </div>
        </div>
    </div>

    <div id="add-music-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">添加歌曲到音乐库</h3>
            <div class="modal-body">
                <div class="form-group" style="padding:0; background:none; margin-bottom: 15px;">
                    <label>歌曲名 (*)</label>
                    <input type="text" id="add-music-title-input" class="api-setting-item" style="width:100%; border:1px solid #ddd; border-radius:4px; padding:8px;">
                </div>
                <div class="form-group" style="padding:0; background:none; margin-bottom: 15px;">
                    <label>歌手 (*)</label>
                    <input type="text" id="add-music-artist-input" class="api-setting-item" style="width:100%; border:1px solid #ddd; border-radius:4px; padding:8px;">
                </div>
                <div class="form-group" style="padding:0; background:none; margin-bottom: 15px;">
                    <label>歌曲URL (*)</label>
                    <input type="text" id="add-music-url-input" class="api-setting-item" style="width:100%; border:1px solid #ddd; border-radius:4px; padding:8px;">
                </div>
                <!-- ▼▼▼ 改造：接收网易云歌曲ID ▼▼▼ -->
                <div class="form-group" style="padding:0; background:none;">
                    <label>网易云歌曲ID (选填)</label>
                    <input type="text" id="add-music-netease-id-input" class="api-setting-item" style="width:100%; border:1px solid #ddd; border-radius:4px; padding:8px;" placeholder="例如: 1889506664">
                </div>
                <!-- ▲▲▲ 改造完成 ▲▲▲ -->

            </div>
            <div class="modal-actions">

                <button class="modal-btn btn-secondary" id="close-add-music-modal">取消</button>
                <button class="modal-btn btn-primary" id="save-music-btn">保存</button>
            </div>
        </div>
    </div>
    
    <div id="share-music-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">分享音乐</h3>
            <div id="music-library-picker" class="modal-body" style="max-height: 300px; overflow-y: auto;">
                <!-- 音乐库列表将由JS动态生成 -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="close-share-music-modal">取消</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 升级完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：播放列表弹窗 ▼▼▼ -->
    <div id="playlist-modal" class="modal-overlay from-bottom">
        <div class="modal-content">
            <h3 class="modal-header">播放列表</h3>
            <div id="playlist-modal-content" class="modal-body" style="max-height: 350px; overflow-y: auto; padding: 0 10px;">
                <!-- 播放列表将由JS动态生成 -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-primary" id="close-playlist-modal-btn" style="flex: 1;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：外卖详细购物车弹窗 ▼▼▼ -->
    <div id="detailed-cart-modal" class="modal-overlay from-bottom">
        <div class="modal-content">
            <h3 class="modal-header">购物车详情</h3>
            <div id="detailed-cart-list" class="modal-body" style="max-height: 350px; overflow-y: auto; padding: 0 10px;">
                <!-- 购物车商品列表将由JS动态生成 -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-primary" id="close-detailed-cart-btn" style="flex: 1;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：用户为好友支付的确认弹窗 ▼▼▼ -->
    <div id="player-pay-confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header" id="player-pay-confirm-title">为TA付款</h3>
            <div id="player-pay-confirm-body" style="padding: 10px 0;">
                <!-- 订单详情将由JS动态生成 -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="player-pay-cancel-btn">残忍拒绝</button>
                <button class="modal-btn btn-primary" id="player-pay-confirm-btn">豪爽买单</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：发送红包弹窗 ▼▼▼ -->
    <div id="red-packet-modal" class="modal-overlay">
        <div class="modal-content" style="padding: 0; overflow: hidden;">
            <div class="transfer-modal-header" id="red-packet-modal-header">发红包</div>
            <div class="transfer-modal-body">
                <div class="transfer-amount-input-wrapper">
                    <span>¥</span>
                    <input type="number" id="red-packet-amount-input" placeholder="0.00">
                </div>
                <input type="text" id="red-packet-memo-input" placeholder="恭喜发财，大吉大利" style="width: 100%; border: none; outline: none; background: #f7f7f7; padding: 10px 15px; font-size: 0.9rem; border-radius: 8px; margin-top: 15px; text-align: center;">
            </div>
            <div class="transfer-modal-footer">
                <button class="transfer-confirm-btn" id="confirm-red-packet-btn" disabled>塞钱进红包</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：红包领取详情弹窗 ▼▼▼ -->
    <div id="red-packet-details-modal" class="modal-overlay">
        <div class="modal-content" style="text-align: center;">
            <img id="rp-details-avatar" class="avatar-preview" style="width: 60px; height: 60px; margin: 0 auto 10px;">
            <p id="rp-details-sender-name" style="font-weight: 500;"></p>
            <p id="rp-details-memo" style="color: var(--text-color-medium); font-size: 0.9rem; margin-top: 5px;"></p>
            <p id="rp-details-amount" style="font-size: 2rem; font-weight: 600; margin: 20px 0;"></p>
            <div class="modal-actions" style="margin-top: 15px;">
                <button class="modal-btn btn-primary" id="close-rp-details-btn" style="flex: 1;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->
    <!-- ▼▼▼ 新增：用户开启直播设置弹窗 ▼▼▼ -->
    <div id="user-stream-setup-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">开启我的直播</h3>
            <div class="form-group" style="padding:0; background: transparent;">
                <label>直播标题</label>
                <input type="text" id="user-stream-title-input" class="api-setting-item" style="width:100%; border:1px solid var(--border-color); border-radius:8px; padding:8px;" placeholder="给你的直播起个标题吧">
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="cancel-user-stream-btn">取消</button>
                <button class="modal-btn btn-primary" id="start-user-stream-btn">开始直播</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->


    <!-- ▼▼▼ 新增：外卖评价专用弹窗 ▼▼▼ -->
    <div id="review-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">发表评价</h3>
            <div class="form-group" style="padding:0; background: transparent;">
                <textarea id="review-textarea" placeholder="输入你的评价内容..." style="min-height: 100px;"></textarea>
            </div>
            <div class="member-item" style="padding: 10px 5px; justify-content: flex-end;">
                <label for="anonymous-review-checkbox" style="font-size: 0.9rem; margin: 0 10px 0 0;">匿名评价</label>
                <input type="checkbox" id="anonymous-review-checkbox" style="width: 18px; height: 18px; margin: 0;">
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="cancel-review-btn">取消</button>
                <button class="modal-btn btn-primary" id="submit-review-btn">提交</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->




    <!-- ▼▼▼ 新增：微博帖子操作菜单 ▼▼▼ -->
    <div id="weibo-context-menu" class="context-menu" style="flex-direction: column; align-items: stretch; padding: 5px;">
        <div class="context-menu-item" id="menu-item-weibo-edit" style="border:none; border-radius: 8px;">
            <i class="fa-solid fa-pen-to-square" style="width: 20px; text-align: center; margin-right: 8px;"></i>
            <span>编辑</span>
        </div>
        <div class="context-menu-item" id="menu-item-weibo-delete" style="border:none; border-radius: 8px; color: var(--danger-color);">
            <i class="fa-solid fa-trash-can" style="width: 20px; text-align: center; margin-right: 8px;"></i>
            <span>删除</span>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->



    <!-- ▼▼▼ 新增：礼物弹窗 ▼▼▼ -->
    <div id="gift-modal" class="modal-overlay from-bottom">
        <div class="modal-content" style="padding: 0;">
            <h3 class="modal-header" style="padding: 15px; margin: 0; border-bottom: 1px solid var(--border-color);">赠送礼物</h3>
            <div id="gift-panel-content" class="modal-body" style="max-height: 250px; overflow-y: auto; padding: 0;">
                <!-- 礼物列表将由JS动态生成 -->
            </div>
            <div class="modal-actions">
                <div class="wallet-balance-display">
                    <i class="fa-solid fa-wallet" style="color: var(--text-color-medium);"></i>
                    余额: <span id="gift-modal-balance">¥0.00</span>
                </div>
                <button class="modal-btn btn-primary" id="send-gift-confirm-btn" disabled>赠送</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：打赏排行榜弹窗 ▼▼▼ -->
    <div id="leaderboard-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header">打赏贡献榜</h3>
            <div id="leaderboard-content-area" style="max-height: 60vh; overflow-y: auto; padding: 0 5px;">
                <!-- 排行榜内容将由JS动态生成 -->
            </div>
            <div class="modal-actions" style="margin-top: 15px;">
                <button class="modal-btn btn-primary" id="close-leaderboard-modal-btn" style="width: 100%;">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：商品进货弹窗 ▼▼▼ -->
    <div id="restock-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-header" id="restock-modal-title">商品进货</h3>
            <div class="transfer-modal-body" style="padding-top: 15px;">
                <p id="restock-modal-info" style="text-align: center; color: var(--text-color-medium); font-size: 0.9rem; margin-bottom: 20px;"></p>
                <label>进货数量</label>
                <div class="transfer-amount-input-wrapper">
                    <input type="number" id="restock-quantity-input" placeholder="0" style="font-size: 1.8rem; text-align: center;">
                </div>
                <p id="restock-total-cost" style="text-align: right; margin-top: 10px; font-weight: 600;"></p>
            </div>
            <div class="modal-actions">
                <button class="modal-btn btn-secondary" id="cancel-restock-btn">取消</button>
                <button class="modal-btn btn-primary" id="confirm-restock-btn" disabled>确认进货</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->


    <!-- ▼▼▼ 新增：网店经营相关页面 ▼▼▼ -->
     <div id="page-online-store" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-online-store-btn"></i></div>
            <h1 id="online-store-page-title">商品管理</h1>
            <div class="header-right"></div>
        </div>
        <div class="page-content" style="background-color: var(--bg-main); padding: 10px 10px 60px 10px;">
            <div class="live-tab-content active" id="store-products-content">
                <!-- 商品管理列表将由JS动态生成 -->
            </div>
            <div class="live-tab-content" id="store-my-store-content">
                <!-- 我的小店页面将由JS动态生成 -->
            </div>
        </div>
        <!-- 新增的底部图标导航栏 -->
        <div id="online-store-bottom-nav">
            <div class="store-tab-btn active" data-tab="products">
                <i class="fa-solid fa-boxes-stacked"></i>
                <span>商品列表</span>
            </div>
            <div class="store-tab-btn" data-tab="my-store">
                <i class="fa-solid fa-user-tie"></i>
                <span>我的小店</span>
            </div>
        </div>
    </div>


    <div id="page-edit-product" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-edit-product-btn"></i></div>
            <h1 id="edit-product-page-title">添加商品</h1>
            <div class="header-right"><button class="header-btn" id="save-product-btn">保存</button></div>
        </div>
        <div class="page-content page-form-content" id="edit-product-form-content">
            <!-- 商品编辑表单将由JS动态生成 -->
        </div>
    </div>

    <div id="page-store-order-details" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-store-order-details-btn"></i></div>
            <h1>订单详情</h1>
            <div class="header-right"></div>
        </div>
        <div class="page-content" id="store-order-details-content" style="padding: 15px;">
            <!-- 订单详情将由JS动态生成 -->
        </div>
    </div>

    <div id="page-store-earnings" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" id="back-from-store-earnings-btn"></i></div>
            <h1>小店收入</h1>
            <div class="header-right"></div>
        </div>
        <div class="page-content" id="store-earnings-content">
            <!-- 收入页面将由JS动态生成 -->
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->

    <!-- ▼▼▼ 新增：仓库和进货市场页面 ▼▼▼ -->
    <div id="page-store-warehouse" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" data-target-page="page-online-store"></i></div>
            <h1>我的仓库</h1>
            <div class="header-right"></div>
        </div>
        <div class="page-content" id="store-warehouse-content" style="padding: 10px;">
            <!-- 仓库库存列表将由JS动态生成 -->
        </div>
    </div>

    <div id="page-wholesale-market" class="page">
        <div class="page-header">
            <div class="header-left"><i class="fa-solid fa-chevron-left header-icon" data-target-page="page-online-store"></i></div>
            <h1>进货市场</h1>
            <div class="header-right"></div>
        </div>
        <div class="page-content" id="wholesale-market-content" style="padding: 10px;">
            <!-- 市场商品将由JS动态生成 -->
        </div>
    </div>
    <!-- ▲▲▲ 新增完成 ▲▲▲ -->


</body>





</html>

